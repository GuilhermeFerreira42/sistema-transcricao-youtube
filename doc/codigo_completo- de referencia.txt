==========================================
Conteúdo de app.py (caminho: app.py):
==========================================
"""
Aplicação de Chat com Persistência e Processamento de Dados

Este módulo contém a aplicação principal Flask e implementa uma interface
de chat que suporta conversas persistentes com uma IA e processamento
de vídeos do YouTube.

Funcionalidades principais:
- Interface web para conversas com IA (Ollama - gemma2:2b)
- Persistência de conversas em arquivos JSON
- Processamento de transcrições de vídeos do YouTube
- Geração de resumos para conteúdo de vídeos
- Comunicação em tempo real via WebSockets
"""

import init_eventlet

from flask import Flask, render_template, request, jsonify, Response
import json
import os
import logging
import logging.handlers
import traceback
from datetime import datetime
import requests
import argparse
from youtube_handler import YoutubeHandler
from flask_socketio import SocketIO, emit, join_room, leave_room
from uuid import uuid4
from utils.chat_storage import (
    create_new_conversation,
    add_message_to_conversation,
    get_conversation_by_id,
    get_conversation_history,
    delete_conversation,
    rename_conversation,
    update_message_in_conversation
)
import re

# Configuração do sistema de logging
def setup_logger():
    log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logs')
    os.makedirs(log_dir, exist_ok=True)
    
    # Nome do arquivo de log com data
    log_filename = os.path.join(log_dir, f'app_{datetime.now().strftime("%Y%m%d")}.log')
    
    # Configurar logger principal
    logger = logging.getLogger('chat_app')
    logger.setLevel(logging.DEBUG)
    
    # Limpar handlers existentes para evitar duplicação
    if logger.handlers:
        logger.handlers.clear()
    
    # Log para arquivo com rotação por tamanho
    file_handler = logging.handlers.RotatingFileHandler(
        log_filename, 
        maxBytes=10*1024*1024,  # 10 MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    
    # Log para console
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # Formato detalhado dos logs com timestamp ISO, nível, contexto e mensagem
    log_format = '%(asctime)s [%(levelname)s] %(message)s'
    formatter = logging.Formatter(log_format, datefmt='%Y-%m-%d %H:%M:%S')
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    # Função auxiliar para encapsular o contexto
    def log_with_context(level, message, context=None, message_id=None, conversation_id=None, **kwargs):
        parts = []
        
        if context:
            parts.append(f"[{context}]")
        if conversation_id:
            parts.append(f"[conv:{conversation_id}]")
        if message_id:
            parts.append(f"[msg:{message_id}]")
            
        parts.append(message)
        log_message = " ".join(parts)
        
        if kwargs:
            # Limitar tamanho dos dados extras
            kwargs_str = str(kwargs)
            if len(kwargs_str) > 500:
                kwargs_str = kwargs_str[:500] + "..."
            log_message += f" - {kwargs_str}"
        
        logger.log(level, log_message)
    
    # Adicionar funções auxiliares ao logger
    logger.debug_with_context = lambda msg, **kwargs: log_with_context(logging.DEBUG, msg, **kwargs)
    logger.info_with_context = lambda msg, **kwargs: log_with_context(logging.INFO, msg, **kwargs)
    logger.warning_with_context = lambda msg, **kwargs: log_with_context(logging.WARNING, msg, **kwargs)
    logger.error_with_context = lambda msg, **kwargs: log_with_context(logging.ERROR, msg, **kwargs)
    
    return logger

# Inicialização do logger
logger = setup_logger()
logger.info("Iniciando aplicação de chat")

# Inicialização da aplicação
app = Flask(__name__, static_folder='static')
app.secret_key = 'sua_chave_secreta_aqui'
socketio = SocketIO(app, async_mode='eventlet', cors_allowed_origins="*")
logger.info("Aplicação Flask e Socket.IO inicializados")

# Configuração da API Ollama
API_URL = "http://localhost:11434/v1/chat/completions"
MODEL_NAME = "gemma2:2b"
youtube_handler = YoutubeHandler()
logger.info(f"API configurada: {API_URL}, Modelo: {MODEL_NAME}")

# Cache para mensagens em streaming
streaming_messages = {}

@app.route('/')
def home():
    """Rota principal que renderiza a página inicial"""
    logger.info("Requisição para página principal recebida")
    conversations = get_conversation_history()
    logger.debug(f"Carregadas {len(conversations)} conversas do histórico")
    return render_template('index.html', conversations=conversations)

@app.route('/get_conversation_history')
def conversation_history():
    """Endpoint para obter o histórico de todas as conversas"""
    try:
        logger.info("Requisição para obter histórico de conversas")
        conversations = get_conversation_history()
        logger.debug(f"Retornando {len(conversations)} conversas do histórico")
        return jsonify(conversations)
    except Exception as e:
        logger.error(f"Falha ao obter histórico de conversas: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>')
def get_conversation(conversation_id):
    """Endpoint para obter uma conversa específica pelo ID"""
    try:
        logger.info(f"Requisição para obter conversa: {conversation_id}")
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            logger.debug(f"Conversa {conversation_id} encontrada com {len(conversation.get('messages', []))} mensagens")
            return jsonify(conversation)
        logger.warning(f"Conversa não encontrada: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        logger.error(f"Falha ao obter conversa {conversation_id}: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

@app.route('/get_conversation/<conversation_id>/<int:offset>/<int:limit>')
def get_conversation_batch(conversation_id, offset, limit):
    """
    Endpoint para carregar mensagens em lotes para lazy loading.
    Permite carregar partes da conversa para melhorar a performance com históricos longos.
    
    Args:
        conversation_id: ID da conversa
        offset: Índice inicial das mensagens a serem carregadas
        limit: Número máximo de mensagens a serem retornadas
    """
    try:
        logger.info(f"Requisição de lote para conversa: {conversation_id} (offset={offset}, limit={limit})")
        conversation = get_conversation_by_id(conversation_id)
        if conversation:
            messages = conversation['messages']
            # Garantir que offset e limit estão dentro dos limites
            offset = min(offset, len(messages))
            end_index = min(offset + limit, len(messages))
            batch = messages[offset:end_index]
            
            logger.debug(f"Retornando lote {offset}-{end_index} de {len(messages)} mensagens")
            return jsonify({
                'messages': batch,
                'total': len(messages),
                'hasMore': end_index < len(messages)
            })
        
        logger.warning(f"Conversa não encontrada para batch loading: {conversation_id}")
        return jsonify({'error': 'Conversa não encontrada'}), 404
    except Exception as e:
        logger.error(f"Falha ao obter lote de mensagens: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

@app.route('/stream')
def stream():
    """
    [DEPRECATED] Endpoint para streaming de respostas usando Server-Sent Events (SSE).
    Esta funcionalidade foi substituída pelo Socket.IO para melhor gerenciamento de eventos.
    """
    return jsonify({'error': 'Este endpoint foi desativado. Use Socket.IO para streaming.'}), 410

@app.route('/send_message', methods=['POST'])
def send_message():
    """Endpoint para enviar mensagens para a IA e receber respostas"""
    try:
        data = request.get_json()
        message = data.get('message', '')
        conversation_id = data.get('conversation_id')
        message_id = data.get('message_id', str(uuid4()))  # Usar o messageId enviado ou gerar um novo UUID
        
        if not message:
            return jsonify({'error': 'Mensagem vazia'}), 400
            
        if not conversation_id:
            conversation_id = create_new_conversation()
            
        logger.info_with_context("Processando mensagem do usuário", 
                                context="backend",
                                message_id=message_id,
                                conversation_id=conversation_id,
                                length=len(message))
        
        # Adicionar a mensagem do usuário ao histórico com o message_id explícito
        user_message_id = add_message_to_conversation(conversation_id, message, "user", message_id=f"user_{message_id}")
        
        # Verificar se é um comando especial
        if message.lower().startswith('/youtube '):
            # Comando para processar vídeo do YouTube
            url = message[9:].strip()
            logger.info_with_context("Processando comando YouTube", 
                                    context="backend",
                                    message_id=message_id,
                                    conversation_id=conversation_id,
                                    url=url)
            process_youtube_background(url, conversation_id)
            return jsonify({'status': 'processing_youtube', 'conversation_id': conversation_id})
            
        elif message.lower().startswith('/youtube_resumo '):
            # Comando para resumir vídeo do YouTube
            url = message[16:].strip()
            logger.info_with_context("Processando comando YouTube Resumo",
                                    context="backend",
                                    message_id=message_id,
                                    conversation_id=conversation_id,
                                    url=url)
            process_youtube_resumo_background(url, conversation_id)
            return jsonify({'status': 'processing_youtube_resumo', 'conversation_id': conversation_id})
        
        # É uma mensagem normal - processa com Socket.IO para streaming
        process_streaming_response(message, conversation_id, message_id)
        
        return jsonify({
            'status': 'processing', 
            'message_id': message_id,
            'conversation_id': conversation_id,
            'user_message_id': user_message_id
        })
        
    except Exception as e:
        logger.error_with_context("Erro ao processar mensagem", 
                                context="backend", 
                                error=str(e),
                                traceback=traceback.format_exc())
        return jsonify({'error': str(e)}), 500

def process_streaming_response(message, conversation_id, message_id):
    """
    Processa a resposta da IA em modo streaming usando Socket.IO
    
    Args:
        message: Texto da mensagem do usuário
        conversation_id: ID da conversa
        message_id: ID único da mensagem
    """
    try:
        # Inicializar uma entrada para a mensagem em streaming
        if message_id not in streaming_messages:
            streaming_messages[message_id] = {
                'content': '',
                'complete': False,
                'conversation_id': conversation_id
            }
            
        logger.debug_with_context("Iniciando processamento de resposta em streaming", 
                                context="backend",
                                message_id=message_id, 
                                conversation_id=conversation_id)
        
        def background_task():
            try:
                # Obter a resposta da IA em streaming
                for chunk in process_with_ai_stream(message, conversation_id):
                    if chunk:
                        # Adicionar o chunk à mensagem em streaming
                        streaming_messages[message_id]['content'] += chunk
                        
                        # Emitir o chunk para o cliente
                        socketio.emit('message_chunk', {
                            'message_id': message_id,
                            'chunk': chunk,
                            'conversation_id': conversation_id
                        }, room=conversation_id)
                        
                        logger.debug_with_context("Chunk enviado", 
                                                context="backend",
                                                message_id=message_id, 
                                                conversation_id=conversation_id,
                                                chunk_size=len(chunk))
                
                # Marcar a mensagem como completa
                streaming_messages[message_id]['complete'] = True
                
                # Notificar o cliente que a mensagem está completa
                socketio.emit('message_complete', {
                    'message_id': message_id,
                    'conversation_id': conversation_id,
                    'content': streaming_messages[message_id]['content']
                }, room=conversation_id)
                
                # Salvar a mensagem completa na conversa
                assistant_message_id = add_message_to_conversation(
                    conversation_id, 
                    streaming_messages[message_id]['content'], 
                    "assistant",
                    message_id=f"assistant_{message_id}"
                )
                
                logger.info_with_context("Mensagem completa processada", 
                                        context="backend",
                                        message_id=message_id,
                                        assistant_message_id=assistant_message_id,
                                        conversation_id=conversation_id,
                                        content_length=len(streaming_messages[message_id]['content']))
                
                # Limpar a mensagem do cache
                if message_id in streaming_messages:
                    del streaming_messages[message_id]
                    
            except Exception as e:
                logger.error_with_context("Erro no processamento em background", 
                                        context="backend",
                                        message_id=message_id,
                                        conversation_id=conversation_id,
                                        error=str(e),
                                        traceback=traceback.format_exc())
                
                # Notificar o cliente do erro
                socketio.emit('message_error', {
                    'message_id': message_id,
                    'conversation_id': conversation_id,
                    'error': str(e)
                }, room=conversation_id)
        
        # Iniciar o processamento em background
        socketio.start_background_task(background_task)
        
    except Exception as e:
        logger.error_with_context("Erro ao iniciar processamento streaming", 
                                context="backend",
                                message_id=message_id,
                                conversation_id=conversation_id,
                                error=str(e),
                                traceback=traceback.format_exc())
        raise

@app.route('/save_message', methods=['POST'])
def save_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        role = data.get('role')
        
        if not all([conversation_id, content, role]):
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG-PYTHON] Rota /save_message acessada para conversa: {conversation_id}, role: {role}")
        add_message_to_conversation(conversation_id, content, role)
        
        # Notificar clientes via WebSocket
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success', 'conversation_id': conversation_id})
    except Exception as e:
        print(f"[ERRO-PYTHON] Erro ao salvar mensagem: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube', methods=['POST'])
def process_youtube():
    data = request.json
    conversation_id = data.get('conversation_id')
    video_url = data.get('video_url')
    
    if not conversation_id or not video_url:
        return jsonify({'error': 'Dados incompletos'}), 400
    
    # Salvar o comando do usuário no histórico
    command_message = f"/youtube {video_url}"
    add_message_to_conversation(conversation_id, command_message, "user")
    print(f"[DEBUG] Comando do usuário salvo: {command_message}")
    
    # Notificar o frontend que a mensagem do usuário foi salva
    socketio.emit('message_saved', {
        'content': command_message,
        'role': 'user',
        'conversation_id': conversation_id
    }, room=conversation_id)
    
    # Inicia o processamento em background
    socketio.start_background_task(process_youtube_background, video_url, conversation_id)
    
    return jsonify({'status': 'Processamento iniciado'})

def process_youtube_background(url, conversation_id):
    """
    Função que processa um vídeo do YouTube em background.
    Baixa as legendas, limpa e retorna como mensagem na conversa.
    
    Args:
        url: URL do vídeo do YouTube
        conversation_id: ID da conversa onde salvar o resultado
    """
    print(f"[INFO] Iniciando processamento do vídeo: {url} para conversa: {conversation_id}")
    youtube_handler = YoutubeHandler()
    
    try:
        # Gerar message_id único para a resposta
        message_id = str(uuid4())
        logger.info(f"[BACKEND] Gerado message_id para YouTube: {message_id}")

        # Notificar início do processamento com animação de carregamento
        socketio.emit('youtube_response', {
            'status': 'processing',
            'conversation_id': conversation_id,
            'content': "Processando vídeo...",
            'message_id': message_id
        }, room=conversation_id)
        logger.debug(f"[BACKEND] Emitido 'youtube_response' com status 'processing' para {conversation_id}")
        
        # Garantir que o cliente está na sala correta
        socketio.emit('join_conversation', {
            'conversation_id': conversation_id
        }, room=conversation_id)
        
        # Substituindo as chamadas separadas pelo novo método combinado
        cleaned_subtitles, video_title = youtube_handler.download_and_clean_transcript(url)
        
        if not cleaned_subtitles:
            error_msg = f"Não foi possível processar as legendas do vídeo '{video_title or 'desconhecido'}' em PT-BR, PT ou EN."
            print(f"[ERRO] {error_msg}")
            socketio.emit('youtube_response', {
                'status': 'error',
                'conversation_id': conversation_id,
                'error': error_msg,
                'message_id': message_id
            }, room=conversation_id)
            logger.error(f"[BACKEND] Erro no processamento do YouTube: {error_msg}")
            return
            
        print(f"[INFO] Legendas encontradas e processadas para o vídeo: {video_title}")
        
        # Formata a resposta com o título e as legendas
        response_content = f"**Legendas do vídeo '{video_title}':**\n\n{cleaned_subtitles}"
        
        # Salva a mensagem no histórico com o message_id explícito
        add_message_to_conversation(conversation_id, response_content, "assistant", message_id=message_id)
        logger.info(f"[BACKEND] Mensagem salva com message_id: {message_id}")
        
        # Envia a resposta para o frontend
        socketio.emit('youtube_response', {
            'status': 'success',
            'conversation_id': conversation_id,
            'content': response_content,
            'message_id': message_id
        }, room=conversation_id)
        logger.debug(f"[BACKEND] Emitido 'youtube_response' com status 'success' para {conversation_id}")
        
        # Notifica que a conversa foi atualizada
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        logger.debug(f"[BACKEND] Emitido 'conversation_updated' para {conversation_id}")
        
        print(f"[INFO] Processamento do vídeo concluído com sucesso")
        
    except Exception as e:
        error_msg = f"Erro ao processar o vídeo: {str(e)}"
        print(f"[ERRO] {error_msg}")
        socketio.emit('youtube_response', {
            'status': 'error',
            'conversation_id': conversation_id,
            'error': error_msg,
            'message_id': message_id
        }, room=conversation_id)
        logger.error(f"[BACKEND] Exceção no processamento do YouTube: {error_msg}")

@app.route('/save_youtube_message', methods=['POST'])
def save_youtube_message():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        content = data.get('content')
        if not conversation_id or not content:
            return jsonify({'error': 'Dados incompletos'}), 400
        
        print(f"[DEBUG] Salvando mensagem do YouTube na conversa: {conversation_id}")
        add_message_to_conversation(conversation_id, content, "assistant")
        
        # Opcional: Notifica novamente via WebSocket para que o frontend atualize o histórico (se necessário)
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        return jsonify({'status': 'success'})
    except Exception as e:
        print(f"[ERRO] Falha ao salvar mensagem do YouTube: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/process_youtube_resumo', methods=['POST'])
def process_youtube_resumo():
    """
    Processa um vídeo do YouTube, baixa as legendas, limpa e gera resumos por blocos.
    """
    try:
        data = request.json
        video_url = data.get('url', '').strip()
        conversation_id = data.get('conversation_id')
        
        if not video_url:
            return jsonify({'error': 'URL do vídeo não fornecida'}), 400
        if not conversation_id:
            return jsonify({'error': 'ID da conversa não fornecido'}), 400
            
        print(f"[INFO] Processando resumo do vídeo: {video_url} para conversa: {conversation_id}")
        
        # Adiciona a mensagem do usuário ao histórico
        command_message = f"/youtube_resumo {video_url}"
        add_message_to_conversation(conversation_id, command_message, "user")
        
        # Notifica que a conversa foi atualizada
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        # Adiciona o cliente à sala da conversa
        socketio.emit('join_conversation', {
            'conversation_id': conversation_id
        }, room=conversation_id)
        
        # Inicia o processamento em background
        socketio.start_background_task(process_youtube_resumo_background, video_url, conversation_id)
        
        return jsonify({'status': 'Processamento de resumo iniciado'})
    except Exception as e:
        error_msg = f"Erro ao iniciar processamento do resumo: {str(e)}"
        print(f"[ERRO] {error_msg}")
        return jsonify({'error': error_msg}), 500

def process_youtube_resumo_background(url, conversation_id):
    """
    Processa um vídeo do YouTube em background, gerando resumos por blocos de transcrição.
    O processo divide a transcrição em blocos menores e gera um resumo para cada bloco
    usando a IA, permitindo um resumo mais detalhado do conteúdo completo.
    
    Args:
        url: URL do vídeo do YouTube
        conversation_id: ID da conversa onde salvar o resultado
    """
    print(f"[INFO] Iniciando processamento de resumo do vídeo: {url} para conversa: {conversation_id}")
    youtube_handler = YoutubeHandler()
    
    try:
        # Gerar message_id único para a resposta
        message_id = str(uuid4())
        logger.info(f"[BACKEND] Gerado message_id para YouTube Resumo: {message_id}")

        # Notificar início do processamento com animação de carregamento
        socketio.emit('message_chunk', {
            'content': "Processando vídeo para resumo...",
            'conversation_id': conversation_id,
            'message_id': message_id,
            'chunk_number': 0
        }, room=conversation_id)
        logger.debug(f"[BACKEND] Emitido chunk inicial para {conversation_id}")
        
        # Garantir que o cliente está na sala correta
        socketio.emit('join_conversation', {
            'conversation_id': conversation_id
        }, room=conversation_id)
        
        # Baixa e limpa a transcrição
        transcript, video_title = youtube_handler.download_and_clean_transcript(url)
        
        if not transcript:
            error_msg = f"Não foi possível processar as legendas do vídeo '{video_title or 'desconhecido'}' em PT-BR, PT ou EN."
            print(f"[ERRO] {error_msg}")
            
            # Enviar erro como message_chunk e response_complete para manter consistência
            socketio.emit('message_chunk', {
                'content': f"**Erro:** {error_msg}",
                'conversation_id': conversation_id,
                'message_id': message_id,
                'chunk_number': 1
            }, room=conversation_id)
            socketio.emit('response_complete', {
                'conversation_id': conversation_id,
                'message_id': message_id
            }, room=conversation_id)
            logger.error(f"[BACKEND] Erro no YouTube Resumo: {error_msg}")
            return
            
        print(f"[INFO] Legendas encontradas e processadas para o vídeo: {video_title}")
        
        # Divide a transcrição em blocos de aproximadamente 300 palavras
        transcript_chunks = youtube_handler.split_transcript_into_chunks(transcript)
        
        if not transcript_chunks:
            error_msg = f"Falha ao dividir a transcrição do vídeo '{video_title}' em blocos."
            print(f"[ERRO] {error_msg}")
            
            # Enviar erro como message_chunk e response_complete
            socketio.emit('message_chunk', {
                'content': f"**Erro:** {error_msg}",
                'conversation_id': conversation_id,
                'message_id': message_id,
                'chunk_number': 1
            }, room=conversation_id)
            socketio.emit('response_complete', {
                'conversation_id': conversation_id,
                'message_id': message_id
            }, room=conversation_id)
            logger.error(f"[BACKEND] Erro no YouTube Resumo: {error_msg}")
            return
        
        # Cria a resposta inicial com o título do vídeo
        full_response = f"**Resumo do vídeo '{video_title}':**\n\n"
        
        # Adiciona a informação sobre os blocos
        full_response += f"*O vídeo foi dividido em {len(transcript_chunks)} blocos para resumo detalhado.*\n\n"
        
        # Salva a mensagem inicial no histórico com o message_id específico
        add_message_to_conversation(conversation_id, full_response, "assistant", message_id=message_id)
        
        # Envia a resposta inicial para o frontend
        socketio.emit('message_chunk', {
            'content': full_response,
            'conversation_id': conversation_id,
            'message_id': message_id,
            'chunk_number': 1
        }, room=conversation_id)
        logger.debug(f"[BACKEND] Emitido cabeçalho do resumo para {conversation_id}")
        
        # Processa cada bloco com a IA para gerar resumos
        response_content = full_response
        chunk_number = 2
        
        for i, chunk in enumerate(transcript_chunks):
            # Formata o número do bloco
            block_number = i + 1
            
            # Adiciona cabeçalho do bloco
            block_header = f"\n\n### Bloco {block_number}/{len(transcript_chunks)}\n\n"
            socketio.emit('message_chunk', {
                'content': block_header,
                'conversation_id': conversation_id,
                'message_id': message_id,
                'chunk_number': chunk_number
            }, room=conversation_id)
            response_content += block_header
            chunk_number += 1
            
            # Prepara o prompt para a IA
            prompt = f"""Resumir o seguinte trecho em um parágrafo conciso, mantendo os pontos importantes:

"{chunk}"

Resumo detalhado:"""
            
            # Gera o resumo com a IA e envia em streaming
            try:
                for resumo_chunk in process_with_ai_stream(prompt, conversation_id):
                    if resumo_chunk:
                        # Enviar chunk via socket para streaming em tempo real
                        socketio.emit('message_chunk', {
                            'content': resumo_chunk,
                            'conversation_id': conversation_id,
                            'message_id': message_id,
                            'chunk_number': chunk_number
                        }, room=conversation_id)
                        response_content += resumo_chunk
                        chunk_number += 1
            except Exception as e:
                error_msg = f"Falha ao gerar resumo para o bloco {block_number}: {str(e)}"
                print(f"[ERRO] {error_msg}")
                error_response = f"*Erro ao gerar resumo para este bloco*\n\n**Trecho original:**\n\n{chunk[:150]}..."
                socketio.emit('message_chunk', {
                    'content': error_response,
                    'conversation_id': conversation_id,
                    'message_id': message_id,
                    'chunk_number': chunk_number
                }, room=conversation_id)
                response_content += error_response
        
        # Notificar que a resposta está completa
        socketio.emit('response_complete', {
            'conversation_id': conversation_id,
            'message_id': message_id,
            'total_chunks': chunk_number,
            'complete_response': response_content
        }, room=conversation_id)
        logger.info(f"[BACKEND] Resumo concluído para {conversation_id}, total de chunks: {chunk_number}")
        
        # Atualiza a mensagem no histórico
        update_message_in_conversation(conversation_id, message_id, response_content)
        
        # Notifica que a conversa foi atualizada
        socketio.emit('conversation_updated', {
            'conversation_id': conversation_id
        })
        
        print(f"[INFO] Processamento do resumo do vídeo concluído com sucesso")
        
    except Exception as e:
        error_msg = f"Erro ao processar o resumo do vídeo: {str(e)}"
        print(f"[ERRO] {error_msg}")
        
        # Em caso de erro, enviar message_chunk e response_complete
        socketio.emit('message_chunk', {
            'content': f"**Erro:** {error_msg}",
            'conversation_id': conversation_id,
            'message_id': message_id,
            'chunk_number': chunk_number if 'chunk_number' in locals() else 1
        }, room=conversation_id)
        socketio.emit('response_complete', {
            'conversation_id': conversation_id,
            'message_id': message_id
        }, room=conversation_id)
        logger.error(f"[BACKEND] Erro no YouTube Resumo: {str(e)}")

@app.route('/rename_conversation/<conversation_id>', methods=['POST'])
def handle_rename_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para renomear conversa: {conversation_id}")
        
        # Forçar decodificação do corpo JSON
        data = request.get_json(force=True, silent=True)
        if not data:
            data = {}
            print("[BACKEND] Request body vazio ou inválido")
        
        new_title = data.get('title', '').strip()
        print(f"[BACKEND] Novo título: '{new_title}'")
        
        if not new_title:
            print("[BACKEND] Título inválido")
            return jsonify({'error': 'Título inválido'}), 400
            
        success = rename_conversation(conversation_id, new_title)
        if success:
            print(f"[BACKEND] Conversa renomeada com sucesso para: {new_title}")
            
            # Notificar via WebSocket
            socketio.emit('conversation_renamed', {
                'conversation_id': conversation_id,
                'new_title': new_title
            })
            
            return jsonify({'success': True, 'new_title': new_title, 'conversation_id': conversation_id})
        else:
            print("[BACKEND] Falha ao renomear conversa")
            return jsonify({'error': 'Falha ao renomear conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao renomear conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/delete_conversation/<conversation_id>', methods=['DELETE'])
def handle_delete_conversation(conversation_id):
    try:
        print(f"[BACKEND] Recebendo solicitação para excluir conversa: {conversation_id}")
        
        success = delete_conversation(conversation_id)
        if success:
            print(f"[BACKEND] Conversa {conversation_id} excluída com sucesso")
            
            # Notificar via WebSocket
            socketio.emit('conversation_deleted', {
                'conversation_id': conversation_id
            })
            
            return jsonify({'success': True, 'conversation_id': conversation_id})
        else:
            print(f"[BACKEND] Falha ao excluir conversa {conversation_id}")
            return jsonify({'error': 'Falha ao excluir conversa'}), 500
    except Exception as e:
        print(f"[BACKEND] Erro ao excluir conversa: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/log-frontend', methods=['POST'])
def log_frontend():
    """Endpoint para registrar logs do frontend"""
    try:
        log_data = request.json
        if not isinstance(log_data, dict):
            logger.error(f"Formato inválido de log recebido: {log_data}")
            return jsonify({'error': 'Formato de log inválido'}), 400
            
        # Extrair campos do log
        log_level = log_data.get('level', 'INFO')
        message = log_data.get('message', '')
        data = log_data.get('data', {})
        timestamp = log_data.get('timestamp', '')
        context = log_data.get('context', 'frontend')
        message_id = log_data.get('messageId')
        conversation_id = log_data.get('conversationId')
        
        # Mapear níveis de log do frontend para os do Python
        level_map = {
            'DEBUG': logging.DEBUG,
            'INFO': logging.INFO,
            'WARN': logging.WARNING,
            'ERROR': logging.ERROR
        }
        
        log_level_num = level_map.get(log_level, logging.INFO)
        
        # Criar mensagem de log estruturada
        log_parts = []
        if context:
            log_parts.append(f"[{context}]")
        if conversation_id:
            log_parts.append(f"[conv:{conversation_id}]")
        if message_id:
            log_parts.append(f"[msg:{message_id}]")
            
        log_parts.append(message)
        log_message = " ".join(log_parts)
        
        # Limitar tamanho dos dados extras para evitar logs muito grandes
        if data:
            data_str = str(data)
            if len(data_str) > 500:
                data_str = data_str[:500] + "..."
            log_message += f" - {data_str}"
            
        # Registrar o log com o formato adequado
        logger.log(log_level_num, log_message)
        
        return jsonify({'success': True})
    except Exception as e:
        logger.error(f"Erro ao processar log do frontend: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({'error': str(e)}), 500

@app.route('/test_socket', methods=['POST'])
def test_socket():
    try:
        data = request.json
        conversation_id = data.get('conversation_id')
        
        if not conversation_id:
            return jsonify({'error': 'ID da conversa não fornecido'}), 400
            
        print(f"[DEBUG] Enviando evento de teste para conversation_id: {conversation_id}")
        socketio.emit('test_event', {
            'message': 'Teste de conectividade',
            'conversation_id': conversation_id,
            'timestamp': datetime.now().isoformat()
        }, room=conversation_id)
        
        return jsonify({'status': 'Evento de teste enviado'})
    except Exception as e:
        print(f"[ERRO] Falha ao enviar evento de teste: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/view-logs')
def view_logs():
    """Endpoint para visualizar os logs da aplicação"""
    try:
        # Verificar se estamos em ambiente de desenvolvimento
        is_dev = os.environ.get('FLASK_ENV') == 'development'
        
        # Por segurança, apenas disponível em desenvolvimento
        if not is_dev and request.remote_addr != '127.0.0.1':
            return jsonify({'error': 'Acesso não autorizado'}), 403
            
        log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logs')
        log_file = os.path.join(log_dir, f'app_{datetime.now().strftime("%Y%m%d")}.log')
        
        if not os.path.exists(log_file):
            return jsonify({'error': 'Arquivo de log não encontrado'}), 404
            
        # Ler as últimas 200 linhas do arquivo de log
        with open(log_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            last_lines = lines[-200:] if len(lines) > 200 else lines
        
        # Filtros disponíveis
        message_id = request.args.get('message_id')
        conversation_id = request.args.get('conversation_id')
        level = request.args.get('level')
        context = request.args.get('context')
        
        # Aplicar filtros
        filtered_lines = []
        for line in last_lines:
            if message_id and f"[msg:{message_id}]" not in line:
                continue
            if conversation_id and f"[conv:{conversation_id}]" not in line:
                continue
            if level and f"[{level}]" not in line:
                continue
            if context and f"[{context}]" not in line:
                continue
            filtered_lines.append(line)
                
        # Renderizar template HTML simples para visualização
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Logs da Aplicação</title>
            <style>
                body {
                    font-family: monospace;
                    background-color: #f5f5f5;
                    padding: 20px;
                }
                h1 {
                    color: #333;
                    margin-bottom: 20px;
                }
                .filters {
                    margin-bottom: 15px;
                    padding: 10px;
                    background-color: #fff;
                    border-radius: 5px;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                }
                .filter-item {
                    margin-right: 15px;
                    display: inline-block;
                }
                .filter-item input, .filter-item select {
                    margin-left: 5px;
                    padding: 4px;
                }
                button {
                    padding: 5px 10px;
                    background-color: #4285f4;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                }
                .logs {
                    background-color: #202020;
                    color: #f8f8f8;
                    padding: 15px;
                    border-radius: 5px;
                    overflow-x: auto;
                    white-space: pre-wrap;
                    margin-top: 20px;
                    box-shadow: 0 1px 5px rgba(0,0,0,0.2);
                }
                .logs span {
                    display: block;
                    margin-bottom: 2px;
                    font-size: 13px;
                    line-height: 1.5;
                }
                .log-debug { color: #b5b5b5; }
                .log-info { color: #8ab4f8; }
                .log-warning { color: #fdd663; }
                .log-error { color: #f28b82; }
                .message-id { color: #a2e9a2; }
                .conversation-id { color: #e9a2a2; }
                .highlight { background-color: rgba(255,255,0,0.2); }
            </style>
        </head>
        <body>
            <h1>Logs da Aplicação</h1>
            
            <div class="filters">
                <form method="GET" action="/view-logs">
                    <div class="filter-item">
                        <label for="message_id">Message ID:</label>
                        <input type="text" id="message_id" name="message_id" value="{message_id}">
                    </div>
                    <div class="filter-item">
                        <label for="conversation_id">Conversation ID:</label>
                        <input type="text" id="conversation_id" name="conversation_id" value="{conversation_id}">
                    </div>
                    <div class="filter-item">
                        <label for="level">Nível:</label>
                        <select id="level" name="level">
                            <option value="">Todos</option>
                            <option value="DEBUG" {selected_debug}>DEBUG</option>
                            <option value="INFO" {selected_info}>INFO</option>
                            <option value="WARNING" {selected_warning}>WARNING</option>
                            <option value="ERROR" {selected_error}>ERROR</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label for="context">Contexto:</label>
                        <select id="context" name="context">
                            <option value="">Todos</option>
                            <option value="frontend" {selected_frontend}>Frontend</option>
                            <option value="backend" {selected_backend}>Backend</option>
                        </select>
                    </div>
                    <button type="submit">Filtrar</button>
                    <button type="button" onclick="window.location.href='/view-logs'">Limpar Filtros</button>
                </form>
            </div>
            
            <div class="logs">
                {logs}
            </div>
            
            <script>
                // Auto-refresh a cada 10 segundos
                setTimeout(() => {
                    window.location.reload();
                }, 10000);
                
                // Destaque de termos de busca
                function highlightTerms() {
                    const msgId = document.getElementById('message_id').value;
                    const convId = document.getElementById('conversation_id').value;
                    
                    if (msgId || convId) {
                        const logEntries = document.querySelectorAll('.logs span');
                        
                        logEntries.forEach(entry => {
                            if (msgId && entry.textContent.includes(msgId)) {
                                entry.classList.add('highlight');
                            }
                            if (convId && entry.textContent.includes(convId)) {
                                entry.classList.add('highlight');
                            }
                        });
                    }
                }
                
                window.onload = highlightTerms;
            </script>
        </body>
        </html>
        """
        
        # Colorir as linhas de log conforme o nível
        formatted_logs = []
        for line in filtered_lines:
            css_class = "log-info"
            if "[DEBUG]" in line:
                css_class = "log-debug"
            elif "[WARNING]" in line:
                css_class = "log-warning"
            elif "[ERROR]" in line:
                css_class = "log-error"
                
            # Substituir IDs com formatação especial
            for msg_id in set(re.findall(r'\[msg:([^\]]+)\]', line)):
                line = line.replace(f"[msg:{msg_id}]", f'<span class="message-id">[msg:{msg_id}]</span>')
                
            for conv_id in set(re.findall(r'\[conv:([^\]]+)\]', line)):
                line = line.replace(f"[conv:{conv_id}]", f'<span class="conversation-id">[conv:{conv_id}]</span>')
                
            formatted_logs.append(f'<span class="{css_class}">{line}</span>')
        
        # Formatar o HTML com os valores apropriados
        html = html.format(
            message_id = message_id or '',
            conversation_id = conversation_id or '',
            selected_debug = 'selected' if level == 'DEBUG' else '',
            selected_info = 'selected' if level == 'INFO' else '',
            selected_warning = 'selected' if level == 'WARNING' else '',
            selected_error = 'selected' if level == 'ERROR' else '',
            selected_frontend = 'selected' if context == 'frontend' else '',
            selected_backend = 'selected' if context == 'backend' else '',
            logs = ''.join(formatted_logs)
        )
        
        return html
    except Exception as e:
        logger.error_with_context("Erro ao exibir logs", error=str(e), traceback=traceback.format_exc())
        return jsonify({'error': str(e)}), 500

# ---- WebSocket event handlers ----

@socketio.on('connect')
def handle_connect():
    """Evento de conexão do Socket.IO"""
    logger.info(f"Nova conexão Socket.IO estabelecida: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    """Evento de desconexão do Socket.IO"""
    logger.info(f"Conexão Socket.IO encerrada: {request.sid}")

@socketio.on('join_conversation')
def handle_join_conversation(data):
    """Evento para entrar em uma sala de conversa"""
    conversation_id = data.get('conversation_id')
    if conversation_id:
        join_room(conversation_id)
        logger.debug(f"Cliente {request.sid} entrou na sala: {conversation_id}")
        return {'status': 'success', 'joined': conversation_id}
    return {'status': 'error', 'message': 'ID da conversa não fornecido'}

@socketio.on('leave_conversation')
def handle_leave_conversation(data):
    """Evento para sair de uma sala de conversa"""
    conversation_id = data.get('conversation_id')
    if conversation_id:
        leave_room(conversation_id)
        logger.debug(f"Cliente {request.sid} saiu da sala: {conversation_id}")
        return {'status': 'success', 'left': conversation_id}
    return {'status': 'error', 'message': 'ID da conversa não fornecido'}

def process_with_ai(text, conversation_id=None):
    """
    Processa um texto com a IA e retorna a resposta completa.
    Esta função faz uma chamada síncrona para a API da Ollama.
    
    Args:
        text: Texto/prompt a ser enviado para a IA
        conversation_id: ID da conversa (opcional, para rastreamento)
        
    Returns:
        str: Resposta gerada pela IA
    """
    try:
        # Incluir o ID da conversa no contexto para rastreamento
        context_header = f"[Conversa: {conversation_id}] " if conversation_id else ""
        print(f"{context_header}Processando com IA: {text[:50]}...")
        
        payload = {
            "model": MODEL_NAME,
            "messages": [
                {"role": "system", "content": "Você é um assistente útil, fale somente em português brasileiro. Formate suas respostas em Markdown. Use acentos graves triplos (```) APENAS para blocos de código, especificando a linguagem (ex.: ```python). NUNCA coloque texto explicativo dentro de blocos de código."},
                {"role": "user", "content": text}
            ],
            "stream": False
        }
        headers = {"Content-Type": "application/json"}
        response = requests.post(API_URL, json=payload, headers=headers)
        response.raise_for_status()

        response_data = response.json()
        if 'choices' in response_data and len(response_data['choices']) > 0:
            return response_data['choices'][0]['message']['content']
        return "Erro: Nenhuma resposta válida recebida da IA."
    except requests.exceptions.RequestException as e:
        print(f"[Debug] Erro na requisição HTTP: {str(e)}")
        return "Ocorreu um erro ao se conectar com a IA."
    except Exception as e:
        print(f"[Debug] Erro inesperado: {str(e)}")
        return "Ocorreu um erro inesperado ao processar sua mensagem."

def process_with_ai_stream(text, conversation_id=None):
    """
    Processa o texto com a IA em modo streaming.
    Retorna a resposta incrementalmente em formato de gerador.
    
    Args:
        text: Texto da mensagem
        conversation_id: ID da conversa
    """
    try:
        logger.debug(f"Iniciando processamento com IA para conversa: {conversation_id}")
        
        # Obter histórico da conversa para contexto
        conversation = get_conversation_by_id(conversation_id) if conversation_id else None
        messages = []
        
        if conversation and 'messages' in conversation:
            # Carregar apenas as últimas mensagens para respeitar limite de tokens
            history = conversation['messages'][-10:]  # Ajuste conforme necessário
            
            for msg in history:
                if msg['role'] == 'user':
                    messages.append({
                        "role": "user", 
                        "content": msg['content']
                    })
                elif msg['role'] == 'assistant':
                    messages.append({
                        "role": "assistant", 
                        "content": msg['content']
                    })
        
        # Adicionar a mensagem atual se ainda não estiver no histórico carregado
        if not messages or messages[-1]['content'] != text:
            messages.append({
                "role": "user",
                "content": text
            })
            
        logger.debug(f"Preparado contexto com {len(messages)} mensagens para IA")
        
        # Configuração da chamada para o modelo
        payload = {
            "model": MODEL_NAME,
            "messages": messages,
            "stream": True,
            "temperature": 0.7,
            "max_tokens": 2000
        }
        
        logger.debug(f"Enviando requisição para API: {API_URL}")
        
        # Enviar requisição em streaming
        response = requests.post(
            API_URL,
            json=payload,
            stream=True,
            timeout=60
        )
        
        if response.status_code != 200:
            logger.error(f"Erro na API: {response.status_code} - {response.text}")
            yield f"Erro ao processar a resposta: {response.status_code}"
            return
            
        logger.debug("Conexão estabelecida com a API, iniciando streaming")
        
        buffer = ""
        for line in response.iter_lines():
            if line:
                try:
                    line_text = line.decode('utf-8')
                    
                    # Pular prefixo de dados
                    if line_text.startswith('data: '):
                        line_text = line_text[6:]
                        
                    # Verificar se é o marcador de fim    
                    if line_text == '[DONE]':
                        logger.debug("Marcador [DONE] recebido, finalizando streaming")
                        break
                        
                    # Decodificar JSON
                    data = json.loads(line_text)
                    
                    if 'choices' in data and len(data['choices']) > 0:
                        choice = data['choices'][0]
                        if 'delta' in choice and 'content' in choice['delta']:
                            content = choice['delta']['content']
                            if content:
                                buffer += content
                                
                                # Enviar buffer quando atingir certo tamanho ou tiver pontuação
                                if len(buffer) >= 10 or any(c in buffer for c in '.!?'):
                                    logger.debug(f"Enviando chunk de {len(buffer)} caracteres")
                                    yield buffer
                                    buffer = ""
                except Exception as e:
                    logger.error(f"Erro ao processar linha do streaming: {str(e)}")
                    logger.error(traceback.format_exc())
        
        # Enviar resto do buffer se houver
        if buffer:
            logger.debug(f"Enviando chunk final de {len(buffer)} caracteres")
            yield buffer
            
        logger.info(f"Streaming concluído para conversa: {conversation_id}")
        
    except Exception as e:
        logger.error(f"Erro no processo de streaming: {str(e)}")
        logger.error(traceback.format_exc())
        yield f"Erro no processamento: {str(e)}"

if __name__ == '__main__':
    # Configurar o parser de argumentos
    parser = argparse.ArgumentParser(description='Servidor de chat com persistência e logs')
    parser.add_argument('--port', type=int, default=5000, help='Porta para o servidor (padrão: 5000)')
    parser.add_argument('--host', type=str, default='0.0.0.0', help='Host para o servidor (padrão: 0.0.0.0)')
    
    # Processar os argumentos
    args = parser.parse_args()
    
    logger.info("Iniciando servidor Socket.IO")
    try:
        # Usar a porta especificada via linha de comando
        port = args.port
        host = args.host
        logger.info(f"Tentando iniciar servidor em {host}:{port}")
        socketio.run(app, debug=True, host=host, port=port)
    except OSError as e:
        if 'Address already in use' in str(e) or 'endereço de soquete' in str(e):
            # Tentar uma porta alternativa
            alt_port = port + 1
            logger.warning(f"Porta {port} já em uso. Tentando porta alternativa {alt_port}")
            try:
                socketio.run(app, debug=True, host=host, port=alt_port)
            except Exception as e2:
                logger.critical(f"Falha ao iniciar servidor na porta alternativa: {str(e2)}")
                logger.critical(traceback.format_exc())
                print(f"\nERRO: Todas as portas estão em uso. Execute python cleanup_ports.py para liberar as portas.")
        else:
            logger.critical(f"Falha ao iniciar servidor: {str(e)}")
            logger.critical(traceback.format_exc())
    except Exception as e:
        logger.critical(f"Falha ao iniciar servidor: {str(e)}")
        logger.critical(traceback.format_exc())


==========================================
Conteúdo de cleanup_ports.py (caminho: cleanup_ports.py):
==========================================
"""
Script utilitário para verificar e limpar portas em uso.
Especialmente útil quando a aplicação principal encontra erros de porta já em uso.
"""

import os
import sys
import subprocess
import time

# Portas usadas pela aplicação
PORTS_TO_CHECK = [5000, 5001, 5002]

def check_port(port):
    """Verifica se uma porta está em uso e retorna o PID do processo que a utiliza"""
    try:
        # Windows netstat para encontrar processos usando a porta
        cmd = f"netstat -ano | findstr :{port}"
        result = subprocess.run(cmd, shell=True, text=True, capture_output=True)
        
        if result.returncode == 0 and result.stdout.strip():
            for line in result.stdout.split('\n'):
                if f":{port}" in line and "LISTENING" in line:
                    parts = line.strip().split()
                    if len(parts) >= 5:
                        # O último campo deve ser o PID
                        pid = parts[-1]
                        return int(pid)
        
        return None
    except Exception as e:
        print(f"Erro ao verificar porta {port}: {str(e)}")
        return None

def kill_process(pid):
    """Tenta encerrar um processo pelo PID"""
    try:
        print(f"Tentando encerrar processo {pid}...")
        subprocess.run(f"taskkill /F /PID {pid}", shell=True, check=True)
        print(f"Processo {pid} encerrado com sucesso.")
        return True
    except subprocess.CalledProcessError:
        print(f"Não foi possível encerrar o processo {pid}. Talvez seja necessário privilégios de administrador.")
        return False
    except Exception as e:
        print(f"Erro ao encerrar processo {pid}: {str(e)}")
        return False

def main():
    print("Verificando portas em uso pela aplicação...")
    
    pids_found = False
    for port in PORTS_TO_CHECK:
        pid = check_port(port)
        if pid:
            pids_found = True
            print(f"Porta {port} em uso pelo processo PID {pid}")
            
            response = input(f"Deseja encerrar o processo {pid} para liberar a porta {port}? (s/n): ")
            if response.lower() == 's':
                if kill_process(pid):
                    print(f"Porta {port} liberada.")
                    time.sleep(1)  # Dar tempo para o sistema liberar a porta
                else:
                    print(f"Não foi possível liberar a porta {port}.")
        else:
            print(f"Porta {port} está livre.")
    
    if not pids_found:
        print("Todas as portas estão livres. Você pode iniciar a aplicação normalmente.")
        
    print("\nDica: Se continuar tendo problemas, tente iniciar a aplicação em uma porta específica:")
    print("python app.py --port 5005")

if __name__ == "__main__":
    main() 

==========================================
Conteúdo de DOCUMENTACAO.md (caminho: DOCUMENTACAO.md):
==========================================
# Documentação do Sistema de Chat

## 1. Estrutura de Arquivos
```
/
├── static/
│   ├── js/
│   │   ├── modules/
│   │   │   └── streamingManager.js
│   │   ├── chat/
│   │   │   ├── chatActions.js
│   │   │   ├── chatUI.js
│   │   │   └── chatStorage.js
│   │   ├── utils/
│   │   │   └── logger.js
│   │   ├── messageRenderer.js
│   │   ├── main.js
│   │   └── init.js
│   └── css/
│       └── streaming.css
├── templates/
│   └── index.html
├── logs/
│   └── app_YYYYMMDD.log
└── app.py
```

## 2. Melhorias Implementadas

### 2.1. Gerenciamento de Streaming
- Implementação do sistema de `messageRegistry` para controlar o fluxo de mensagens
- Sistema de cache para manter o estado das mensagens em streaming
- Gerenciamento de containers únicos por mensagem usando `messageId`
- Detecção e prevenção de duplicação de mensagens
- Suporte a transições suaves entre conversas

### 2.2. Interface do Usuário
- Correção dos IDs dos elementos HTML:
  - `send-btn` para o botão de envio
  - `chat-input` para o campo de entrada
- Implementação de verificações de existência de elementos antes de adicionar listeners
- Suporte a envio de mensagens por Enter (exceto com Shift)
- Scroll automático para a última mensagem

### 2.3. Segurança e Validação
- Sanitização de mensagens usando `DOMPurify`
- Tratamento de erros em todas as operações assíncronas
- Validação de mensagens vazias antes do envio
- Verificação de existência de elementos DOM antes de manipulação

### 2.4. Funcionalidades Principais
- Envio e recebimento de mensagens em tempo real
- Suporte a múltiplas conversas
- Carregamento de histórico de conversas
- Formatação de mensagens com suporte a Markdown
- Indicadores visuais de carregamento e erro
- Sistema centralizado de logs para depuração

## 3. Componentes Principais

### 3.1. messageRegistry 
O `messageRegistry` é um componente crítico para gerenciar mensagens em streaming:

```javascript
// Definição global para garantir acesso em múltiplos módulos
window.messageRegistry = new Map();
```

**Propósito**:
- Rastrear todas as mensagens em streaming ativas
- Gerenciar os containers DOM de cada mensagem
- Prevenir a duplicação de mensagens
- Permitir a limpeza adequada de containers após conclusão do streaming

**Estrutura**:
```javascript
// Para cada mensagem no Map
messageRegistry.set(messageId, {
  content: '',        // Conteúdo acumulado da mensagem
  rendered: false,    // Se já foi renderizada ao menos uma vez
  container: element, // Referência ao elemento DOM
  timer: timeoutId    // Timer para limpeza de containers órfãos
});
```

**Interação com outros componentes**:
- Utilizado por `chatActions.js` para gerenciar o ciclo de vida das mensagens
- Consultado durante carregamento de conversas para evitar duplicação
- Limpo automaticamente quando mensagens são finalizadas

### 3.2. Sistema de Streaming
Gerencia a recepção e renderização de mensagens em tempo real:

Principais funções:
- `handleStreamChunk`: Processa e acumula chunks recebidos via Socket.IO
- `renderStreamingContent`: Renderiza conteúdo acumulado no container apropriado
- `finalizeMessage`: Conclui o streaming, removendo elementos temporários
- `cleanupOrphan`: Remove containers órfãos para prevenir vazamentos de memória

## 4. Fluxo de Mensagens e Prevenção de Duplicação

### 4.1. Problema Identificado
O sistema pode enfrentar duplicação de mensagens quando:
1. IDs de mensagem inconsistentes são usados entre streaming e armazenamento
2. Durante o carregamento do histórico, mensagens podem ser renderizadas múltiplas vezes

**Sintoma**: Mensagens duplicadas aparecem no DOM com IDs diferentes:
- UUID (ex: `2ca03c22-be96-49c2-8f5a-17f2d4dc2287`) para mensagens em streaming
- Timestamp (ex: `2025-04-24T17:06:24.506222`) para mensagens do histórico

### 4.2. Solução Implementada

1. **Centralização do messageRegistry**:
   - Definição global via `window.messageRegistry` para garantir acesso consistente
   - Referência local em cada módulo para facilitar o uso

2. **Detecção de Duplicação por Conteúdo**:
   - Verificação de conteúdo similar entre mensagens
   - Alertas de log quando múltiplos containers são detectados para conteúdo similar

3. **Prevenção Durante Carregamento**:
   - Verificação de mensagens existentes no DOM antes de renderizar novas
   - Atualização do messageRegistry ao carregar histórico

4. **Ciclo de Vida da Mensagem**:
   - Streaming: ID temporário durante recepção de chunks
   - Finalização: Atualização para ID permanente após conclusão
   - Histórico: Verificação de duplicação antes de renderizar

### 4.3. Fluxo Completo

1. **Envio de mensagem do usuário**:
   - Captura de input do usuário
   - Validação e envio para o backend
   - Exibição imediata no chat

2. **Streaming da resposta**:
   - Backend envia chunks via Socket.IO
   - `messageRegistry` rastreia cada mensagem com ID único
   - `handleStreamChunk` acumula conteúdo e atualiza o DOM
   - Detecção contínua de containers duplicados

3. **Finalização da resposta**:
   - Backend envia evento `response_complete`
   - `finalizeMessage` limpa elementos temporários
   - Mensagem é adicionada ao histórico com ID permanente

4. **Carregamento de histórico**:
   - Ao mudar de conversa, histórico é carregado
   - Verificação de mensagens já renderizadas
   - Prevenção de duplicação por conteúdo similar

## 5. Sistema de Logs

O sistema possui um mecanismo avançado de logging para ajudar na depuração e entendimento do fluxo de dados.

### 5.1. Frontend Logging

O sistema de logs do frontend está centralizado no arquivo `static/js/utils/logger.js`:

- Níveis de log: DEBUG, INFO, WARN, ERROR
- Formatação consistente com timestamp
- Envio de logs para o backend através do endpoint `/log-frontend`
- Captura automática de erros não tratados e rejeições de promessas

Exemplo de uso:
```javascript
import { logger } from './utils/logger.js';

// Logs específicos para messageRegistry
logger.debug('Inicializando messageRegistry para messageId', { messageId });
logger.warn('Múltiplos contêineres detectados', { messageId, count: containers.length });
```

### 5.2. Backend Logging

O backend utiliza o módulo `logging` do Python:

- Logs armazenados em arquivos diários (`logs/app_YYYYMMDD.log`)
- Captura de exceções com traceback completo
- Registro de eventos do Socket.IO
- Processamento de logs do frontend para análise unificada

### 5.3. Depuração de Duplicação

Para diagnosticar problemas de duplicação:

1. **Logs de alto nível**:
   - `[INFO] Inicializando messageRegistry global`
   - `[INFO] Inicializando entrada no messageRegistry { messageId: '...' }`
   - `[INFO] Mensagem finalizada com sucesso { messageId: '...', contentSize: ... }`

2. **Logs de alerta**:
   - `[WARN] Múltiplos contêineres detectados { messageId: '...', count: 2 }`
   - `[WARN] Tentativa de finalizar mensagem não registrada { messageId: '...' }`

3. **Monitoramento periódico**:
   - `[DEBUG] Monitoramento de streams concluído { activeStreams: ..., registrySize: ... }`

## 6. Troubleshooting

### 6.1. Problemas Comuns

1. **Mensagens duplicadas**:
   - **Sintoma**: Mesma mensagem aparece duas vezes no chat
   - **Verificação**: Inspecionar o DOM para identificar IDs diferentes
   - **Solução**: Verificar a inicialização do `messageRegistry` e o carregamento de histórico

2. **Mensagens ausentes**:
   - **Sintoma**: Chunks recebidos mas não renderizados
   - **Verificação**: Consultar logs para eventos `message_chunk` e `response_complete`
   - **Solução**: Verificar se o `messageRegistry` está acumulando corretamente

3. **Erros de referência**:
   - **Sintoma**: Erro `messageRegistry is not defined` no console
   - **Verificação**: Confirmar que a definição global do `messageRegistry` está carregada
   - **Solução**: Garantir importação correta em todos os módulos que utilizam

### 6.2. Manutenção e Evolução

Para futuras melhorias no sistema:

1. **Padronização de IDs**:
   - Usar o mesmo formato de ID (preferencialmente UUID) em todo o ciclo de vida
   - Coordenar IDs entre frontend e backend

2. **Melhorias no messageRegistry**:
   - Adicionar expiração automática de entradas antigas
   - Implementar persistência para recuperação após recarregamento da página

3. **Otimização de renderização**:
   - Implementar renderização virtual para grandes históricos
   - Melhorar detecção de duplicação baseada em conteúdo

## 7. Histórico de Alterações

### Versão 1.3.0
- Implementação do messageRegistry global
- Solução para duplicação de mensagens
- Sistema avançado de logging para depuração
- Detecção de múltiplos containers

### Versão 1.2.0
- Sistema de cache para streaming
- Suporte a múltiplas conversas
- Melhorias na formatação de mensagens
- Tratamento de erros aprimorado

### Versão 1.1.0
- Adição do StreamingManager
- Melhorias na interface do usuário
- Correção de IDs dos elementos HTML
- Implementação de verificações de segurança

### Versão 1.0.0
- Implementação inicial do sistema de chat
- Gerenciamento básico de mensagens
- Interface simples e funcional

## 8. Dependências

- Socket.IO para comunicação em tempo real
- Marked.js para renderização de Markdown
- DOMPurify para sanitização de HTML
- CSS moderno para estilização

## 9. Configuração

Para configurar o ambiente:

1. Instalar dependências:
```bash
npm install socket.io marked dompurify
```

2. Configurar o servidor:
```python
# app.py
from flask import Flask, render_template
from flask_socketio import SocketIO

app = Flask(__name__)
socketio = SocketIO(app)
```

3. Inicializar o cliente:
```javascript
// main.js
import { chatUI } from './chatUI.js';
import { streamingManager } from './modules/streamingManager.js';

// Inicialização
document.addEventListener('DOMContentLoaded', () => {
    chatUI.initialize();
    streamingManager.initialize();
});
```

## 10. Troubleshooting

### Problemas Comuns

1. **Mensagens não aparecem**
   - Verificar conexão com o servidor
   - Confirmar se os elementos DOM existem
   - Verificar logs do console

2. **Streaming interrompido**
   - Verificar estado do cache
   - Confirmar conexão WebSocket
   - Verificar logs de erro

3. **Interface não responde**
   - Verificar inicialização dos componentes
   - Confirmar existência de elementos
   - Verificar erros no console

### Soluções

1. **Reinicialização**
   - Recarregar a página
   - Verificar conexão
   - Limpar cache do navegador

2. **Debug**
   - Usar console.log para rastreamento
   - Verificar estado dos componentes
   - Monitorar eventos do Socket.IO

3. **Manutenção**
   - Limpar cache periodicamente
   - Verificar atualizações
   - Monitorar performance 

## Sistema de Logs

O sistema possui um mecanismo avançado de logging para ajudar na depuração e entendimento do fluxo de dados. O sistema de logs foi implementado tanto no frontend quanto no backend.

### Frontend Logging

O sistema de logs do frontend está centralizado no arquivo `static/js/utils/logger.js`, que oferece as seguintes funcionalidades:

- Diferentes níveis de log: DEBUG, INFO, WARN, ERROR
- Formatação consistente com timestamp
- Envio de logs para o backend através de um endpoint dedicado
- Captura automática de erros não tratados e rejeições de promessas

Exemplo de uso:
```javascript
import { logger } from './utils/logger.js';

// Diferentes níveis de log
logger.debug('Mensagem de depuração', { dados: 'adicionais' });
logger.info('Informação importante');
logger.warn('Aviso sobre potencial problema', { motivo: 'validação falhou' });
logger.error('Erro crítico', { erro: error.message, stack: error.stack });
```

### Backend Logging

O backend utiliza o módulo `logging` do Python para criar logs estruturados:

- Logs enviados tanto para o console quanto para arquivos
- Arquivos de log separados por data (`app_YYYYMMDD.log`)
- Captura de exceções com rastreamento completo (traceback)
- Endpoint dedicado para receber e registrar logs do frontend

### Pontos de Log Principais

Os logs foram estrategicamente adicionados em pontos críticos do sistema:

1. **Inicialização**
   - Carregamento de dependências
   - Verificação de elementos críticos
   - Inicialização do Socket.IO

2. **Fluxo de Mensagens**
   - Envio de mensagens do usuário
   - Recebimento de chunks do backend
   - Renderização de respostas
   - Conclusão de streaming

3. **Manipulação de Erros**
   - Falhas de rede
   - Erros de processamento
   - Problemas de renderização

4. **Conexões Socket.IO**
   - Eventos de conexão/desconexão
   - Entrada/saída de salas
   - Emissão de eventos

### Monitoramento

Para visualizar os logs:

1. **Logs do Frontend**: Console do navegador
2. **Logs do Backend**: 
   - Console do servidor
   - Arquivos na pasta `logs/app_YYYYMMDD.log`
   - Logs unificados (frontend + backend) nos arquivos de log

### Configuração do Nível de Log

Para ajustar a verbosidade dos logs:

- **Frontend**: Modificar `currentLogLevel` em `static/js/utils/logger.js`
- **Backend**: Ajustar os níveis dos handlers em `setup_logger()` em `app.py` 

==========================================
Conteúdo de iniciar_servidor.bat (caminho: iniciar_servidor.bat):
==========================================
py C:\Users\Usuario\Desktop\persistencia-memoria-html\app.py

==========================================
Conteúdo de init_eventlet.py (caminho: init_eventlet.py):
==========================================

# Arquivo de inicialização para garantir que o monkey patching do Eventlet
# seja executado antes de qualquer outro import em todo o projeto
import eventlet
eventlet.monkey_patch()
print("[INFO] Eventlet monkey patching aplicado com sucesso.")


==========================================
Conteúdo de 1- documentação.md (caminho: linha_de_raciocinio\1- documentação.md):
==========================================
Segue a primeira parte da documentação, organizada de acordo com o esquema proposto. Essa seção abrange a **Introdução e Objetivos** e está escrita de forma a oferecer uma visão clara do sistema, seu estado atual e as metas pretendidas para os refinamentos e futuras melhorias.

---

# 1. Introdução e Objetivos

## 1.1. Visão Geral do Sistema
O sistema em desenvolvimento é uma aplicação de conversação que integra diferentes funcionalidades, incluindo:
- **Transcrição de Vídeos do YouTube:** Captação e processamento de legendas dos vídeos.
- **Resumo de Vídeos do YouTube:** Processamento dos dados transcritos para gerar resumos concisos dos conteúdos.
- **Interação com uma Inteligência Artificial (IA):** Permite que os usuários façam consultas e recebam respostas processadas em tempo real via streaming, com formatação em Markdown e sanitização de conteúdos.

Atualmente, as funcionalidades de transcrição, resumo e interação via IA estão implementadas e estão em operação. O sistema também utiliza comunicação em tempo real através do Socket.IO, permitindo que os dados sejam transmitidos dinamicamente para o frontend enquanto o processamento ocorre no backend.

## 1.2. Contexto e Estado Atual
- **Funcionalidades Consolidadas:**  
  - A transcrição dos vídeos do YouTube está operando conforme o esperado.
  - O resumo dos vídeos (YouTube Resumo) já foi implementado e é funcional.
  - A conversa com a IA (processamento dos textos e streaming de respostas) está estabelecida, com a renderização incremental no frontend utilizando técnicas como Markdown e DOMPurify para a sanitização.
- **Pontos de Atenção:**  
  - A linha de raciocínio e a documentação atual estão desatualizadas e contêm trechos de rascunhos antigos, informações redundantes e detalhes que não refletem mais o estado operacional do sistema.
  - Alguns aspectos anteriores relacionados ao acúmulo e duplicação de chunks de resposta, ou processos de re-renderização de conteúdo final, já foram refinados na última versão (documentação número 3).
  - Existe a necessidade de alinhar a documentação com o que já foi implementado, destacando a arquitetura de isolamento por `conversation_id` que garante que as mensagens e respostas sejam exibidas somente no chat correspondente.


## 1.3. Objetivos da Documentação
Esta documentação tem como finalidade:
- **Clarificar o Funcionamento do Sistema:**  
  - Descrever detalhadamente os componentes internos (backend, frontend, utilitários) e como eles interagem para oferecer as funcionalidades de transcrição, resumo e comunicação com a IA.
- **Documentar o Estado Atual e as Funcionalidades Implementadas:**  
  - Registrar quais módulos já estão consolidados (por exemplo, a função do YouTube Resumo) e como eles operam dentro do fluxo do sistema.
- **Identificar Pontos para Refinamento:**  
  - Especificar quais aspectos ainda necessitam de ajustes, como melhorias no layout (animação de carregamento, botão de Stop), tratamento de erros e aprimoramentos na experiência de usuário, sem impactar o que já funciona.
- **Fornecer uma Base para Novos Desenvolvedores ou Inteligências de Suporte:**  
  - Facilitar a compreensão rápida do sistema para que seja possível dar continuidade ao desenvolvimento ou manutenção com clareza sobre quais partes são essenciais, quais já foram implementadas e quais podem ser descartadas ou simplificadas na documentação final.

## 1.4. Escopo e Abordagem
- **Escopo:**  
  - A documentação abrangerá tanto os aspectos técnicos (arquivos e seu conteúdo, fluxos de dados, integrações) quanto os pontos de melhoria e refinamento necessários para evoluir o sistema de forma coesa.
- **Abordagem:**  
  - Inicialmente, serão identificados e descritos os principais arquivos e módulos que compõem a linha de raciocínio (tanto do backend quanto do frontend).
  - Em seguida, será feita uma análise de quais pontos e funcionalidades já estão consolidados, quais informações estão desatualizadas e como eliminar redundâncias para uma versão final mais fluida.
  - Serão listados também os refinamentos pendentes, que devem ser considerados para futuras iterações sem comprometer a estabilidade do fluxo principal (especialmente o isolamento via `conversation_id` e o processamento assíncrono via Socket.IO).

---

# 2. Identificação dos Arquivos do Projeto

## 2.1. Arquivos do Backend

### **app.py**  
- **Função Principal:**  
  - É o núcleo do servidor Flask, responsável por definir as rotas e endpoints do sistema.  
- **Principais Responsabilidades:**  
  - **Rotas e Endpoints:** Gerencia a página inicial, criação, recuperação, atualização e exclusão de conversas.  
  - **Integração com Socket.IO:** Configura a comunicação em tempo real, associando os clientes a salas (com base no `conversation_id`) e emitindo eventos como `message_chunk` e `response_complete`.  
  - **Processamento de Mensagens:** Trata os comandos enviados pelo usuário, diferenciando entre as requisições para a inteligência artificial e os comandos específicos para o YouTube (por exemplo, `/youtube` e `/youtube_resumo`).  
  - **Streaming de Respostas:** Implementa o envio de respostas em tempo real (chunks) para o frontend, permitindo a renderização incremental enquanto o processamento ocorre no backend.

### **init_eventlet.py**  
- **Função Principal:**  
  - Inicializa o ambiente assíncrono utilizando o Eventlet.  
- **Principais Responsabilidades:**  
  - **Monkey Patching do Eventlet:** Assegura que todas as operações ocorram de maneira compatível com o processamento assíncrono, preparando o ambiente para a execução do servidor Flask com suporte a eventos.

### **youtube_handler.py**  
- **Função Principal:**  
  - Contém toda a lógica relativa ao processamento de vídeos do YouTube.  
- **Principais Responsabilidades:**  
  - **Download de Legendas:** Utiliza ferramentas (como o yt-dlp) para baixar as legendas dos vídeos do YouTube.  
  - **Limpeza e Formatação:** Processa as legendas removendo formatações indesejadas e caracteres especiais, preparando o texto para exibição e para a geração de resumos.  
  - **Divisão em Chunks:** Pode incluir a lógica para dividir a transcrição em partes menores, facilitando o processamento e o resumo de cada bloco.

### **text_processor.py**  
- **Função Principal:**  
  - Fornece funções auxiliares para manipulação e formatação de texto.  
- **Principais Responsabilidades:**  
  - **Divisão de Texto:** Separa textos longos em blocos ou chunks de tamanho adequado para processamento.  
  - **Limpeza e Formatação:** Aplica regras para padronizar o conteúdo textual, removendo quebras de linha desnecessárias e ajustando espaçamentos, para garantir consistência na renderização.

### **chat_storage.py**  
- **Função Principal:**  
  - Gerencia o armazenamento e o histórico das conversas.  
- **Principais Responsabilidades:**  
  - **Criação de Conversas:** Implementa a criação de novas conversas, assegurando que cada conversa receba um identificador único (`conversation_id`).  
  - **Armazenamento de Mensagens:** Salva, atualiza e exclui mensagens associadas a cada conversa, geralmente utilizando arquivos JSON para persistência.  
  - **Gerenciamento do Histórico:** Permite a recuperação e o gerenciamento do histórico de conversas, facilitando o acesso aos dados anteriores.

---

## 2.2. Arquivos do Frontend

### **chatUI.js**  
- **Função Principal:**  
  - Gerencia a interface do chat e a interação do usuário.  
- **Principais Responsabilidades:**  
  - **Captura de Entrada:** Lida com o input do usuário para envio de mensagens e comandos.  
  - **Interação com o Backend:** Dispara eventos e chamadas aos endpoints para enviar comandos e receber respostas via Socket.IO.  
  - **Gerenciamento de Sala:** Executa funções para juntar ou sair de salas com base no `conversation_id`, garantindo que as mensagens sejam exibidas no chat correto.

### **messageRenderer.js**  
- **Função Principal:**  
  - Responsável pela renderização das mensagens no DOM.  
- **Principais Responsabilidades:**  
  - **Conversão de Markdown:** Utiliza a biblioteca `marked` para converter o conteúdo das mensagens em Markdown para HTML.  
  - **Sanitização:** Aplica o DOMPurify para sanitizar o HTML gerado, garantindo segurança e evitando a injeção de scripts maliciosos.  
  - **Renderização Incremental:** Trata a atualização em tempo real das respostas (chunks) sem duplicação, utilizando técnicas que evitam a re-renderização do conteúdo final.

### **commandHandler.js**  
- **Função Principal:**  
  - Processa comandos especiais digitados pelo usuário (ex.: `/youtube`, `/youtube_resumo` e outros).  
- **Principais Responsabilidades:**  
  - **Filtragem de Comandos:** Identifica os comandos inseridos pelo usuário e direciona para os handlers específicos.  
  - **Interação com o Backend:** Encaminha as requisições para as rotas correspondentes, garantindo que os comandos sejam processados corretamente e que o fluxo de dados siga o isolamento por `conversation_id`.

### **utils.js**  
- **Função Principal:**  
  - Disponibiliza funções auxiliares que podem ser utilizadas em diversos pontos do Frontend.  
- **Principais Responsabilidades:**  
  - **Escape HTML:** Prover segurança para conteúdos que não passem pelo processo de conversão de Markdown.  
  - **Animações de Carregamento:** Controla a exibição de loaders e placeholders enquanto as respostas estão sendo processadas.  
  - **Outras Utilidades:** Funções diversas que facilitam a manipulação do DOM e o tratamento de erros ou estados especiais na interface.

---

# 3. Análise de Conteúdo Atual

## 3.1. Funcionalidades Consolidadas e Operacionais

### Transcrição e Resumo do YouTube
- **Transcrição:**  
  - A função de transcrição dos vídeos do YouTube já está implementada. O sistema capta as legendas dos vídeos através do módulo do `youtube_handler.py`, realiza o download utilizando ferramentas como yt-dlp, e efetua a limpeza e formatação das legendas.
- **Resumo do YouTube:**  
  - O resumo dos vídeos está funcional. Utiliza a transcrição obtida, divide o conteúdo em blocos (chunks) se necessário e processa cada bloco para gerar um parágrafo resumido. Essa funcionalidade já foi integrada ao backend e está operando de maneira isolada por `conversation_id`, garantindo que os resultados apareçam no chat correto.

### Comunicação com a Inteligência Artificial
- **Processamento de Mensagens e Streaming:**  
  - A interação com a IA, que envolve o envio de mensagens, processamento com streaming e renderização incremental dos chunks de resposta, está consolidada.  
  - O backend (no `app.py`) gerencia o fluxo de mensagens via Socket.IO, isolando as conversas por meio do `conversation_id`, o que permite que a resposta seja renderizada em tempo real sem interferir em outras conversas.

### Gerenciamento de Armazenamento e Histórico
- **Persistência das Conversas:**  
  - O módulo `chat_storage.py` já garante a criação, atualização e armazenamento dos históricos de conversas em arquivos (geralmente JSON), permitindo a recuperação e manutenção dos dados associados a cada conversa.

## 3.2. Elementos que Estão Atualizados

### 3.2.1. Acumulação e Re-renderização Redundante dos Chunks  
**Funcionamento Atual:**  
- O sistema **não acumula chunks no backend**.  
- Cada chunk é enviado individualmente via Socket.IO e renderizado incrementalmente no frontend.  
- O evento `response_complete` finaliza o streaming sem reprocessar o conteúdo, garantindo eficiência.  

---

### 3.2.2. Processamento Manual de Eventos e Logs  
**Padrão Adotado:**  
- Logs são integrados de forma padronizada:  
  ```javascript
  logger.debug('Evento recebido', { conversationId, detalhes }); 
  ```  
- Verificações críticas (ex: `chatId`) são mantidas para evitar vazamentos de contexto.  
- Detalhes internos refinados (ex: `isNearBottom`) são omitidos da documentação, mantendo-se apenas a descrição do comportamento final.  

---

### 3.2.3. Fluxos da IA e do YouTube  
**Arquitetura Unificada:**  
- **Padrão Comum:**  
  - Socket.IO para streaming em tempo real.  
  - Isolamento por `conversation_id`.  
  - Renderização incremental com Markdown/DOMPurify.  
- **Diferenças Específicas:**  
  - **YouTube:**  
    - Download e processamento de legendas via `youtube_handler.py`.  
    - Divisão em blocos de ~300 palavras para resumo.  
  - **IA:**  
    - Integração direta com API de IA para respostas dinâmicas.  



## 3.3. Pontos para Refinamento (Melhorias Pendentes)

- **Ajustes na Interface do Frontend:**  
  - Refinar animações de carregamento e a exibição de placeholders para melhorar a experiência do usuário, garantindo que o conteúdo seja atualizado apenas no chat ativo.
  - Revisar a implementação do botão de Stop, assegurando que ele interrompa efetivamente o streaming, sem deixar processos em segundo plano.

- **Padronização da Renderização e Sanitização:**  
  - Unificar o processo de renderização no frontend, utilizando sempre a conversão com Markdown (via `marked`) seguida pela sanitização com o DOMPurify.
  - Garantir que a função `escapeHTML` seja utilizada somente em casos onde o Markdown não se aplique.

- **Documentação dos Logs e Monitoramento:**  
  - Simplificar a descrição da geração e tratamento dos logs, ressaltando os pontos onde são essenciais para o debug e monitoramento sem entrar em detalhes de implementações que já foram refinadas.

- **Aprimoramento do Isolamento por Conversation_id:**  
  - Validar se todas as requisições e eventos (fetch, SSE, Socket.IO) estão transportando corretamente o `conversation_id` e se a verificação de contexto no frontend (exemplo: `if (response.chatId !== currentChatId) return;`) está garantida.

---

# 4. Refinamentos e Melhorias Necessárias

## 4.1. Ajustes na Interface do Frontend

- **Animação de Carregamento e Placeholders:**
  - **Objetivo:**  
    Garantir que a animação de carregamento seja exibida de forma consistente e que os placeholders sejam criados e removidos apenas no chat ativo.
  - **Melhoria Proposta:**  
    - Utilizar uma classe CSS com `white-space: nowrap` e elementos inline para evitar que a animação quebre a linha.
    - Garantir a remoção imediata da animação assim que a resposta completa for recebida pelo evento `response_complete`.

- **Botão de Stop:**
  - **Objetivo:**  
    Assegurar que o botão de Stop interrompa completamente o processo de streaming, evitando que chamadas fiquem em segundo plano.
  - **Melhoria Proposta:**  
    - Revisar a implementação para utilizar mecanismos como `AbortController` no backend, cancelando requisições que ainda estejam em processamento.
    - Refinar o design do botão para que fique visualmente claro, utilizando um ícone (por exemplo, um “X” dentro de um retângulo) que comunique de forma imediata sua funcionalidade.

## 4.2. Padronização da Renderização e Sanitização

- **Consistência na Conversão de Conteúdo:**
  - **Objetivo:**  
    Garantir que todas as mensagens — sejam respostas da IA ou resultados do YouTube — sejam renderizadas de forma consistente, evitando riscos de injeção e discrepâncias visuais.
  - **Melhoria Proposta:**  
    - Utilizar sempre a conversão de Markdown através da biblioteca `marked` seguida de sanitização com o DOMPurify.
    - Utilizar a função `escapeHTML` apenas para conteúdos que não passaram pelo pipeline Markdown, mantendo a segurança e a integridade do HTML renderizado.

## 4.3. Monitoramento e Logs

- **Simplificação e Padronização dos Logs:**
  - **Objetivo:**  
    Facilitar o monitoramento e o debug sem sobrecarregar o sistema com informações redundantes.
  - **Melhoria Proposta:**  
    - Resumir os detalhes dos logs para destacar somente os eventos críticos, como erros de requisições, inconsistências no `conversation_id` ou falhas durante o streaming.
    - Garantir que os logs sejam enviados tanto para o backend quanto para o frontend com identificação clara do contexto (por exemplo, utilizando tags ou prefixos que indiquem se o log é relacionado à IA ou ao módulo do YouTube).

## 4.4. Isolamento por conversation_id

- **Validação e Consistência do Chat Ativo:**
  - **Objetivo:**  
    Evitar que mensagens de uma conversa "vazem" para outra e assegurar que todos os eventos (fetch, SSE, Socket.IO) carreguem o `conversation_id` corretamente.
  - **Melhoria Proposta:**  
    - Revisar e assegurar que cada requisição e evento inclua o `conversation_id` e que o frontend realize a verificação do `chatId` para descartar respostas que não correspondam ao chat atualmente ativo.
    - Implementar testes de troca de contexto para garantir que, caso o usuário mude de chat durante o processamento de uma mensagem, a resposta permaneça associada à conversa original.

## 4.5. Revisão dos Mecanismos de Divisão e Processamento de Texto

- **Otimização da Divisão em Chunks:**
  - **Objetivo:**  
    Garantir que a transcrição e o processamento para o resumo do YouTube sejam divididos em partes de forma que o processamento seja eficiente e o usuário receba respostas coerentes.
  - **Melhoria Proposta:**  
    - Revisar os métodos de divisão de texto no arquivo `text_processor.py`, assegurando que os chunks gerados sejam adequados para o processamento sem perder o contexto.
    - Ajustar a lógica de reenvio e renderização incremental para evitar redundâncias, especialmente se os chunks já forem processados de forma independente no fluxo final.

---


5. Arquitetura e Fluxos do Sistema
O Tópico 5 detalha a arquitetura do sistema conversacional, incluindo os fluxos de dados entre o frontend e o backend, o funcionamento das principais funcionalidades (transcrição, resumo e comunicação com IA) e os mecanismos de isolamento e streaming que garantem a coesão e a segurança do sistema. Esta seção também apresenta diagramas visuais para ilustrar os processos e destaca aspectos críticos como o uso do conversation_id para evitar vazamentos entre chats.

5.1. Visão Geral da Arquitetura
O sistema é uma aplicação web baseada em Flask (backend) e JavaScript/HTML/CSS (frontend), projetada para oferecer interações em tempo real com três funcionalidades principais:
Transcrição de Vídeos do YouTube: Extrai e processa legendas de vídeos.
Resumo de Vídeos do YouTube: Gera resumos concisos a partir das transcrições.
Comunicação com Inteligência Artificial (IA): Permite conversas dinâmicas com respostas renderizadas incrementalmente.
A arquitetura utiliza o Socket.IO para comunicação assíncrona, garantindo atualizações em tempo real. O isolamento entre conversas é assegurado pelo uso consistente do conversation_id, enquanto a renderização no frontend é unificada com Markdown (marked) e sanitização (DOMPurify).
Componentes Principais
Backend:
app.py: Servidor Flask que gerencia rotas, endpoints e eventos Socket.IO.
youtube_handler.py: Processa vídeos do YouTube (download e limpeza de legendas).
text_processor.py: Manipula e divide textos em chunks.
chat_storage.py: Gerencia o armazenamento e histórico das conversas.
init_eventlet.py: Configura o ambiente assíncrono com Eventlet.
Frontend:
chatUI.js: Controla a interface e captura interações do usuário.
messageRenderer.js: Renderiza mensagens incrementalmente no DOM.
commandHandler.js: Processa comandos como /youtube e /youtube_resumo.
utils.js: Fornece funções auxiliares (ex.: escape HTML, animações).

5.2. Fluxo de Dados e Processos
O sistema segue um fluxo bem definido para processar mensagens e comandos, desde a interação do usuário até a renderização final. Abaixo, descrevemos os fluxos gerais e específicos para cada funcionalidade.
5.2.1. Fluxo Geral de Dados
Entrada do Usuário:
O usuário digita uma mensagem ou comando (ex.: /youtube <URL>) no frontend (chatUI.js).
A mensagem é enviada ao backend via HTTP (fetch) ou Socket.IO, sempre acompanhada do conversation_id.
Processamento no Backend:
O app.py recebe a requisição e verifica/armazena a mensagem em chat_storage.py.
Dependendo do tipo de mensagem:
Mensagem normal: Encaminhada para process_with_ai_stream() para interação com a IA.
Comando YouTube: Direcionada ao youtube_handler.py para processamento específico.
Streaming de Respostas:
Respostas são geradas em chunks (IA ou YouTube) e emitidas via Socket.IO para o frontend.
Cada chunk carrega o conversation_id, garantindo que seja renderizado no chat correto.
Renderização no Frontend:
O messageRenderer.js converte os chunks em Markdown, aplica sanitização e atualiza o DOM incrementalmente.
O evento response_complete finaliza o streaming, removendo placeholders.
Persistência:
O histórico é atualizado em chat_storage.py, associando mensagens ao conversation_id.
5.2.2. Fluxo Específico: Comunicação com IA
Entrada: Usuário envia mensagem via /send_message.
Processamento: process_with_ai_stream() chama a API da IA (ex.: gemma2:2b), gerando chunks.
Saída: Chunks são emitidos via Socket.IO (message_chunk) e renderizados em tempo real.
5.2.3. Fluxo Específico: Transcrição do YouTube
Entrada: Comando /youtube <URL> enviado via /process_youtube.
Processamento: youtube_handler.py baixa legendas com yt_dlp, limpa o texto e formata a resposta.
Saída: Resultado enviado como mensagem única via Socket.IO (youtube_response).
5.2.4. Fluxo Específico: Resumo do YouTube
Entrada: Comando /youtube_resumo <URL> enviado via /process_youtube_resumo.
Processamento:
youtube_handler.py baixa e divide a transcrição em blocos (~300 palavras).
Cada bloco é processado pela IA para gerar resumos.
Saída: Resumos são enviados como chunks via Socket.IO (message_chunk), com cabeçalhos por bloco.

5.3. Diagrama de Fluxo de Dados (DFD)
Abaixo está o diagrama em MermaidJS que ilustra o fluxo completo do sistema, destacando o isolamento por conversation_id e a integração entre os módulos.
mermaid
flowchart TD
    %% Frontend: Captura e Envio
    A[Usuário Interage<br>(input ou comando)]
    A --> B[chatUI.js:<br>Captura e envia mensagem]
    
    %% Envio para o Backend
    B -->|HTTP ou Socket.IO<br>com conversation_id| C[app.py:<br>Recebe requisição]
    
    %% Processamento no Backend
    C --> D[chat_storage.py:<br>Verifica e armazena]
    D --> E{Tipo da Mensagem?}
    E -->|Normal| F[process_with_ai_stream():<br>Geração de chunks]
    E -->|/youtube ou /youtube_resumo| G[youtube_handler.py:<br>Processa YouTube]
    
    %% Streaming e Resposta
    F --> H[Socket.IO:<br>Emite message_chunk]
    G --> I[Divisão e<br>Processamento]
    I --> H
    
    %% Renderização no Frontend
    H -->|room=conversation_id| J[messageRenderer.js:<br>Renderização incremental]
    J --> K[DOM:<br>Markdown + Sanitização]
    
    %% Finalização
    K --> L[Evento response_complete:<br>Finaliza streaming]
    
    %% Armazenamento
    D --> M[chat_storage.py:<br>Atualiza histórico]
Aspectos Destacados
Isolamento: O conversation_id é usado em todas as etapas para garantir que mensagens sejam processadas e exibidas no chat correto.
Streaming: Tanto a IA quanto o YouTube utilizam Socket.IO para enviar chunks, permitindo renderização em tempo real.
Modularidade: Os fluxos de IA e YouTube são distintos, mas convergem no mesmo pipeline de renderização.

5.4. Mecanismos Críticos
5.4.1. Isolamento por conversation_id
Funcionamento: Cada conversa tem um identificador único (conversation_id), gerado em chat_storage.py. Todas as requisições e eventos Socket.IO usam esse ID para associar mensagens ao chat correto.
Implementação:
Backend: join_room(conversation_id) associa clientes a salas específicas.
Frontend: Verifica if (response.conversation_id !== currentChatId) para descartar mensagens irrelevantes.
Benefício: Evita "vazamentos" entre chats, mesmo em cenários de troca rápida de contexto.
5.4.2. Streaming em Tempo Real
Funcionamento: Respostas são divididas em chunks e enviadas via Socket.IO (message_chunk), com finalização sinalizada por response_complete.
Implementação:
Backend: process_with_ai_stream() e process_youtube_resumo_background() geram chunks dinamicamente.
Frontend: messageRenderer.js atualiza o DOM sem acumulação redundante.
Benefício: Permite feedback imediato ao usuário, mantendo a interface responsiva.
5.4.3. Renderização e Sanitização
Funcionamento: Todo conteúdo é convertido para Markdown (marked.parse) e sanitizado (DOMPurify.sanitize) antes de ser inserido no DOM.
Implementação: Centralizado em messageRenderer.js, aplicado a respostas da IA e YouTube.
Benefício: Garante segurança contra XSS e consistência visual.

5.5. Pontos de Integração
Frontend-Backend: Comunicação via Socket.IO e HTTP, com conversation_id como chave de roteamento.
IA-YouTube: Fluxos paralelos que convergem no streaming e renderização, mantendo independência operacional.
Armazenamento: chat_storage.py atua como camada central para persistência, usada por todos os módulos.

5.6. Considerações sobre Escalabilidade
Processamento Assíncrono: O uso de Eventlet e Socket.IO suporta múltiplos usuários e chats simultâneos.
Modularidade: A separação entre IA e YouTube facilita expansões futuras (ex.: suporte a novos comandos).
Persistência: O armazenamento em JSON é funcional, mas pode ser substituído por um banco de dados para maior escala.

---

# 6. Diagrama de Fluxo de Dados Atualizado

Nesta seção, apresentamos diagramas em MermaidJS que sintetizam o fluxo de dados de forma clara. Os diagramas ilustram como as requisições são processadas, desde o envio da mensagem pelo usuário até a renderização incremental dos dados no frontend e a integração entre os módulos de transcrição, resumo e comunicação com a IA.

## 6.1. Diagrama Geral do Sistema

```mermaid
flowchart TD
    %% Frontend: Captura e Envio
    A[Usuário Interage (input de mensagem ou comando)]
    A --> B[chatUI.js: Captura e envia mensagem]
    
    %% Envio para o Backend via HTTP / Socket.IO
    B --> C[app.py: Recebe requisição com conversation_id]
    
    %% Processamento no Backend
    C --> D[Verifica e armazena a mensagem (chat_storage.py)]
    D --> E{Tipo da Mensagem?}
    E -- Mensagem Normal --> F[Processamento da IA]
    E -- Comando /youtube ou /youtube_resumo --> G[youtube_handler.py: Processa YouTube]
    
    %% Streaming e Resposta
    F --> H[process_with_ai_stream(): Geração de chunks]
    G --> I[Divisão e Processamento do Texto]
    H & I --> J[Socket.IO: Emite chunks para o frontend]
    
    %% Renderização no Frontend
    J --> K[messageRenderer.js: Renderização incremental]
    K --> L[Atualiza DOM com Markdown e Sanitização]
    
    %% Feedback e Finalização
    L --> M[Evento response_complete: Finaliza streaming]
    
    %% Armazenamento do Histórico
    D --> N[chat_storage.py: Atualiza histórico de conversas]
```

## 6.2. Aspectos Destacados no Diagrama

- **Isolamento por conversation_id:**  
  Todas as requisições e eventos carregam o `conversation_id`, garantindo que cada mensagem e resposta sejam processadas e renderizadas somente no chat correto.

- **Fluxo Paralelo para IA e YouTube:**  
  O diagrama diferencia, a partir de uma decisão (bloco E), o processamento normal (para a IA) e o processamento específico dos comandos do YouTube. Apesar de distintos, ambos utilizam o mesmo mecanismo de streaming via Socket.IO para enviar chunks de resposta ao frontend.

- **Renderização Incremental:**  
  Os chunks de resposta são enviados progressivamente para o frontend, onde a função de renderização (messageRenderer.js) converte o conteúdo para Markdown, aplica sanitização (com DOMPurify) e atualiza o DOM de forma contínua, mantendo o usuário informado em tempo real.

- **Finalização e Armazenamento:**  
  Após a conclusão do processamento e streaming, o evento `response_complete` sinaliza a finalização do fluxo de dados, enquanto o histórico é atualizado no backend para futuras consultas.

---

# 7. Conclusão e Considerações Finais

## 7.1. Resumo dos Pontos Principais

- **Funcionalidades Consolidadas:**  
  - **Transcrição e Resumo do YouTube:** O sistema já capta legendas de vídeos, as processa e gera resumos de forma eficaz.  
  - **Interação com a Inteligência Artificial:** O fluxo de mensagens e o processamento em streaming estão funcionando, com isolamento das conversas por `conversation_id`.  
  - **Armazenamento e Histórico:** A criação, atualização e recuperação das conversas funcionam corretamente, possibilitando a manutenção do histórico dos chats.

- **Arquitetura e Fluxo de Dados:**  
  - O sistema integra a comunicação via Socket.IO para atualizações em tempo real, garantindo que cada mensagem e resposta seja associada ao chat correto.  
  - A separação dos fluxos, tanto para a IA quanto para o processamento do YouTube, permite que modificações em uma área não comprometam a outra.

- **Refinamentos e Melhorias Pendentes:**  
  - Ajustes na interface do frontend (animação de carregamento, botão de Stop e placeholders) para uma experiência de usuário mais clara e consistente.  
  - Padronização da renderização e sanitização do conteúdo (Markdown com `marked` seguido de DOMPurify) para segurança e consistência visual.  
  - Otimizações na lógica de verificação e isolamento via `conversation_id`, assegurando que as respostas sejam canalizadas corretamente mesmo em situações de troca de contexto ou multitarefa.

## 7.2. Próximos Passos

- **Implementação dos Refinamentos:**  
  - Continuar a aprimorar os elementos de interface e a lógica de streaming, evitando qualquer acúmulo desnecessário ou duplicação de dados.
  - Revisar e testar a funcionalidade do botão de Stop, assegurando que ele interrompa os processos de streaming como esperado.

- **Testes e Validações:**  
  - Desenvolver e expandir os testes unitários e de integração para validar o isolamento por `conversation_id` e o fluxo completo de dados.
  - Monitorar logs e desempenho para detectar e corrigir eventuais problemas, garantindo a robustez do sistema durante cenários de uso real.

- **Documentação Contínua:**  
  - Manter a documentação atualizada à medida que novos requisitos e refinamentos são implementados, permitindo uma transição suave para desenvolvedores e sistemas de suporte.
  - Incluir novos diagramas e exemplos de uso quando houver alterações significativas nas funcionalidades ou na arquitetura do sistema.

## 7.3. Considerações Finais

A documentação apresentada reflete o estado atual do sistema, destacando as funcionalidades já consolidadas e os pontos onde melhorias ainda são necessárias. A abordagem modular e o isolamento por `conversation_id` garantem que as integrações entre os diversos módulos — transcrição, resumo e IA — operem de maneira coesa e sem interferências.  

Com estes ajustes e refinamentos, o sistema se torna mais robusto, escalável e de fácil manutenção, proporcionando uma experiência de usuário consistente e segura. A continuidade do monitoramento e dos testes garantirá que futuras atualizações sejam incorporadas sem comprometer o funcionamento das funcionalidades essenciais.

==========================================
Conteúdo de 2- DFD com foco no youtube- 2025-04-02.png (caminho: linha_de_raciocinio\2- DFD com foco no youtube- 2025-04-02.png):
==========================================
PNG

   
IHDR  
      n   sRGB     IDATxi|U;+5la]" `@P((
2>=l" °"qddK0(BEM:@'thSO]UN:Uſ.4M               ,[                               ~               #            /4=   \Gø)           ל6{nm   ȭ6纂Rx           Ŷit^    a[           p͸kŶNE-   ]hkټ^ٷ           r'feei}0/CN)t>LWCLIr'Sw2CiʸSW9k^ifz{lyv˶_q+ϥKZ<Ǖm?qdoq}>9=?9|km?z~w?{r΃u>ٯWBrٯGy_`<|.]Ȝuu>˟ty/'˫Y>]{|O.s.7?^>/kVC2m($F-           s'feeL}$K#r..-S,sXĻHGr^l~HDqqo/xLيP}nOWџ?$|ѻ}.c{α^X6 /{}1._^EqW_ g?er/<]>;{wߟ_^|ri9_`mݕCSfjw}<.]}6 u'sܻ]Sӛ7Ϲѥ))Ð쉷˝ޖ\
o          5N^x)U$Q]a!<wٓ>oRZnyﵟWyw^E9#$<瑭hPSίwqYAW9-<]n~sk8{}9ls=~Sa̯|6/;9So~I_׫Et[][?G}>O9O˵m~_>/wb~3wΥt*33S6M6MA-           ŷYYYr:l2%-x=ZUbV    %ߠIv+I
           쉷[)   yLߠۂ           \s\w   0܏y]| E            Hޒx  bf;WE-           ;xI"J!ĵ5P9$           i$EGrr
jժ),,LJR4gvƍaJNNt=s={vaKNNa8qb_Ր!CTvmEFFB
ҥVZ}-N<y\vzqmݺUahرn0`аaî \-3gRx           [humiҤIر^{5=:u^=ӶRJJHHPXX_}=zTo233krJ5lP&LPN4j(=SڿڵkqqǍ;wJfgϞՌ3ԠA7N|șx{5	           HiӦ_~њ5kԪU+#F;Ԉ#OXbJHHPBBBGk]'NPbbnF-_\e˖l2dO*!!A*U
Hc̙JKKӇ~VZ髯R^=, ~"           X
@ѐ"I^zͦ#FhJKKJF5Cɒ[;Tɒ%UX1jJ_$iӦM$[vZkNŊSLL~>|س}ܸq*SVX
*<<\5jӵm6~튌Tjgy{ԩJ,PUZU/=73f7߬5iD[lis!=*]"##զM}>u	}^EzK:~׶׫e˖
WJꫯ4/8p@=*T+WN}щ'$I]vդIk.Yfk+VP۶mUxqƪo߾}>}oTDDn6-^ث+jԨQz'UT)EEEgϞ:yFoQ%JPn|j?^ZR˖-մiS}@d-            H{W뮻4uTOA$nZcƌQr|;sd4}t͙3GŊS׮]o>կ__˖-$=Z$
c]pAӦMرcenZOi=c5j~ũ_~ѣz)%%%u߿'Uܾ}{iʔ);w:t^{M&M׼̘1C4hYfgϞڜ8qB-ZЪU4j(}*Qmذ!_[xbccRkذLMzթS'M6M-Z5eIҹsԦM%%%i̘1Zhy͚5K$;VݻwW\\vؑD+Vcǎ
ԩS;h͚5ܹN߯xmܸQOu]>Æ
SXX6lؠO?TsQc-YD3fЪU4tLk٣5k衇$O+VΝ;?[Gz           ( oN:ZxyGTfMmV{VvroΝ:~~iuIԴiSk:=)*To
7ܠK*22RԦMU^]
&IԿ/uQkٲe߿%I>3mذAժUSRR7o3g*44TԹsg-\PV#<˺4uTIR.]6GѣGyf5ls[nEC>ޡCTF
ۻ Ib
-[L}O?X}jԨ$Cj*Ihv:/իk풤rʩ駟ٳt
7Hu[oUVϞ==}լYSo$F]viĉTztjݺuL0AQQQ{/cꭷ
1 .o          x~mۦݻw?TӦM5gqz衇t:}[ʗ/x@ЬYd5fխ[79sF6l=ܣPeff*33SʕS͵d]K*%IWI*Q$)55UԿ]V6MwkܹspqIܹS=zZ{-/_\Sz<bn^ZϟCYYY~ws&KRHHoIr߆
ԨQ#:tH+V￯۷k>ru֩{[Ij׮'xʕj׮VP߾}uAOR$5iīRJf͚luj>i$u]i̙3
		]wݥI&ٳW} /          #(LTzz$WO<ӧȑ#z饗g//22R֭Sbb͛^zlٲJLL̳82%%EiSHHkժU:|W(><멧RttjժG}T7oVHHLSNIʖ->66V6ۥ'Oj>>f*U/\͖-[|s/lټ
}]UPA+WV=4{|GnRSSrԩS*_zI~Xh=)Sxל9s?P H           B-P4ƪ>CBB+nk͹[Z5}':znݪ!C/K/kIғO>7ꫫ:Ai	zu	9rDg)N2eH֟:uʫ5&&F͛7\6nܨXcǎuդI<67SL3<>}h߾}JMM7|.[ŋn).6MSsՑ#GTT)9#GH4UR%YUJ}A!           X
@о}{͚5+ׂŋ+++KuٶpB,YRwajذFڵkk$.Ith5nXIIIjҤFW_\V^[oUuݻW*RJQF1cW2lviǎ=/RGVHH|UL
8P'Nv9=
		c=wW믿8I҅zjN


Uf4o<֭[ݻ߮+VѣijԩSʕu@8~,X_ZyW6mҦM            RH7xCKV֭գGԈ#t[nj޼xn6EDDgϞϵtR
<Xu}Ip;qDM:UK6mR.]4g?Q.]pB5oΥYf駟*))I'OVd=/۶mS5|3FCa\*2d"""Ԯ];M8QK.ճ>_]uԑ)WR4qD޽[5vX
6Lj	&ZjL
:T6m҂{zGLL߯ѣGk׮]~+hݺ5o<M<Y}QVtwhС
S۶m5yd͝;Ww}6nܨ_~'>3eddw޹n衇$[d#`=           @PJmݺUo-ZK*++KիW5x`Ky馛'o߾ŋkСzwm6=ر-[_~Y}QHH5jŋ}Wu.oNtiРA:|ڄ͟?_Æ
S^TjUM<Y]vwiС<xΝ;ի>=.]h3f̙Gtjڴf͚f͚嫿8q}]UPA;wVշo_m޼YM4O<BBBTV-ر/^#FSɒ%u=hȑr8ӷ~CjРAT&Mh"%$${~a	U7n5je˖>}y+Vxk           ( 4t:;wN7^_Fɐ˴k0  `15{`[FPxxp8d:K           BB-   
K o)           A*?fEEE]5bĈ"y@9r_c^lYX@;            
[ 6r~+.'|R<^(+d-            HgUZx`㲊@&           @x  B-           o ;a@2[           t$ WۜZ           RH \µ.5CaflCE-           o wair:^/
o-w4Mo-[           `)$ Gd۬,<KNS2wCl)CN$)Le9yν{{:m_c|6I6wÐKsun&Ib\m$           K! p=r'feeir-rzB2e8d)t\6/.;s,_n8\r#W{b?˾=M)ɔYLeޱS[tx           ,[ ĝt6++6v%l͕j)t^\ww//&z˾.rn^O<<mzy~sm;Kkbdق{  H           B- z.TxkaH^Q
`s2t7On\#n@&R
           [ ȝx~I߆xZpݢd-            H \otf/4ģ(As)o          x ^nMO'ۜE           RH \rJO=$B[
p>o          x )E	w)o          x !E	l-[           `)$ b<4$H           B-  .(ACex           ,[  \L(JАxkY$           K!  C<4$Z           RH 4y%hH,o          x a(JАxkY$           K!  S<4$Z           RH 
E-           o p1ME	o-[           `)$ b<4$Z           RH 
E-           o p1ģ(ACex           ,[  \L3̘1CڿGx/^xM>ݯ;wȑ#m<y"ֲH           B-  .aGQ>3uQ{}||UVȣ[Gz           ( o p1eGQΟ?GyD-[{W_}Gt$Z           RH PpE9}FhB={Դi<gk͚5^9R;w,?^z^zI			8p~'OYf}3gڶm:hܹFiw9ѣZhԩSe:["           X
  fpE6l<^xA%Kի5fEGGK.~3b_^
Rʕu}'iΜ9풤47N
RjjTOff_~E=V^o9!CI@&Rx           [  \#l޼Y={Tǎ%I񊌌Ttt}+55U<^,JNN֍7(Ram׮]skٲe5zh~풤VZphʔ)_؂7o-[           `)$ b*~5kLSNկnM-ZO<c飏>$СC:pV^-Ij_N<JJJRDD֭k׮2ev[o-[           `)$ b(KΟ?tvJ>ҥKrJIRC5kׯoݻw+$$DիWWLLLm˖-g?J.L2g=+"ֲxkXO            D-  .GQGuC
[###Ohٚ?_?Iq9sϫTR6m֬Y)Ssιr%JPJJ'NH7H@&Rx           [  \#|r8/mϞ=ںu5k&IԩS'͙3GT|yy^    IDAT%&&cǎbŊI.pႶnY駟t=ú馛p8$I6l$9NߴiS;wNVZpBIRZH@&:           @x >G}TcǎU޽նm[Z|cIJ,nI222TjU۷OWBB$W1n54~x)**J3gΔ$֮][6M'NniZp,X I:wСMÇS\\֯_ӧW^D߀ ֲxK-           :o p1GQ}QUXQg֗_~gϪL2ҥyUP>M8QNR2eԫW/=6#GԨQ4zh/^\=zP۶m5uTIRժUk?֓O>%J~?~-[^z~p>￯)SӪX/Ee20M           PLӔTff222t9-xA&C/JJ= xy-ٔ&4RV߉ctap9ppn{}QxUƃme=@
ff/[           o p1'OZV o)           A*  S<4$Z3)           AG-  .x%hH,o          x i(JАxkY$           K!  Q!ֲH           B-  .x%hH,o          x !E	o-[           `)$ b<4$Z           RH 0x%hH,o          x )E	o-[           `)$ bGQ["           X
  &
E-           o p1E	o-[           `)$ bGQ["           X
  Q!ֲH           B-  .ɣ(ACex           ,[  \GQ["           X
  Q!ֲH           B- zdd+t6ģ(A-s=:h
d#`=            땻]iST+YӐS6S2d^)[>>g_gȔ-^]0K3{[e;W}y{W;fy.52[           t$ 7nm6l6ҧa2YrȔa:e)zw^~0yi_vg{o7L׸=>.lZ           RH \EQ`JS)5LlًDMl)XDZ:.ӔbRݴ_low^\/R{e?f33K8 *_"".7gfh.~7])tʔ)eL>4MDn{oQx           ,[ ]tkբn֍eff*++Ki4s+4$ٯp/+%%E-Z$}ԡC
LIYSml69($$īۢ[           `)$ 7Nw᭻fpt^'<<944TA_;o-[           `)$ 'a4MOѧJu,-
ŷE6{Q}
r&R[x           ,[ ȝ.t:ۢv+Iaaaϡ^vZ[           `)$ 7SoK9nJmHHnZ3^X3ۢ[           `)$ G}BۜKvkh#           X
 YBϢX|jjQ7.[           `)$ pIQ,J-)           P@$  2[           t$  x           ,[   o          x  B-           o  PXH           B-   
           RH  @a!           X
   (,$           K!   [           `)$  x           ,[   o          x  B-           o  PXH           B-   
           RH  @a!           X
   (,$           K!   [           `)$  x           ,[   o          x  [Gz           ( o %==]
*H.\YfA?xˌ          # PXvܩ`0o<۷q$ׇhըQ#(xkXO            D-   
K o)           AG-   
           RH  @a!           X
   (,$           K!   %           P@$ 
ѣ{nUTI/RmL5k֨nݺzgq%N7|~ANRdd*U;Sj
fVXJ o)           AG- C*W׶Lmٲ%H#ÕڵK}$y抍UZZ6nܨ1cƨo߾jժUG?3o          x (l+Vԉ'Ν;{m۱c.\S?+&&F?/ٖ~[ӦMS:uTt f$           K! P6lkMԨQ#9rgkj:v옢Լyss=
		l5kﯹsѣ*^ZnKE)99YYz{kժUJNNi*W:uf͚y8p@_~ۧ~JNN֙3g=+##C7t,Y?C+VT>}tq͛7O)))(...Ϲ5MS};vLjܸuHIرcRSS/^6vݺu:sUt뾦ZdΜ9)MIIW_}]vٳTtK?aÆiРAogUVرm۶M!!!j֬z){޼yڱcEFFnݺJLL_T6moi˖-JOOWՕo3j֬Y_ݻzz-Z$:uJKV֭աC<|2            
[ p-СC:vg]FFnݪ[nŧE4ydUREO=:uUViܸq^矫k׮zղeK͛7O7o$ݻW|jժ~Z>>{Ob
M<Yu+""B&L%>ǌ4O=zڵke˖ԶmO^ӧokӧ"4}iٚ4ij֬cǎ[o)33ϫ*QjԨJ*R$ɓ9r8=zGUDD}]%%%y;~x5mTÇW˖-xb+*_-_\ׯΣFճgO=С6oެ3gzpBI׿U<8qBuyO]v՜9stIOLZbڴi'xBӬY4cƌ
           RH \uUddt]wIo.ݮziܹiiiZ`7n~Iի%Kjرڳgj֬)Ir:ի5j$IvZm۶MM6޽{evIRtt~G?^JNNV֭uzPBڳgʕ+Zs)**JW^y@ԣ>Ij[d=6۷ĉ9MIIվ}{%&&J4hg?N:e~źpႆhIRÆ
oh֬Yjڴm=cҥkUPso/_^+W޽{բE%''DzUreI{_՞={Q|yǳ|wj:qʖ-%Kfg\J*^yf/8pjРv.]={Yo$           K! p-v5n+tӦMjܸvW})##Cr233=un맟~j.t+Q%SꫯjڹsVݻ{
q{>}:t萒j*IܹSujJOwk~]dIOѭ$+VL =:{Tfͼ7h@Ŋݻs_v]NwVZ<Ed7oSNy҃%y[XX׹KRxxΝ;i?tPU\Y)))ڵkVX#G$f[g?5kz]ʕ++66\<Enz$~
H           B- Z׺u딜%Kj4hO3gH>\IMMZ

icpqqqzl2\RK,QDDڶmnݺ08qB3f_r9sƫP֭Dsmp_ZCNўՂ*U>|6PŊeەX$W|]ܿ-^XOVDD*WS-I!!!^ˆ;]DS}6;yjz[
o          @Бx Vjժŋ+))Ie˖UDD'6;wk߾}UbEtVZ?+WjѢET7nw}WYYYzgUZ5*%%E7nݧ?SLq_]JږUJr)Wvء{z>>#GSNѣ+>}ZN^3fНwީ6mڨlٲI&yWTTT<sJ.-Iyx:xkXO            D- ZjҤl٢$f-^vUjU+22RfѣG>y4|peeepvӧ$)%%E;[oUkܹSҥZji׮]:{8pPիfiÆ
^o߮gꦛnJ=uW]-iӦ?ږ)Sne˖5kj׮]^ij*SOqp~ٳG6MݻwfffjϞ=$[ծ][wgrr=7tӵuV}ׯ_/I&"w$           K! p-5mTVґ#G4dȐ\/^\:uz)--M,UXn]-ZHZj%IZbBBB԰aCEGGdɒZ~V(ڵK,*0}z뭷,͟?_i0KV۶m|ruرc?*WxI7߬oV&LPfta^Zԯ_?}Gzu뭷\rJMMw}~M?ʕ+'Iԩ6oެѣGsΊڵk~
05..Nk׮W_}M?В%Kt	O~zҥLܹsiӦZ|>SuU˗׎;7ߨm۶*YU$          # p-լYS


U\\\EGGkʕZz"##UV-uM~F8p.\qtjժz+I8pfΜO>DC7p}Q-X@?9s>SEFF;PRR>n%&&TRZfVZ%JE"IjԨuիWk۶mZz)37h@CҥKuV>}ZŊSʕ5` UVӶlٲz5g}r:\yիWγe˖JIIw}+V(::ZW˖-駟\_}EGGkȐ!9s&O0o^;vzW_iҥJKKSٲev]չ\oxkj     ޽EYρ

fj%Fi)hmڷl-+V~+ݭ45vPM7ZR;XJiRa8#Ip^Ç}uo      jar:r8***R~~V$yj2 fǎr8.+ݫbuѽHǏW>}pEDDm۶./Kߪ莾2OPjl6l6W{.o          ϑx z6m̙3Zzu<f-           JZ!  T_~*,,Ԇ
l2/׸qԤI_YϤ             dҠA4h _o&ޚ6           "   ś4           #   śV           pH ԖFpWTT>LԡCEEEנA_7xK-           9o m۶.^8|F)IճgOW[f           @$  x3[           s$  x           
   -$          B-   j            x  B-           ($  x           
   -$          B-   j            x  B-           ($  x           
   -Lzm&           D-  aZdINr=|m۶ܘz뭵ZPo&x           |[  C5l0T:fY,mܸ6K*[f           @$ /u?j"xK-           9o #FP~=>..N/B-VT[           PH ̜9S!!!/+<<+*G-           ($ _ڷo	&w\~4bĈPP9o          @@!  3qDUz<$$D3gμ#           o ?!!!>}z'L_Ċx           
  4'"<o          @@!  +<<c⣊ O$          B-  +..NO={;55Uiii>D-           ($ {1o^z}]V           pH0x"7ԦM:(?_f-           HV	lC&
n
7 REm
poS.            x 0ws >Wv?            o 0nu:nPwkfL&ffsu            x lt:P|m8( Fmӹpƾ    IDATvp);oqF/w8YɸuV3U^*3]wUY~TYw)O>.:sn]gq(szΎ3}x}lҭljQpJIq
èͷ$          B- iCBea$C&Ͻ]|xXe2\:mxnTwUl׹9}]Zl3Ƕ*nWRUv:vETZyj=Ozpnpx*zVη~U[zޯeoWzzK]7׳:ː9$H܅%k'Mwo           PHj-..(ynkJwmUnm4o2vDOirWyD*LgUjU^_v׹rJbu'oعmy{n+u]u*>grYvW~lz+^We}}Wf=ݧh=+z[?S:%W2GoTyFm0p8)#           o p􊋋e8KR{ka*ngI˝تOpyK7A֠X{g:v_{ռ`+Z
7_Q3st2Ir8X,X,~x[o          ϑx ɕxJ5f,?SxCI%9
oM            x lN bR>&            9o py4>p2&ʘd3_x           
 ܍z$~̐I            x _vsxK-           9op}YZ&o_m'           o [&1)o          @@! 	o?fcR$          B- $~_[I           [ 'H̓x           
 POx1>&E-           ($@=A-}L[           PHz[k<            x 2俏Ix           
 POx-L~            x 31)o          @@! 	o-$          B- u0֨Cmk<            x D-%>8p`_xb^0+۷z%Kxe^odͷk.M4IٳRSS/~3n9o߮cV9&33SIII=zWjoϪ#77WIII&}LʛV           pHz%޾ٳWڹsϟS.]2o]SUrr?*33SV̙3uWz~jռyrcbb\U>-of-           Hzo'NHF+Ծ͛7^ӠAb
>\w}&M_&չsg?ԍ#           oH<uW/VZi۷$W^:s>}Zr.m߾]3g_|!ժ=zSӦM%InVM4Isѱcǔ͛7K*IXђ%Kt͙3GVҡCN:)==];vt׻yf͞=[wVhhw1c(::ZTPPٳgkŊUll~)55p1Z~N
&10-YD80xzV5qD[$M6==]vүK.}lɒ%;w:.LnF[jܹڵkΜ9h
<X,}QeggK?Y>Te9s~aeddjjΜ9[oiϞ=2CIIIz/$ywڴizoj߾}԰a4rHLJg?f̘O>D+ZCO233uVYVWcǎXߚ;w8֭[QC7o^	           x ELOvZ⋚?4a/󟊎M7ݤ*<<\[n<"M2E'N޽{u})//cW^yECըQ#h	W_}Uf͒$=ZpM>]?8	&XRI>`M2EƍӶm#t0=7o4m4S/ϟ_;=Z7n#<g}V,Y1.##C?v^zIwy.]ѣGҹ?Su]5pLrr&Lt{͚5Kwq{9Y,M8Q?$i޽=z^L:U]wΝ{ĉ۷ZhGI=>|c̩S4g=1bZj5kjܸqڷowtiK*--MfҪU$U>;vmٲE>?+,,L<vQ۔)SԳgO͟?_&Mʕ+5czꩧԶm[߿&NX=P&1)o          @@! ꉋx+IzW܍cƌի~zUVZ
w'N>]z7*IڵRSS5|w}{׽}IR-?~\<
Qן'Ojٲz-*##Ýɓ'k߾}:|6nܨqiᒤݻtj̙JMMU
]}71cw.IѣGJO?yKzGUVVVr:њ8͘1}[j;S[nUllvޭK


r׳~zmݺUj֬䞧*ƍ+/66V~G]GVrr{_FFڷo6w]iii={&O,Ir:zIʣFŋf
0ٻﾫ\Tv$I={]wݥ3f%)%%E#FpkڵFٳg몫Ҕ)S$$9^;ｩ9of-           Hz"&޶h#m5**Jt̙
ǟ>}Zvm&*!ITBB6nx{WVy[Ǐ+''Gڵk%IEEE*..֎;twn%)))Iv]It$I7pϟ;w[nοm6n%)44T}ц
$I۷oԠA<^۫W/EDDh˖-6Z%N{PVLLG'NHҔ&á+''G{ՙ3g*M=tjc_Eʥ377WИ1cMt饗GڲeKuϯO?T_~ڴi㱦{7uرҹ?^cƌo1)o          @@! ꉋxjY_$-X@,(wEM49o
6mRFF+/h>yN)"Ǐ$tM?|pO8r=H%͜e]z:ydsGFF*88X?Cuȑ#M
6Z@,Y3g(::Z;wju]sWz=]ޗr㪪:tGStiǎs]5β0M            x ELpIҭ*VxPP8{L]vռyԦMYV-]T7n$5jHfYGxaZf:upYV͙3Gfy6\r%5JRƍ%IGQf</ԩSs[,uM~N>]V*I}W믫GS/e˖iĉݻI]o+JKYGץ^'|QQQ;\'NF媙1)o&ޖ.           Hz"&Vbq7(}ڳg:t蠎;cǎj׮̙uh/R{Ԯ];Y%9~ݠ uIk׮HݱcƎoVIIIr8:~;z7tԩ
ת@Wvs8Z~{K.2Z|kuI]s5^~;8qB/Ǳ͙3Gw$mݺU;wVJJ~=Ifs-5e]+VxѣڴivZJ$)))I}6m걦+v飏>{᷏Ix           
 POԱp}gZ`GyDcƌѰadX`}g1bDСfyweVV.]*Iϗ$JOOc=aÆ)//O3gT.]$٬kF<^kN~f͚N:e˖O>ҥ{9=Z111Z`=njmݦytGڿfϞ:h^5\Osї_~*22R~233eZ+T[N:iժU+o>͚5KaTnԻﾫ^z)>>種t7^o-ŢFs}u]Z|~W&M=sgx	
:T;Së2_sL            POԱۑ#G_TFF:wݻ7ٳ5i$YVkNuV/jzոqc%$$֨Qm6uIݻw믿zK'NTƍէO=Cӌ͚5K#G(::ZrFUf2224}tUAA#Fx$>j޼-Z***Jz\5>JHHЂh"8qB͚55rH5k֬Flر2C*,,T˖-5|p>|XK.j-ܢkƌZxۯ_?M6MsSO=P%%%iԩ\egW^yiƌzTPPXM0AzkѣM3gjjѢ&OG}FT!}Lʛ&6           2CNSCEEE
uIԪY  ua"(??_C_0i^F{τL Ք?}NyCFEA


UPP,L&Lu$ɺ"c7*SG)44T!!!Z25JU           s$@=QoԄAh           u@I+r  Q_1T_[M^=[           s$@=A-e[           PHz[1)o          @@! 	o?fcR$          B- $~_[I           [ 'H!}L[           PHz[odǤH           [ 'H᷏Ix           
 POx5m'           o k2O-           ($@=A-L~            x 31)o          @@! 	o-$          B- $~ː>&E-           ($@=A-L2cR$          B- $~ǤH           [ 'H̓x           
 L&ӹ7ode?kfk3           \ o pL&QC?-,	5(@IgǙJv{0V*<ו9!(-e}]U`2N`T:J:{׆qzV8u]`}By*}_d=xK>;vwtOͷL            L&foZyL!ֹqUnZ(s!*V^Wvd.Ukor7i,窯vU}oX\|z*"yeh=WξtufYfxkL            [ ,Sn]MfG#!V&ӹ8ɝnC,}v\fYn]K=:]:!T:8߶Q:ݗ=wqܶykuQG"Tsd2Uy]Wg+:Mƻ?$zX2Y˼<֫=ZW~=属U_?UWeۮ+Wfj=K}Y,FRMu[           P\} jX,z1N*TQQr:Ke~$Ts@7oֆO>ц
tqI={OފRãٶ멬
ǔ5xlSVQk.j竧Z[qk\e-z
I/9.3OZ,Z

l㭫7JM            JZV5Tn,U\lu7ԑ#Gb
\R*((8~%oM7ݤ}aÆ޺$^q5Z,Y,jbMӭD-           0$@`*ݴ6*..v7VvZ|/_m۶;޺uk77߬뮻Nf٫ׂ̙3


u{@jumo          @@! da=>W鶲[á+++KYYYڿZ
<XCQk{nfiݻߤ#׽-|jO-           ($@r5\M5ݞ8qB˗/ג%Kb
CCCտ%''+%%E"PgmV'O?P\\F#FSN./ n-_x           
 J7p%y4?Tff֮]+1G&M4dl6tMjР)uRtt6mÇK*y/_uYwqNS쾺[           PHVatj˖-ڹsg:tfSjjw7}8:tn-mΝ0a&N;-ܢFߏ$          B- B}GԡC<[,]l6lZnJ.*+Wjʕz衇4tP;VW_}Eu
            x ѣ׿%ݮ>HN8*55U)))Q7_~yǞ:uJEEE4s$          B- ={nnkÆ
r:[h
Qg-~[           PH t:nˍꪫddtJ46o\bH           [ NҲedە#GxZӧRSS5tPR5޶m۶&p_$          B- m҇~(ݮ?*,,8A)55UCQƍ}T)ꃸ8Y,Wx<''Gـ+    IDAT;wTΝ/reH             Ԫm۶nnk֭+%%E6M7p|P%#ŢX߿c_|DkȐ!ھ}|X)           J2ȼ' 5WTTUVn+33S?qɤkV6M64QT||y:x$i޼y:trrr5kl6T&/I-           V	` @;vLZb<7h@fSjj4iJOZfw
6驧GeggkرzW}X)Ëgx           |[ xNOT\\q<&&Fɲl0`4hJ_rǦLM6iժUztui>u            x tjꫯʍܹl6RRRԭ[7L<瞫dҢEԵkW۷Ow}:u꤄W o          @@! ԩSZl233tR9rxPPnl6)..G#""BYYYJJJR^^۷+**ץH           [ :tH/nB㑑<xRRR4dRh߾,X+''GZz,KEF-           ($ٲev233m۶r۶ml6ݛC;7|yM2E;v^{5_[           PH),,ԪUͶ?q٬ݻff+Q@1ydmذAVҴiԽ{w
>e""           orGu7ڮXBN8ިQ#
8lJd2iѢEڵۧ[ڵSbbKEB-           ($={nnkÆ
r:[ll6_>RRR4dڵFz[           PHP9N[NˍILLtvU}Z`C)55UWbuie$          B-(//O˖-nWVV=q<$$DfSZZ7oJq7kҤIz\.[           PHP_Zx233zjz֐!CdF5Q@zyf-[LӧOWϞ=5|p_ZD-           ($d7onn׎;Сl6RRRԳgOfT	&I,W_}Vv픘PKH           [ P}233zX,իRRR4l0nGWXX<
2DvRTTKC-            o0mݺexi̔nG}SNyoܸ
(""%Ύ;p86ի_w6EFFM6./x           
 ї_~nݸqNVZ)%%E6M}UPP*[           PHn:vv}M&ddtUWR @i$          B-*//OYYYұc<7h@fSZZ4iJ !           o%?>vYFEEEǛ5kdl6tMjР* T            xÐdɓxb}$$$ff[n2 A-           ($ʕ+WLLOjXnrss5tPK:s$)((H}fСC 7k,m۶1oH>|X&Mȑ#խ[7YFԩSVTGqqx
޽oZ5alٲZsx           
 |%++K:u$EDDhذaJIIոqcW2JMMb<!!!ر"""}ya[ԠA99]r%jذa#           o999


u !((H版И1cj5Vd["           oHRvv.\#G_:p[T91~x]wu:rv%Ţvm?
?k,9rDO?{Ǐk~^z)==]Zn֭[
6ԎGjjٲƎ+$á^zIyyy_<yR&Mȑ#խ[7k٣,jڴnfÇ{Mnn/^ݻwXZҰa/I*((PVVnݪ#G(((H:t{$}Zd8 0Ծ}{y"o&ޚ6           "KAAϟd=se۵uVq?Oz'uAM6Mz$=2iaͭ_^^$)**JÇ7|kJ{W
4t֭FڹsgcO<?ڿn65Jahڴi_$I֬Y(==]o?%I۷oԩSeXtwk:t^~e<0$          B- өҥ$)%%Eڱc1B&I
6]wݥ_|ܸbAq'N>h]Z߾}uKz۷kŊҲe4h ]qUotM7I4evuܹ؏?XOդIIR֭?Q_"""aÆO>k޼y:z4i>@qqqJOOwuQ&MRffx≚(Hn-           HPe]ݸqcxKHHhڍ Whh
EGG{lqzoUVJNN>=zNLLnw_+..t+I
6Ԕ)Sۮٓ'O_~??\p8믿-;ꫯ:oͨ            xrói*,,ܘ
ӵVbϧqJHHƍ IR3&""B_n|^^.*/(''GVU-Zpd2z7n\G-           ($'Nxl;N
TVY5~ꫯi&iJLLTlll㋋UTT >WclFʥ6lP'O,7޽{&ժ7|SW\qy5o\VU6lЗ_~)e?$>lfk3           \ oU\\޶muWJ*3GpٻwoyfZ@vW6mO***J=>?*_{ljժ6lXnl۶m#Gk̙O~iРAs'ٳGRɃj֬>3N8ݻw+{ o          @!@M=zTӧOW~tQ_R Iꪫ'hܹ֭~G]ܟoذ٣?X;wVpp/.@
iʕդI:~;S.]*V{={ｊoFׯ֯_%''+$$D+WbQ>}TTT$٬+V7mڤ7J


$ICլY믫O>*((PVVfr
n-           HPS_,Ν]JMMTYҥKjڵڱcCW_gzwh"0`l6nf5j
WziӦ駟THڷo^ziٲeꪫ*LZ<x̙cǎe˖JOOWǎ+<%\'|R-o-Iԩq]z饒#Gjɒ%PÆ
պuk7NSN7|֭[+11Q?.]9s(88XڵѣդIkL53           jar:r8***R~~V$yj2\ah֭ǫK.۽XԫW/9sF~fiСj޼WرCeTHO>jr-
jӦW/%RoUtG_RhhBBBdZe6IQ            [ uq㔐 $MsŊz衇ԢE%&&gՖ-[|\%phڲe֯_rP7oi           >W
[=vܩhڴieZ%I۷oɓX=Z˖-SQQPW<Ӛ2eZnݻbxLa
           jar:r8***R~~VHV0uV_QNbbb?7~	-]Tv]˖-ӯq<,,LfSJJ.f@c9_jӦKc7*SG)44T!!!Z2>o           HPW5nX~{=jʕzG/I|jڴz/ڻwo y3[           s%&W UZ߿222w?ה)Sԭ[7L&+;;[O>:tkܸqZnNz3i           >G- Թsg=ڴi~g͞=[jР$髯+>}iӦh":uǕ@[a
     ?{wӽq=K$B"h.T	znis]ի])hiޢ^AJ^[W[̜1GFB$3Nw3     90rp8L|N}J
ST:ĀyBOff>s-YD˖-ӱc<Tǎխ[7u]UV-Uh
T6m￫RJڸq*UT(.
VUV++]MOk*((HW|]7           5V.]ZaJIIђ%KdڵKYYYZrV\!CYf֭u릦Mz{|V4##Cݺuӑ#GycxK           x]N) Y,iFvܩ}魷RLL>޺uƎf͚nСCg);;O>ھ}$iҤID(JB;-           :o\/Oj͚5JMM՜9s?Yʕ$/:u.UXQ>oyyrZp$_~<x'BQ           o\ʗ/?RSS+>>^QQQSN?J*C?~ɁkժU5j$Yf>}'Bq           o\ԥKM<Y7|_|Q-ZbTRRyծ][ȑ#~z\.oP=rTre-]Tŀ[           Wh Orƌ͛7Ú>}^I;j׮"""ԯ_?-ZH^Mڵe'(22cx           
 piUTl28qB-R~TR%I(..Naaa{5}t=z˓O>ھ}$Vtt'Bq           o`ս{w͚5KG5rHկ__O?TVժUղeKKo<9=Ǐ%I{СC<[a6Zb           !%áleffjs;>PI{VPTk޽Zh,Yd9NouMݺuSLL4)P|ԱcG\.5kL6lP``B1@9Yu@)00Pv]VUVk{li           ^G- \Zj驧ڵkuq%&&THH$2egϞɁqr\
ҥK	^
-           (h/ 
*衇҂t	}g:tjԨ!Iߵ`=C
Wǎ5a߿˓#++K]vUZZl6-ZHo/1
L           h;CSLсm6j޼$phڵzꩧTfM5lPߴa@Կm߾]4aoh           ~[ (>M4?ZG;Ｃ[]v^ӭު_/Vff'
fĉ;w$wz'<[           Wh RO?Tiii+<<\t1]jƌ:~'򗔔gyFԬY3͚5x           
 }|G/Գ>uJΞ=˗kРARZjq'r:tHN´tR7o          _ |jUvӞ={onfaڼyƌ[nEjҰaôj*egg{{|\t})--M6M-Rddǂ           oժUK<󌒒tq_<eJۧɓ'K.Tzꥹs*==H(߿n*Iz7վ}{/O_B-           +4@QBW+VW%I?׿*<<\:uĉB(d4iΝ+IݻFkh           ~[ (t]wiԩ_ePӦM%ICk֬ѓO>5kQF_zWX,))IO=$qƚ5k'/           o?4kLcǎ֭[u!%$$;TR$I;w+6mڨjժ0`,Y#::Z4g;(N%ġCtt*,,L˖-S``ǂ           oTZUCʕ+>H}QŊ%IG̙3+[nztwӦM/<t})--MVU-
7h           ~[ oeʔQ=4{l;vL֭O?oYKS*U_~Y;vȳ/
6LK,)߿n*Izվ}{/O_F-           +4j}z7?hzt뭷j0}W=z7nڵkkĈZz<s\ٳG.[BBΝ+IO?
b\           (arp(;;[Z$*t,--M-g)##ϭX֮]F𶔔kNNS7VJJ=|ɦ'e5F@vYVY^s            ?rwA^i/dhh~ܹs/tR-]TsO8;C6mRddUv!uMNSʕӒ%K$Ѯk%߯}Ia6           ^FzV    IDAT͠ 0öv߿6MwqM<YZbesau]JJJRHHȕ |VvvuǏbhVNG.]8pk\K!I           x P򹃶aryܿm~mVu;wT\\.]*<x7n:t 婮o?jn7ç·4           B- lNS2:r<Br	][I/{C#F(^y7Z/{<\(uJLL9URJw}{1<(,Ws}<.==(PFP)YVYV
J4           ?C- |[˥k|,,2$PN!Y|"~,gaH2vG͵~'K<sc_~ab=ϻ޽<`wϹ9s{<Cg󹖹_G:Kr?#_ȹ_ܳ2Ǘz|~ދ\^ϗ2.+3?.y\
zkpcB-[k	           *x %W[%!ә^t\ܫϯ;O՟_~៮7WYُu"9r͑w=p?Eux#vϭ˼矟kzZ/ün~=_s}}y~\|p=.>{>=ΥGq/U맋A0[           Wr4@I:ۜOt`wqKfczw%*{r/sR?|ɸbN<ow2Eq|[=>(,u2hyo!)&՚+ 
-            @I6&,s@g<2^_rtrylڞ             PvЭ/S 
h5䳡[po	            J>w|.e~Wx           
 .f$ c1o->           x 0[&üxh           ~[  h=           x  PM>*o          _  \y           o?z1[x           
   %;!{o          _  qZi           (F40kc1o}T4           B- '_6y!{o          _  qZ}=dO-           +4  <@+            ň[ Opm,o[           Wh a< 0o};dO-           +4  <@i           ~[  J>C4W_3wzjڞ             
;7b%''{lX+<<PYh~W{{;v-[vΝӤIԤIuܹȏ'I/6lpRַ?@U?            SQʖ-N߯KjP͜9Sm۶b4||ӟT,3j޼yjܸqo[           Wh Tҥջw<۫W)Shƍj߾&CIaZ}ʹ4           #o תe˖_U4j(9j4w\eeei֬YZj9Hũw޲X..5c޽[AAA.IҌ3g)55UիWW>}kפIsN9խ[WP6m$Iawէ~#G(,,L111Wpp$Ú6m+o
		Qtt~iUPAsܹsj֬:uh:pMÇVZ5j6lh7wΝ;eզM=䓪\$iŚ8qjԩڳg*T8=裲X,j׮Ξ=jZjBCCua%$$믿ul3nA'Izֵn=:z֬Yr-zgt7j׮]۷$iњ9s,X IO4w\߿_{4x`*UꊮozKׯR\\\.5_4           #o?go޽Hsۆ
TN9Rar޽{cf͚JIIф	t!=쳒rBCQV4n8eeeiҤI6l̙#Ţ~Z[lѣ>FiÆ
z饗^z)##C[^~eYV͙3G#Fիkٚ={ڵkkϞ=8qΞ=^gϞc=`=


ծ]4cYV&''ԩSz뭷СCUbE=ZAAA7nO>$mݺUCQ
>}slٲkzꩧt7k6mj֬Ν;?ԠAԴiS
4H!!!:tr)>>^e˖5l0ܹ%_?:(x)aСCy+44?4sLw}1cΜ9cjԨQZ`nFM:UCш#ԱcGI￯uU#F7߼s	
6L˗ׇ~;vb1o}T4           B- \.3gsNM2EjݺXVV^yEDDHV\;vhС$]v3gz5jh^~ml6IRXX^|EٳGǎSJJ}YS-˥wyGڷo~7lxWf͚sImۦZj$5o\Kӧ%儉4zhխ[WԺukںuu/lyJLLo&MHhرJMMUxx&MpM:UAAAf͚)66VӀkSO)&&F4p@-ZH֭SΝ%ݮլYSRNٳ7oСyM8?:ުU
:^Pnl՘1cW5k>}hܸq:xWիK*Ujժ{ｧN:iر6mڨJ*zgm65mڴ@g駟4eEGG\Xַ?@E-           +4 
ĉ&WqƙRI


5Ce.]MuUs֭[oV=-Zhɒ%e˖I9sM4o<m߾]ӟ̶.](::Z[SO=eoٲ&LGyD111ֽ+%7c5{lIґ#GtAٳG?=ΡJ*fVʗ//IS`{ikǎ,nG
ԨQ#[,UXQy^׺E
Esx
3z);^A^ov^}<۫Vqj?6hcMXX$]SVVVT6mdەbo_m۶)((JRPPڷo7{x           Ph T=ZIZjjz]+V̳OSNԩSr\fP2?'O$u%Ǐ; ͜9S|xbl6uQGVHHz2ehɒ%:u;|ps|T-[VՓnax	TRnOOO$-X@,xdd<k.!K]k6w\xy/bms5;Lr==-Ǐ;qOs&w[           bD- *U@IBѭ\r:qDuǏpZLYVy1C֭SÆ
"ݮ{/OWZ^{9QfϞ
*hȑX,޽wӧO+%%Efs=MjӦMz7էOCժU$JNN.5IR=m_ZJʹօܯcar3F7|s
+]&y*̟Ey            |-׼yseffjݺu?S 5lPIII~yjѢN<
:tH			:s挒bN:W͚5uaIK	^vYԱcǴuVl6ǛlmݺͩUlYխ[W}իgC:u{/l6f͚믿6RNxyŊTDDU^ױ(q݁m5[d۵w^Tr4aٳnٲvZs2[            x (;wܹsSZW_|AUZU4h =z'ӧOwQ&MԢEYV5o\=:uִi԰aCUVMʕSPPF~|ڸq٣~XԦMM<Y+WV-tIR:uԨQ#-^XSLQ.]D<xPAAA|=x	
6LÇW\\l6,X͛7W^Wm޼Y,P׮]կ_?}8p}Q)SF/Ν;ꫯ^}[a8l2[<fΜlmVzw
x۷W&M4vX=㊈ЂVhmn@/V`           h ݮS*!!AsQzzW~Z={4EGGkɚ>}Frʩ}:toiӦi:qhr			JHHo3g(**J=^IR߾}eZ'hܹ


Rtt
&ݮX>|XK.UR%mVzͶګSjƌ3fvԩɓ'UVWG}T?oqƪ_}M2ENիɓ'M6W=Tױq˔)GyD?KVJ`}
		Q-4dUXZz5i$߮^ziʕWzڗ^O#w3           @1C.KCw|,έ*6o	 B;wNgϞռ54lz$CKU.W Fʹs,@vYVYVo(I@9Yuk7           \h <kc[?           ˉBv`   ܁V_f0-           :o  Jw[           bD- '_6ַ?@E-           +40kc           o  JwC4           B-  @x           Ph a< bh           ~[ OpmַC4           B-  @zȞ[           Wh  (y܁Vo            |=X[            x x avȞ[           Wh  (y܁V_x           
   %;J-           @1  \y           o?z1[x           
   %;jZ|3l_`{	           *x b9š"pW~#ϭu.u6y_
JxK           x PݺxwO?n"CÐEZ:߸rg1.<yǐŐ~r*ws[
{+Os_=9
r.:\w0d\:*+67{es\<)ʻjx}ps7QZZxk-=           \%odZsxRNˤaX,2$K0r
Y,'[,2?a(}Y.N1·o<Ͽ0G-z|8Тϗ|r
|yϡ0ogfּ׻c><_|pwy|.R\s{9ry<^}|OEx\?.>|-`Eߏyo}
           L jfU=trpaN/##C{={gxܭV(ծ][͚6Ur<n;"#Ԙ-u~wձGqFmݺcm`lBo=בs=;d1r}9ȼV#}rgq^f.z\^u/k1.y":S_Xob5dZeddo%fo}Ma6           ^wql P.m6nJ\.ЩS
6hƍfqj۶ڴi-Z(00gts駟*11Q۶mxEӧ.xiBx[lv>닭4           B- \;gΝSJJr\yѰaCkNڵS۶mULb=K9r}}JMM5.]Zqqq0`ׯ	9vxk[o          _ J>"á7jZf6oެ<kofoB
^ҒjAZjiӧʕ+	OCs(..N˗H-wl=wok|           x %Ԗ-[zj}Z~233󬋊R;*""^ޙ3gӧ3[,yzեK
^ou=5jw﮾}*&&.n54           B- ahZzV^$YuI;vT͚5D>}^BOCQTT'Dn5kԁtY͛7OSTT~ת^rk[o          _ |?`m׮]ǏYfm;uzya҂s:ZdL5kx<ִiS/4!.%륗^K/N:_~Sҥ0n4           B- jժUf_ͳ&$$DvmҤrKMMՌ34m4/RJT||8!HժU/}^zjժU1M_E-           +4?~\_|X	

R۶m͠mVdټ0IIIQBB,XsΙkԨAiРA
(o@5}t*h           ~[ (>'Oڵk͠Ν;	P˖-͠m۶mFAd    IDATiٳg[			ڲec:uСC[ĐUVUVաCp4           B- 3g/4۶mXcZդI3h۾}{)SK_+!!A3gTZZ=$$D}O<uzqB\ƍx4           B- ,mܸnڴIy5l(440g)!!A~G~:ty&	ގ1B&L(iPRx           
 pN6olmׯ_gYw7AN:r^p9sN~nCSN^zr8>޺ukBȃ[           Wh3C~MJJҩSVܹWiƮ]4qD}0W\Y=H/NbUZ5߿c{Jtq}W6l&M	h           ~[ ڮ]V'Nȳ&<<\;v4öu¤E';;[XttTR^ťf͚ۮ]jҥڵ/_ɓ'}ѣ/           oӁj*3l{<kʕ+:Aƍb񿟥G;Ｃ3fȑ#ҥKW^6l4i	Q"""$I6M>o<5iD?~a5iD7tƄ           o\9blW^{Y[o6o\6$M2E-W֪UKCр	-XRSS=-[V˖-S͕nݺ믿Vpp&           o\oҴvZ3h{<kJ*֭[Ah*UL͞=[			ھ}b;T||lEuY'Nz)11Q<vޭ~X}Q1O_C-           +4wOֺuzjYF|fSf̠mvQ			nn

U~ڵk{qB]^81B'NM:UC)h           ~[ ٳZ~h_pxX,jԨСʗ/雷Ҳe˔A[nECC=ҥK{qJToRRR#Fuj޼ǂx           
 J:ánܸQYYYy|foWŊ0ww;ＣhСj׮'?lOԸqc;vLڱcBCC=[           WhPҸ\.m۶&''yըQvY^7|78qϟgϚ###5h 
<X+W7+W'|v_UϞ=rJY,q           o;w4֭ogMʕձcG3l{M7yaRߑ+!!A6mxC:t~DP45~x1Bƍ1cx{,3o          _/͠5kt<kBCCաC3hۨQ#/L{~M:URSSeʔQ>}OA^דÇ+))I.?vmX(F4           B- _p!}fy֔)SFڵ3͚5j´l29Ns{ݺu5dO!!!^׫DڵK}zoVժUX(&4           B- o8q]z~<kmm[n /LN:_SNonZڵեK/NHZl4i'N(66V)))ۉQ^h           ~[ ԩSZvݾ}gfS-̠ުҥK{ib߶k.M<Ysӧ0`5jxqBӍ7ިߺe9RǏX(4           B-d3he9N5Eӟ̠mLLʖ-륉}ŋ5e[㱖-[*>>^={T``&.k׮5j^y[ӭPh           ~[ !;;[)))f6%%EΝ˳^zԩ:vN:),,Ӗ,ǎ5}t@Sjٲ'
_Ԓ%KsNO;vPR=           xj8Nmݺ&''+###Ϻ5k~""".ߴ4%ɓ'u=zT9r$tҪQW I?7tVkpi:tK7naUN";VaU}           oaڱc]n󬋈0:uRZ8:uTa]l6ժUٳ:{%ol*6mژ_yI
x           
 .4k֬	SLL_& *o          __aۃYSlYor-Z^ Px           
fv駟	

R۶m͠mVdټ0- $           oGzz֮]kmwؑgnWV̠m۶mix!!o          __/֭͠[r<XV5iڶo^eʔ9V^rʩq޽J.d%&&^Shh?vƌG}TZ*1RSS5yd9rDVU^xAv;3꥗^ʳfL2]wﮪUzaꦛnRͽ=ߢ           o7AM6);;;Ϻ
Aێ;(<
=zPvZ8qB^B
jР
>00P
48?RL
<X:w$)<<-ݭުz</R{ы/JOOիUV-oh           ~[r:ڼyݰa233]Ure/L{7nm:tjW_}+

aÆ^_|y
>Qtfʷ922Rھ}{q}           ogb
9s&UVUN.](**SI28qB/Ν;u9EEEM7d9u>#m߾]ae˖
ڵkkIM'NhN<#GO>j׮^{M:}>#ڵK
mݦΝ;K;1cG5Zhv-ө(ũf͚,YDw֩S
y?jٲe:pPݺuս{wUZh.>p}h(pB۷ONS5jнkgΜ3gn땕5kGdeeiŊڲeTbEbۧW^y<+Cuȑ#2C+W]wE*x           
@ɰg{={~Wc֭[KSӧOɓ$Ţ޽[֭M7ݤ
*H	Ծ뒤x@!!!JJJ҄	Ovr:0aN>޽{lٲZb6mڤks֬Y:vz쩐}裏TLi&SNW_UPP]r&NѣG\rz7=zlٲyxSe_RhKmi)edSF" PdTtKftupqyeeYDeYD}-%y(
Ii4i\W 9's9tHK,d%I;wԬY|PZ|O'h\P._Ç>Shh5k&ɽ033S?T^==2ZzyM2V_~ѥK4~xkz4i$ըQCEo?{Wj/>LgϞN:3fz-$[N֭飌]V}4hPjA[           PPx	5k~X;w%73fw_ʕժU+
0vիg}VՓ$5o\>soΝ;uQ=䓊$5nX=\ܷo:u֭[KnjժN_n.^+::Z԰aCڷo֭0
<V366VGѾ}l,\Pѣm>ccc]_~h"-Z>٬F)!!AaaaO84uY7x$^zZ|,CÇWTT$iڽ{VZA~vkѢzjuY/^,@n~	uA}SNM<YS||ǷqyG[           PPo'NzhhG}BСCl}wڱcN:9,믿N:]CM7ݤ˗+++KWʕmIoY;v(QM6՚5kti5o\͛7W^\.o>իWϖ'I!!!:u	$IgϞՙ3gt1;v̶~))):ygKrcccw+>>^7xoUVnU4Hw:u(,,L׿ԺukƪYfTn][ҭ$A{*(((mVW޽{u뭷W^<$)++K'OԩSlگG[           PPOz5w\I9UT׬YkǑ&MVZ-[?ּynͶ\zzΞ=*.\pZ6""q1BVҶm۴sNI9lJOOwH*tfڵZbRRRTJկ__mHU`Svm[-Z(::Z|fj[Ν022Rƍʕ+O?iӦM2jժIRj=?44T$]pݟ322V_y>}ZIIIej֬i<-           (Wx3gڒn۵k˗+<<Qg͛7O]w"##%T
>ZjZRSSeZe6m&2L2$XիW/KgϞO?%Khz-|ٳGUVÇ]cǎʸI%k'99i1	ӟl-ZUug?5kjС2CGѶm۴j*UVVmٸ>-644ؗejj̙֓O>F)00PgϞ֭[p'+ޚ_           x,M>]Tzu\'JR*U4p@effjz?~\իWW
l;vh
Pf͔~<bP+88XΝsI={)--MO?6n(IR||Zn3g8}N&Mta={v_FF}}ڷofzmKX,ڷoV111ںuCpjjvޭ뮻	WBB,I퇻vҘ1ct	L&իWO}QZ#GĉΝӾ}ԬY3[_.]ʷ~wdrLMMMɓ'նm[5mT_U%=T           
o㒤iӦ9*..Nڱc~ƪ[nںu^uu]ڵk֮]={l6yjڴ̙ըQC_Μ9|M7oG}[oUGՆ
TtjժkѢEdXTV-?~\[lQ6m>'>>^7oo{WAAAZfԱcG޽[6m[nEiiiZjN>mK>}h֬Y9s:vK.iٲe2ͺ{<;{h"-[L{vk?lܸSݻwWժU?رcڵC3gT^d2tRږ[W_?ֽޫZjiZvEEEJ*"IڲeЭުիS
TjUٳGK.$]trɊ'O            
`VV,֢-d4_"㽀?R~X͞=;_U,--Mv?xOkР6nܨC
		QVtqmذA~222ԳgO[d7߬4_^?7nڵkٳ뮻$IjR@@vܩ-[z衇+66V~Iwuu7*--M|6nܨG}ׯt[N7|֭`Z|nݪZjiĈQzdZwiڿ7nxm߾]-[Txxj׮
_~믿AzZjl؎
6EjРAe4h۷k׮]jݺ
+WXڴil٢[ӟ$I;vaŋsN5lP>W.I2jݺӵyfmٲE/^T=ԳgOL&\,o߮{ꮻ_hݺuڶm.^ԩSxp./e8/M
dv*UJ*l6d2=dPw           ܤ[Ţ˗/+##C+fϯI΋Ե1$goUv$I_:vJѣG~bh׮]zWK\/_O?-[_~l ٳ:xO={9'y
ueJrܯ˃G [mQ@O           rjQ;S-鶢X,?~o߮͛7: 
Ã35           |.'=rokԨHm>ԨQ#m W<9[           sTKnmtt#⳾x

#F:x'+ޚ=           @1Q/ǎ$EDD8  JΓoI           >G[X,_  P           +T  xm%           PLTOUjU_Ҏ;]4{l8"|ʨ05iahҤIԶm[=sGOV%           o@Nl|6m$IT}y+W}ymڴIV/Axc-           o ?Y$ԩS>%Ɋ$           -  G$ޖT           
o ?MMMMUVVAqQ           +T  (7VmYF[           PP  (s0o          @B[  LOV#AIP           +T  P           +T  P           +T  P           +T  P           +T  P           +T  P           +T  ˶AAA>%A[           PP  'Oڮ׬YӇ$x           *  t	IdRddAqQ      [/    IDAT     +T  (mڵe2Y-           (Wx  Qnm͚5}	J           \-  G111>%A[           PP WzudF$ޖT           
ob2f3EaÆ] @@m@[           PP/G$թSǑ(URE7$lѠ$x           *_~$]wu>6I <o2O){AIP           +Tǉ't%IR&M|
\iР$iٲe@ tRI-ܢpGdJk	    2ل$      ɔ2<7o:o׽ޫ/BЗ_~^z:$\1C_~${>%Ɋ$    *Z0     Dۼ	N-Ο?)SHԬY3GW|A=s:ux
o"I֭AIQ    MXVc      a2.fY&Iax4<yRSS%IfZk\``Ǝ믿Ν;밀rcҥPoѠx    @	MΖjj-     nffhxΙ3gO$o߾|
kԩJKKӀ~zթSa²e$I]v}BE[     J>2ߍ2$VL9sdO=&Vrɹda.~q##}[GjG7l7֫m>buXtue\jk>F7b/tiߝmZޝ/No푧B[Sy__۾/W@[_v9n./h{\n_P;qzj\)Pu5<ǯWprg?(q8a|sܲ3g㴐vJr\)qrg|bj?(|{~*鬝<qa?(I{v>pu l{y^yc?pRZ<T`NǗk;nwc{aӾy}|ȿm~|9_^"qyNݕc].~V+y/x<㊇߿t\)Yۿrd!CfIA]b" ʱS0
𖴴4%''JNNցgݻWk֬U0`>CGwTVMo>kN7nT}PڵK۷o$ux    @1c[Ţߏ[ܳ^WOHNPWN vN]WOٟr<|c{'t幹qrNݶ?ga1:g$<ǑwH\w\=Y<[kj׿"O~8iYyA
ȿ{s<Iףh3ex[!<Gv\o7;J(bN	WunIƕV?ne}쎛&\OO!1UPU>}㹋qUvz1Yz:8$g\jW\篃WΞθs)8-Ҹr>.~*3qɷ|ǭ+"wwQ?9Cʊ9{@_+g,l{a\m?)rw}\a}u67_]
ۿX#o{W^<.[[b\vۏ+ru*r!ClL&S .^8Y,		?1УG}߿kNׯu]Ѐ2멧$+!!x    @	leggjI.
5؟9wYEֲ	'UqYvj;t3҄
Co
_wu#''_.0
\7ƆgㅮcQ)AE_g:[$B'߸(B`I^m1co<]?OIƹs/f=>%ߖ\ǽڍrڍ<~[q^fB>ٚqs߮~2΋>ejuoEv8E\BƹRظ=_ IV*?n$O$+33؉ɺ|G1L馛ԹsguY:uRj<JG޽駟ױcԪU+=7njԨ2eӦMZj$i
qD?gx    pO]M5vY      }gKX,
V@@fGIȟHZw.;vPrrN:Tի+<<7߬(ǅѻwo͙3G
҅4}t͜9S_O^z(׿JbbblQQ    2CVv@a     r)@n\Jn[OA[L<镸mIhz%.<ZlSj믿7xC۷WBBTfM_
+Vh۶m{N>B[     JmN}     ?MSV>{Rq6ɓ^)&&i2lrrˊkժ啸Pj޼yz饗4uT͙3G/_͛yf3F;vտEFF:do<ӒkF#Gq4$*    !ax6  @q!=
 &aox[[JŹS~aÆ={f̘O?TIIIeZ~z_^FRΝ5p@Oaaa7|Sv$M:U+WqD$*    ,y ʩm۶M6f*66VO>xEW9rD<>rQݪA:t7nܨoqb>cZb<X* KTD,PDFFjȑ9rN:$%%%obѪUj*=cڵԧO:t|7n$nСC}<     x  ]BBڶm+)'Y"==],РAdZ5x`GXYF+VuմiS?بQR<nW  |͐kRt8TL5kѣ5zh;vLWRRnݪ,-YDK,Qppz衄Ջ}ڹst});;[AAAJLLluX0*    S w]t?pߘ1cԸqc$#Z3a   +tX*
 JN:;vƎ?CsURR~GeffjZpBCCճgO%$$G
uXVGN$͙3Gqqq>
Ɋe      @VZ5iF$2L裏԰aCUZUs̑$m޼Y]tQdd"""ԧOٳǡ/jܸq_BBBԲeK͟?a>H-ZPPP֭ҥK
Д)SԤI^z=zm|駺(W{ugjݺBCCUJlRͳ=K5jкuԲeKI&?~GuI!!!jԨ>>+**J!!!رe9rUJuE?$^C=$I]Fe[jժBCCUN=Zn9/ɤG


U5l08loOWjɓաC$:tHCQݺuUJo>_nW7d[3fPÆ
-Z?w:tTzu?^^V  T$mffN<={ʕ+>@&L\<nkN͚5SڵUJUREjRӦMնm[u]c=gyFӦMӬY+Voկ'N8M
.v{ǵ{nmٲE˗/W^5rH%$$[nt
7(&&[ԯ__&LΝ;~M2E͚5$]pAӧjٲeX,>(ɓ'kÆ
zJqD*    
T T@ڳg6lpO>	&rرGݺuG}4M:Uڵ֭[ոqc={ɓjРA
T~+hĉ6l^{5ٳG>ۧJf̘ӧkƌj޼~g=SxfϞ-[h3f^u9sF'NT=o>L&5jƏW^yEz뭷4tPzjҤ$)%%E<}]{z'4l0խ[WӦMS-4m41B~5jӧO]vr<5k,uY6lЭjێ/
Z6lOÇ˗5qDmܸQ]w$iܸqz74zhڽ{LoV7o.reGyDSN̙3sNVhh}]?::ZӧO׀4tP5lPT6mW^yEaaa?=zhK]{b
;wNS5a
0@T:udXtwɓzW7xCj׮]m  TP^5nX&MҤIk.%%%)))IWjj>}'T>}4p@+  סEfM:UW_}<Y[     0U* 
ٳl=zT~7͜9akĉ]vU\\.]*ӕ7ͮ]I&2e>_^k׮՜9s4dIҝwީC髯RΝ/_~%IݺuSzԷo_mܸQ:tІ
/N:jժ*7odҤI.I[.]tUVMw֣>iӦoTӦMqF[bѫK׿Uk֬ш#4` Iҋ/O>D5j_]Ǐ?-[JniF&LW_}eiӦ5kSO=GyD7nlKlҤbbbta[3fx
[7p^?Ë?C=z-_|w}+mذ!_"$q!fg϶9r.^~ɶ]>mVcǎuH-v=[cO.T5$$Z|FڵkVZe7ݻwWF  (kymiW%q 
עEhBSNەСC:wfϞٳgf͚ׯ: o_~2CM4.ET    N=  g3<p_JŖ[n]?~ݫ3f88Qnݴ~zI,_߾}Zd$iҥ~{
ԪUԡCym۪O>ڵjSN8
0@ݺu߮|w$I/^Ծ}~}ג,)IZI
$%''K+5o\͛7wX={_Vff-u}HNg6mڤl
4{GQQQZ~}aŐۿ7kժ&MThqqqՐ֯_x&ICѣu[rkQ7|ؓ
ؒnqFڒn%J*իV\j  PFTQ+ޒ8 [n-ܢӧk˖-JJJҧ~cǎԩSzN:߿lÇ+>>^Z.]jAE[     <? TO<t"I2͊P-Tz|֩SvܹsZj[VZ3gΨjժ
		q3g$Tuѣ1c(,,L}}Y=3k5}t
0@mڴњ5kowQF_dѣGkŊ%	8^j|p<xP+WvST~}&[Vuw[rF5kT޽]~*Iu;iܹs׆}0  pOffN:GJ)2,)rU
iI i׮ڵk7|S6lPRRԩS:v~mۺk5` %$$8++OVNtajҥ}Jo    $#  Sqqqn%DJrl[ĉ;v옭:hDDӕ*UؖٵkΟ?IٳuM7k+**#4bhժUz5x`uAkwܡ;CYYYڴi{=KS߾}ս{w]|YVR۶mÇknn-"""tm٪[!85\رct뭷m^ޟt9$9T-*wǞ;jԨ'O?7 $33SJMM-VYgG?gL&uI:u̙3n:%&&jѢE:w:3fhƌjҤ-Z:tT@ΝSN+  @-Rǎ}J	o    o pvں땘c&O:իW$uAh"
4x/^@޽[Ç=~=C7n6lΝ;k'|p_&IѣG+))IչsgtMĉڻw&OΝ;Yf$UQٳgnݺUN'N]su IW~
мyԺukr˖-թSŞWiWN:iܹ:~msaÆ*Ȼ]۷osǝwީ3gjź$I/_ֲe܎  V_~T,J[i2+F"I(  @]tQ.]4k,ZJZxRSS~Kz饗ԬY3
8PVƍ}:*tk2L;wzPx    P  צM~{ѣ>.hԩ
s='I뮻ԩS'=:uꔚ5kEiڵZd3hԩtn={V/ԦMIR3ϨnݺܹΜ9)SnP\\/?,IzwOkVz4giFꫯ4uTI҅J-ƍy)>>%KCSLlvJ/x5JoVu={hɺ5pŞWzJL0A}=s
Ӈ~[*))Hm9ۮ=wS:tЃ>S~zwtIEGG)N  J٢T-TSq6<<\VBCCh5d
yumL@	
 TTI=zP=e˖)))I_~.\ݻw?-[*!!A.]x.O>@			>
       RէO-YD/x(>>^/U1LZd}YJIIQll/^l 2eթSG>EDD(>>^SNULLV٬ٳg뭷RHHvӧRJj߾>sK4hպuk^Z]w$i3ff͚izqF7ۢvڲe&Lc*##C7{ｧHmuEw}ĉכokVf{ｧ
6L/+ݟ+
67|	&hԨQX,曵|ru֭Hm9ۮ=wf-]TO?LLz'5o޼6 Il\%Άfʲ
S%>_hEEE)    IDAT22RpaZX,|222|t%$&00P{V޽/BIIIZl233?ĉզM%$$P:u<դI'33Sw}[I̙3#8*'+ޚY    0CٲX,t2335#>^SYMh:D     P>}ږ {|Iedd؞w	%''ɓ^+&&Ъ.g}{&J.}Upp*W fL%28K]5K~=H&IS *.hѢEJJJҪUe{d2}JHHPBBj֬Y~իoD(C,nYF~	V*{o<_T


RJd6+VT    
7    2j*55elaӽ\ݪ8[\_ PjȐ!2dRSSg)))Ik׮b͛yf3F:uRBBՋV@ȑ#۷o߮zyimoտ[#<BmɊ$    p?	  ʂU̭ުkז  pWZZg>\U+rYP9}0C QXXÇܹsO
6jjݺuZnF;S			ׯ
lwذar*w}ZnKaKah%I			||Lo    
  (CLPPP Pqdfflrr,bʳo #Gjȑ:uꔒ-[bhʕZr{1uUT޽ڮرC<,YRG3rH%%%Iz衹sVxT    <  
  eb)vu%FlD[ @^5kѣ5zh;vLWRRnݪ,-YDK,Qppz衄^5qDM6R0zh}ᇒ.]hѢE
qTT    cg    @EbZZ.x-6g!ע-  uرc5vX;w?*33S.={ȑ#NyWժU+%$$۞y;m/T``-     ^@=    @Y^Tw
8[F:,o _&L	&h޽JLLԜ9s~]pA>_VZR^{M/$馛nիL	T      P!9KV. b'Φbx%.gT _I&iҤI駟~sK۶mSttt)Fo5n8IR&MW_)$$DVǑ
G[     - [ɵ|-DF b;q699Y.]J\$΢,- rnFM:U?stOWVʕK#Lx=ckFk׮UDDDJlT    w  dFL&  j*55؉.\J\$~-Z* |Ѳez͛5zh;^_hᒤ5jhՊگB;
F[     - ?'LVkok'/fsK  ޑ^T| qMi|- \%rj޼-eêU4h -]Tk/J3)9 P     O rOdgg?kъ2ɐL2)YdʙVι\W1KWוoRgמ:^JΞg8;_oW9]5M]$V^'dlW.kηW_j|fIfTy̡ `NMIIJE+gG[ @q-.K#^IyG7\IUCCT-U
h)yI.޶_ȹ; ϕӹs\tuƽK׫mg.c~mӜ
k~ض]OYfuDJ=z9]ٞlױi|1m6rWO*UlfJT    < Bފ%:x¢-&
땉tL*_m2&MrDm?qC&dPsG֜V~egg xIqzh X޶=]-矯iYΰƕ`rUl~0Np (,KgRY- (;kQ!W)RVK'cd7oJp7:wþ-Ec}dC1*܆cc;7\8zFFyz4\v;sO'њ۞^OmG7}zJa77e\Y?uur"OQ     /s
 rOX,eggK2)(Ф;^
⪚T|5rnqmk/_Z8Nm۳NsU7\_됷=^$_獣$aK(u0deH2dVvvgHPXV;qYMn P'Z*sL\ݶppp<y*2=Ρ8SQ1gߡsr|jt݆N6t6w[mܔ9mqo/z{{_\ؕ/KfYV_fD[     z* V-ZTIs
uxM't9ׯ$ت @iHKK+vljjǏY$Kii&  .ǥ I&3aLv*ms}x      °OMW[&I9c5wrb@Qddd;q699J8Q P\sh?@E[Ȁx    70  ~˾zɕ;|TθΓtkF)?"8ydDKJJc?~\:uW⊉)v, Jo a?ot%Q1A9̧R     o  W	bK9oM'32V-쒑ᕸ8~
o %akqbCSéx    0
 e5KWOl!(5Ov{|gK+q֞ʳqqqTP&Fo %&t눊     xo Pp_ʩx貳*[P_HHHjTP5 - s~o    $~y
 *5/vKvvRRR
Mu@BCCN{lj| T )B11]-     ^d !r*2:QYVg%Ц{+UvlKI 0&* JwPWo    " 
Tdݹz-qd2),,DټU^]& |4T x! 8-      s'K9o0CiiiNɺ8kZlVXXۉ'q * < Q     o` ~3
~ɰ}lQhSRR8Nټ Px (1S+@F[      (C8h/T-ܶmZnPD&DlUR%ʺzZj^ P~
o %fT(\-      clM>]=ג7+TITֶ[q6Rzuy

J\  * <?      xu 	RNۢ:po!1gݹjz%.ɤ"%OY @yPx f8-      ({4%_$&&GQzzwB*eTuU֛TZ5e>&  @* J̔
PL}Wx    'y ?&r*޺3:+11A0|EIMMMjlHHHe^  * JwP
D[     . (C?_ro`~WzuQ$q(T	.Rl+W  @y?%  a#*    2s'K9o]Ԅ	o￻(7ۉ+W.rAAA^
  x_i|- s       *6~2
~ɰю;4d޽V5jr)Y6c!!!^   o %fwp0!(*    
 }С&NXZn-I4h9]_~:tFaÆO$m9m4M<YDfljJ?  Q PbF+1bӰat{?ɳsHűrJ=/TN?ϙ,͛7O+WÇe2tת{JHHPʕ%IV>}K/[nnh"=y\T, B(.hb5TrI-+,Koev_Z֭fYievj2w]pO״7d8'9sgСC+ƒ~-     Ep@SȭZriGSɤe˖ӡc?\/\344TJHH(Vu;-  p$  qoUꡇ$eee)%%E?i	jٲY޽Zb:vΝ;Kvء?P6m҇~(IVTT
ɓ'+::HFD[      : PK.^͵uVرCM6uXxb5lP{q>쎷y睺;5}tڷon%88X})  Mq- u\S{[?M8Q'N͛ ?Mpe[˶    @i| >Epʹs{UTTbcc+--X>rH=/ճgOEEE{Պ+$IǏW֭:l755U:tЧ~*)2oѣXEFF*&&F#Gӧ1]tm۶zwe


Ғ%KӒ%K^^7nz表(WsuskҤIz뭷h
2D1fiĉݻԭ[7{xbO.]~)::Z}Պ+tkڴiƘ$9R:uRv4x`<jժ֬YC]vu+F>@YYYycՑl߯M4Iuw+gΜqq\   o ͔"#<W!3gxo^ׯ.\0ȑ#1bn6uQ?^-gjժ>s㾂J,Y~Z۷׭ު^{Mϟ7eff?WnԮ];=:{U=zT#GTllkݺum{~VZyu]{p-tU핔d<}e9\_\[     l J>'N7xC7رc5p@}wz饗ƭ[NV[oӧ+88XÇWrrU֭[	~+WҥK֭[vڥ{N~-[Lcǎu_VZ6lL&hٲe(H޾}թS'l6=oջwo}ᇊoӧ;<yL&&N?\Ǐ׈#b/uO>?sjх:˗k[}]#ӧkzg5j(UTI?~WG͘1CzҴit=($$D_~oV,r}L9:gZ5h ݻWǏW  Wt \7[\&##CGё#GtaٳGRRRԯ_?c̙3o*22RGoJ*W^џ));Ci׮]z5j(l6=:|p}/X@{FAs%o5}t+ZtC{OSLQ^O|Uw
0@			:t~mU\YO?.]ofժUKcƌ7|c<vTjU
6LN׽ZoQ@@:wYfrE{*LzيaAYʎVm	    R@)qJJ&MN:^$mV7x
[Ex=Z7p$gъ+vZ[ݻw׿o:tƱpB5iDuͳJ*zհaCIRddۧ-[8
+"Œg;]t_۷YfE)**J~~~cׯ_8
6L{$)**JYYYԫW/y{{K֭P|<` mݺU!!!%I6:>S5o\F$uA~~~z뭷1_N8oFh=?~&L`֭z-I<xꦛn#<"ISf̘_~Eݻwx^z'#O?ըQt	I ɦ/- u\[+11QwqGy5iĸ}AGO=q_շo_mݺU1cΝ;iӦf͚jh˖-}?^ӠA&WҳgO8VZ矵j*
>\'Nٳ5p@}:sVZQNTM>];jtVU}}]};vT͛[oU.]d:/ZΪN:Z\+Sar(:t    0 No߮˗/K.0mVVUqqq5jETJI]+$SN6.xY_>ƍ/TÆ
M6i̙ڿ6liѭ$VZZd$)++K˖-Slll6l<۱cG]pA;vpnNt$uڵkiӦi޽1S;q~<,~{ׯz1l6uA[n˗W;oooyxx&v>>>:w?p\  ++ :i=z}kիLb|X^|EJMM޽{l2}wdCnݪ
:VTIsQϞ=o߮#FzFq]ar%s<UV5;۶mfs;;]ojժQt+e_[nJJJҡCGjz뭷t뭷j޽zWC9\-)嬜)Sar(:t      PiÇwϞLWڥgeeINvmZhl\.&*OiӦĉT5j$՚p{;wּyk::v쨌۹s>G?>S?^AAAzg_؋zTR%=(qhw)
[SR%9R?Lڰ   J	: ).SbEzC5kxzn:l69!իW>߯:ht=
+qǒ"IwP֙UY~3/_V
ﯮ]k׮+VhdWUnE{*hzqu-     1 3W^yE
4ȳϯP޽͛kj׮CܜϟѣGk۷?֬YSvESN/ŋ[nw+WjդId6(Z5
Oɤ޽{w:4e9R-ZІ
z|ժU$:uaiii/!\%    IDAT+WVժUNcR;V؋I=F   fCkԨ$СCYz)eddO>QxxET\iM6_ח$uQcƌы/[nQPP
WJy'O:?,}ɓy?qvr>|o߮~0ݭުf͚iN׽ZYQqQ\)x7
    @9ŧqaYfZ:x;v8PjJAAAm6u=߱[lbСC{zzlbt-
nݺZx~g222t=r>]p|ꫯJ.`#<L?~@뫛nI˖-s}AUV!˗믿ZL0  ʮxC[ _`<yRѣZn-///I҆
$yڳg=jlz`>{W^xA&IU-[b8K]e]^˖-i&V~,X5jĹnZǏ׷~gǵw^8]j9+IX,f2 o    (L @)¹
8P'OVzzuY}x
ɤX}嗪\:t؛oYsչsg:uJ_}:dLF.]4eyyy):::(""B#G#<Po0a4ib$m۶7nUVZ̙3/TN|I=s9rbcc/B&>.\{LT``֬Yӧsڽew  (|  qgϞu(І
.]VZl5|_7nԤI$I.]$OsСCS+V4;g߁z'k]+CiԩZZx[~a-[L>
$͙3G;wԨQwܡ%KhرZd"##UB%&&jʕX,<xu;nܸQ3gT=4 +;Rx     9 Pi?5sL}\Zj'x,R=zдiԥKyxx;W^:z~G͘1CV^ꫯj
K.8qn|k6Gi	1cN< u]zGu>fΝoV^^^O?-ZС|MM4IK.Upp^z%1B+V$hԩ?~Ǝ˗/VZ>|	)
  ¢- ນ2'O|`T5S?p^M&3Fcƌш#驐/uV=
Д)SGwޑdRӦM5fEEE4WOW3gմiS
>\uWfM#{OjԨƍmm7N3gԒ%K4c*  @1114hPrV4h [裏ƍYj9CVZ׵;w̗+;ޚl6g    (l6233˗/+55U#diR5
h4w "kvZZRSSL:>(-Z$%$$'|H7FW0t2ɦ_
]/'!*  (+Kʫ^M㽎b){ͦ,edd(==].]izpLIVQK  %])iiit8]7BA[J3[?M{>&oooUPOFǙ)c~c5?6     p0 PNLYl~
2DjRRR&M
*""'&  (l* :$8re[
o    i (E;)SFkĉ:uձcG
2ĸ_`(  @YUomŶ' @ \>4e,       ɓW/p[   (,: )@ʎfm	    Ҏy (= D2
  ¢-  ++ȟ+;Rx    p@)B%'&  (o C#:    PRH  *w:t  x    +1 LCd   E[ u3(WL\1_t    l J>(L9  x n<? 劍-     E. (ED  eWqӡ- uHpD[      : P0w  ]N  !o      o\2
%-W   o ͔\-     Ey (= D2
  ¢-  ++o    (p@)B%'&  (o C#WvlK     rL @)	J$xG  ʪxN[ :}V\E%!>+;Rx     9 Pp4H_  PXt DFFnݪk/5C$Q^cx    +r} |$Q"ew  6t 8(..N6mڵk~|*Y	W6䋎     j !  ]6}I,o ڰaGu:nPddZn-[iӦK7U r-     Ei (E;At-  ePqá- ?{q(ݱc233Z
WTTPeee)##CiiiJMMve
2 9*Gt      P.L&.f|Lp   olKIIѺu8N֨QCFm6m0$?d2qOSQB[     : P,={AvF&dr|6_?m$Mfٮ|$o6˖-o\&[}]+c/q.^Y8    PvdeeilXK-[4l\}9|p=bSgsR޿mΖKoys<Sbr9_~1)%<~]u)c!ya6rT=WE[     @97 @eOf٥6-ݒ.eeb.H-JMfdʒtvL۲lW'eǑkX?+6s\n?I9,p6|<<{	qrx^)9A.  (+l*X:@镜5kE6mŋ_Q`-Zj2EWioy<Gc}{1Ew9ZCm&F#"\ɤٿ8?g.ʑ8˵1nX*7e]yۿRp~(vlΩBso    (L @ɓa-ʔ-+KLׄ-Nuȯ]Bfte%Ǻ6lf'BFׂőkX;^xvy6>n.;Z5k*qB?Vy$-YWvUt
Ng߶'೮ͺr|Ͱ]lkLfd1d6d"B-  (S]
otHKKӦMo&&&:֭[ڵbə;X,
nQYef*++KeeyWRe$aw+/aedgJĔ6
9-wǒslY2IWn_qNr&9rc9,WW?^6])Λr?߮c}<8r
||͞ʾv%OiE]ue|V~磽J~l,fLb*H/x    +o >ybZջ]Rzz23/QRW;&vߥ~;Rfwel6f6d!1    Jqqqڶm3
3lVE9oomfUtg)##CYYYܑ\K4;zגgՐ!),')Im9T*OO[
:    Z\ %F%2LX,ʼҹ&ȏ0jbŊntݕjj`r  x w"x%'';hFFF***J>>>oܑ=OdfʂGj_%I7p&Mmۺ92[b.½rx    @ J$f$fѭ,Mjє^oE\  %ٗA.ZteٴsN6..N			F؜<==լY3nsCə;PyYXB<Μ9#IjٲKըQ͑OVVnvuI={TXXCr`#:    PF
 =9l:ݖw4fUPє^9'.*  eMq- ӧOkڵF7ۍ7*%%ڵk;FDDӳ#.oJ(++KoFeː!C4j(Yl6zwU^=KzRVU^~99       ʉK$wY,hJܓ   \'##C[n5ltc}||ԪU+EEE)22R۷W```1G|mzԩSzjIRŊ5ydu]nh޼6m$I:pƎcǪF;ԧOr-X,nxMo    (
; eV}Bc_	
  ¡- \D)>>^qqqڲeRSS3L


uf۴iSP4*
6讻ґ#G$I7t͛
9qN?r&L	&J*FnΝO9G[       (ٜ%$JIA Φ/- Ljj6lѣN+22(m۶|}}9QrG}
I]wݥiӦ͑<Ws)M6MӦMSŊ7,G[     @L@F28   Lq[- 8g";v(3338ժp622R
6tC%Giw\pA? IИ1cSO9 9lRoVE     Rʻ     It )%%E֭S||ӧO;[F
nmڴW1GWٵkz}Ij֬ٳgM6nd

ҍ7ިcǎ]uwީBID[     \ɖ;      o7YYYھ}C7۽{f˛R˖-"ۨ(!joV֥K$I;vٳUJ7GV:4o\-1Cոq)"Dt    +N     $ ʺdY(ݴi.^tlHhBV+^eMZZz)M8Qd2/_lvstGFСCYf1F     u      ++@YM6)>>(MLLt:W[6
m۵k'b-11Q{֭[%I~~~5kbbbYӨQ]xSD(x           :(8`i۶mJOO3l6+,,(RXXL\\Y`>={VԢE͙3GkvsdSWfMOcƌݻճgO-]Tn%o    (
      
o.\p(WrrӱFmddS/w}W6[oG}Tƍ+e6%I
Ν;etӪU4` M>]x    @      s6}I,oD6M;wT||Qh`f͚9tWFI[+W$y{{kҤI߿#+|||ԠAٳG]v%I&IӧOWǎ3fQFz0܂     u      ++@Ipi](ݸqRRR]CmDD]KԺut]w)))I~I7vsdeGF{zzjjӦ߯_]7ֽH.t         p;:(nںuQd~XjJQQQTX4=zFIwܡZ+WvsdeoptREFFرc0`W[n;     W     bG[ E-11QF-[gdRhhC7ۦMl6!jVΝӽޫHV~m
6͑MթSGK,Q۶muSjԨQ1Ew-     Eļ     S6}I,oRjj6l`ѣN+22(m۶|}}9b%;vP^tAIR``̙h7GVkΜ9UJJbbbyfx
ŀ     u      ++سgQ`۷+3338ժpEEEŶ
6tC(~˸^AAAn
v111<yÇsZ~|||o          @B[ ;ڞ>}իlԦMyyys(2224l0}}/F%ȐC=7Ԏ;Իwo-ZHfݡ         3YYYھ}Qd{f˛R˖-
m5ʛ$Wk׮$U\Y_7Gڷof̘KjȐ!o    (&u  匉_~   ( $ $)99Yk֬1:nڴI.\p:~RddԢEYCx[N{Vrr$o߾zp5_}=UViĉ馛4l0w"B[      : ^xK   Sq|d@͛7;tMLLt:W[6:ٶkN1׈#)OOO3FCuwX( j߾vء_|Q7tPx    +1 ((  @IB[;pCm۔glVXXQd0܂ܹsz?Hj֬ٳgM6n%K(""BV~rJEEE;4o    p%[      (vtʖ.񊋋SrrӱRddQhSk.u]$hƌR#õtREFF*%%Eݺuӆ
tM7;4o    (4K  7t  @AT%tJ/ͦn			3S͚5sf[^=7D
ެYҥK29r^{515ҏ?>}Z111ںu\     u  
   (('-Pz>}Zk׮5l7nܨck׮Pd!OOb>zg'HT3f(&&͑n}WׯuM+W5-       Qx  eWFFFE(kڷo~7;vXhIΞ=֭[+**J۷W``Bul:}pӧOkرu^N:嶸[@9;w)Sh̙7|S<[k"???-     Ey @9C-   J:ޖ]/^dR
ԠAm޼,K1Dfx^;>sΜ9hURŭ/M
{.7mTM65nE    IDATUUP[pe[˶    @) 
   (xH[   Wv    +     p8>L[   :    J  ):  $-   
o    p%[    $-P27# ,pe[˶    @)gb^ PPx  Kbx[~:uJ/<<<{!!W։'ԧOw`ZfO]|Ym<~ռysw}nlذA'O[o^A^z)9ᡪUUV֭,$iҥ_wlQl6Kر"""\3g_C=hlϕo)    
u  
   (2oˏ+  @gΜթS'w|̟?_M4qwpLM<Y7oVhhbbb?Cז-[K*Urw%NA_j׮HvFFۧy̙30`@q\|333uy/8qnv       p(  @IBfiݺujѢN<UVQxp͛տuaYVkܹaT׻ 8?X֭ӝw)sX[},Xf͚)$$Mѡ(         |سgN8p]|Y|ݫPcLRRk?Ν;+!!A


ŋu9ժUK<?~A'OTտ©5khʕJJJfSj6mHk^i̱ӧe˖رcT"##uwX>k,
4HsѣGUreuAݺu3> yIڵkΝ;+*,,Ls*W,I<y55w\X,jҤ+i$իzj3F*Uɓ'5gٳG/^TppwﮛoU	J4-[L5St+IM4Q׮]pff{ҥKWժUs+hСZ|ۧ
*}ܹfΜ_~EjӦ+,`ϱL͟?_k׮ƍ9ƽ{j:xHS%Ǯ wWӰaCܹSNY,_/V\i^||Iyxxnݺӧ֭kqF-X@ǏWPPzg/_ւyf:uJUVUcnHLLٳ+33x}mٲe<eo    (&u  o  PP6}I,oˇkתjժ


Uff|}}rJh3gTll,BCC_U.]O<L}裏x@ꫯ4i$[YӧOW׮]էO]tI˗/ה)STn]UVMݺu-ӧÊ$-X@sQ۶mշo_;vLs5dc˗/kUfM~PPP"""te=Z^^^۷*U?C͓d#<blZw޽Un]
4Hiii7oF#Gۻ@qԠAS:qyO>֪U4n8=裊p	;x.]wyg֭[}ݺtΝ	&7ߔTɓշo_w}Zf.\uu;vh֬Y
V۶m>}֬Ynݺnݺڲe;HLLرcu7kРA[j
P}\
zGJ
M*UM6MvR>}TZ5<yR_|?X,ڸq&M6mڨO>?5i$mgddhر:zz衠 %$$h֬Y:yT}
e6d?^~q?eo    (L  
o  PPye:ޖ}/^֭[+$ժ(-[L)))unݺ9ܗ+[nŋS
$IvM3gnPRR:tPXF
kڷoU*UJ*z'Uzu]pA?ZhJ	&h߾}twy撤={j͚5_$Wڵ%Iaaa:tw;{lg5jȑZ|w^8dX IW_}U~~~f͚iԨQ5keЩS$IZO=򴴴4͚5K
,.22(p޽-Z5jAAAZb~7m۶@ϱgjՊUϞ=%I:on;11Q!!!zǌc	ׯ}[x[׻48q¸}9رCqqqjѢQ0u
7رcOΟ?;ou)j޼y_Q.͚5Xg˖-:xb憇bhɒ%ԩ.^sΩSNF`-X@it     S  $mٷae˖JMM]\xb]V~x{\NF$}5>>IETǎǍ⻌<زeΝ>}(<<\tu넅b(!!(u._,ISF!I:yN8#Gȑ#y)񦦦[e6UTI!!!JHH0
o3{UÆ
[)oH͘1CǏw]NERsF$xҥK
Ss
dZel ϱfEv[v(m߾ڷo%%%)99YJKKsaW׻m۶i۶myӰaC?2OOO=u1畔amڴq(ݻw*T|Ғ%Kw^iF4iZj05nXs*TP\n     W @9a6%ew9   ܍eڵk%IzeVR׮]S΃yyy9vܒ5cܹS6MժUsZ+ew:uڴiXK&Nt3g8ܶw)g˵pB={Vު]QSa+VhŊy\tܝ:%CN9v)Y,箽ў(Y=祫?ϕAS땖&???իW5¾ޅn3n{zz*((ȡ7ӧ~$$$h?eZUF
UTIR9mݐ<\qKvu%yzzjذaZho߮5kl6EF7]\:    PL  
o  PP6}I,o˶?Sѣ7nlsNì$kq)33S<ի'OOO<yR7nt{}'QUvUV;D\\f̘.][nQ``$Ξ=[CtPbEIRǎgՊG)))ym/HCQn]UXQ۶mSǎ9s~W{9w
yՔUZX^Hi7}tmذAWӦM^~|-w7pCn(^NÇվ}{Iұc駟A9rW.ժ+!!A_Q/:|!N6۩V ͦCiӦMZx.\6mڸWv5_}     : ޝ%33͑   ++l[v,:uꤛnm&OOO\MIIѱcF^w-/_֧~*ͦ!C[~}Y,%%%nݺƿ+j֬Y:zhcڷofzmfddh߾}Hooo+11Qk6U~'#$5h@{q(2lW@@ 9 ժnM			ZjU[lѶmԺuJ^^<BCCe6n۶-϶BBBmG&''ɓ;\͜9SYYYС$?Pzzbccl|p~feeRJ
֦M·Qhh._xc;*))I&Iӧtԩ";򄎷       F-   J:ޖ]ڰa4i37o7쯅uRJڳg~'I_?нޫ#GСC6*Vz)66VWFF4i.觟~RjjԩSBBBf͙3G:w/^<;Ըq4~xuAfY+VݻթSBmbŊڽ{~gmVڲeƌo]Zf~w=;J]joe5iDfYז-[{+Z9VR%uU.bQhhvܙ0nݺڲe֮]Zjȑ#eٜƙ^׻:V^RR.]*)ٳڱcԳgOծ][Tvmf-ZB||$uGƍӧ~:رcZp>#""l2M:U=zPPPvڥ˗[oUժU-OOOM8QTvܩ#G;,Lse[
o    c^ P'
   
t->.ui۶6lؠիWm۶.۷dҐ!Cw/jU5x`Oڿv]vIf̘g!!!>|iŊZj*V
W^+pLڵɓ'~z7߬viԩFkg}VӔ)SdX~:eﯦ[n߫^zS^|Eӕڵk駟V&M9fl:tV^x-X@
T޽թS'UP+Z9ֻwohŊZ|իkڴiƶ^l6}P@@ӊSfff)ia^sǉkDIٹ1???ժUKw}nfc\PP
y飏>RŊaÆi̘1ڿBBBԤI=4qgã*춏g,"SlZQP Q7VA0@BYUT]H-V}Z_ܰF,ED5
$$Y?&!3s]dΜIgιύ4x`-_ܽ(;V۷o[ob]vezթS'I:3F۷oז-[ti5iDT6m")_6     8Nvl6ӚΡoǨe(]# 0={믿ݻ70{   H<.CRϫ5W^zQTT,vA)!ͦ2O~֠EVrju jf iժU "B?O@
Znm!#VkP0ωɾ$˲hի'ժhY,wIAm~I     W "Dn7y   @x   e-[     8 P   h4   ~&[     U> !\I    o  ?4    u     i  x    pZ i  q2   o       b)?Dp8L      h	    Py @   K.1jr:_q0{.Èv];vЩST~}{[-gɓڱc$UVjٲ6bcc<Ηo    ) @!x  rXoWzt5ט=F@M6MC+VP.]8/aD믿^ݺu$?~\s1y"~333tREGG+77Wqqq>      DW{0y   @\L- ,]vU߾}%I׾}LT/$ t|xK       "   &4 ̴tR5h@6M6{M6@a484    K* o  Lh )>>^͓$ڵKk׮5y",IR-ԱcG     ?08 0K!b   8@\L- l#FP֭%I&LP^^!O>$5iph    8 4[a$   v^[ І
|;.]*IZzGM[       D   [ @0HLLtn7nܨw}܁`bmڴIaÆ&OE-     y @q5ޖ<	   @-  x̞=[M6$
2D&O*..$edd<
.     y @qovɓ    zeo ⢋.Қ5k$IO?mD0%7!mip!h    8 4o  P[^[ @0ڵz-Izgo>'B}ɑ$9iph    8 Po  Lh ˗Al<x %IM[     |Y3  "::ZdL    |5w\IҮ]~z'B$i_Bx     Do  P[^[ @05jZn-I?~LaJFm4o    N  UJJ8cҤI<;f   ^[ @02C6lPTT5~xGB ,_\t-(11i4       jmѢEf͚.   g )Iz饗;/IJOO7y
     u  a*..N.cZl4?M   [ @0{մiSIҐ!CTZZjD𗬬,IRÆ
5` x     ~^~ɒ%D   %^[ @0袋fI3Ϙ<!//O$iРAZ&O_     ?  ܭZV'z!y   "+x v]vU^$7۷k֭f$=iK4    K D뮻NSL_h"   o `ŊjРl6l8!өe˖I:t-Z<|[     |Y3  alԩ馛jWf8   P[ @(ל9s$Iv҆
>oÒx     D ժիW+**Zlqƙ0   ] W *233պukI҄	oDlIRÆ
C<
|[     : HqM7iԨQg}瞓j5a"   @\L-  T
6(**Jyyy\rss?Qh'x        sQӦMݷ{nݺ8   " PѣGK6lؠ]v<.Ě5kp8$I&O       4h@K.$YV-Y   h s*>>^4x`l6'p:Zz$sjѢh      "LϞ=գGM2E͚53{   @\L-  \tEZr$i߾};w|:|$n     u  t?.]3fo   	4 BQϞ=յkWI
4y"UVV$)..Nz2y     s  3pp8p8tpT .   @-  TYF]tJKK5d\nMB-      0T5pp8dede
   D-  T5mTsΕ$zxLC    IDAT6y"֊+p8d~D-     ~`p^ 6l6cZ;*<^\)K   Ubϐ[ @(;vnIĉkD8áիWKuf͚<[     : pu5l6{L/xReee4  Z^[ @[vPQQƎk88_0y       sVm})o:_*C~ܟWR"o	   h ֭[kђ-[hΝ&Oo$I{MF-     y @)t{cژNɐԦoб<m;|K   D-  <j޼$)55U%%%&O>|Xo[(e     ?08 5n6x_%?+^mO,{l/%m<^D   bO[ @8hР֭['I:zz)'BuVX!)ŢtA x    pZ n_.Y1(
]M
IR!+PށBm%|  *q2 p~I.\''ͦ5kH>Ǜ<[     |9 0QS҈*Bۤ+*=tϴ2Cy
j[o  P4 ɲeԨQ#vp<%l۶MyyyAx    /9|  ;ԵԢJ֥tږW·   o $..N͓$޽[&O,IRfԵkWAx     (oG|2XZ$]u]AwO|·   P`W nӕ$I8qrssM{'I>|NEo    N  B"tak3trV>3|-  @D$[ @8Z~UTTcǚ=N[b$)::Ziii&O@       PcȗyZ?rJ
Vl(!t4MM!t@I   ~E-  %$$h	-[hΝ&OJKK~zIR޽gD$o      BHmB1c%i6I'C	  h 3gy撤T<Qdڲe


$I&O@     ?08 BF~2X5|].\ިodā|m·   ({z4 jպu$IGSO=eD)++KԢEuih4     CIkG~eFi;/8tR5|7  D@\L-  %''_~*''"KNNv%HE-      @]ЭKۡ7ˌeN|?  x w˖-SFdە1 ZrC<
@-       -tzG*),ݎ\Y	>ݺz,UogȟUD   >B-  i޼yݻw+++"Cqq^|EI<
<@-     ~`p^ j
OZ5c*,SL(c喡7ͷ?Cv   س 	ӕ$I4irssM(+*..$edd<
B-     ~i @0D
[/ZVݡtֺsFI'k[  i D+::ZEEE3fㄽ%KHվ}{Yh      -t=Э5ZWuү&tr<2t!|  B-  R$$$h	[jΝ&O>SH*oF       =F}S'cR䀇n]nNm3:07IEO  y IfΜ͛KRSSURRbD)++KdZ5p@h      QuM(11t&qdH_/-  @
Ğ HbZn:IѣG5sLs
Cڸq$GQÆ
Mf     ?  x.V5JcЭKysEޤ   zeo &99Y?$iѢE1yaJMf     _|  H=gE6ZoWvM֩mifgNh	  Nh DKQFJIIḉeeeIu7<
F-       ײTQEAuizgvT|3-   j[ @$%IwvEqa>wpff x     [v(,C.7ެwʐ~_S  s 
$IҤIkD/;;[T~}ih    8 0=*/S5JeuAu)>NN譔?  q^[ @$[~UTT1cƘ=NH+((֭[%I
RM[       B3?WQϊ	Yv0{:1uyC*7u-   jD-  %$$hĉ[jΝ&O֮]RI҈#L[     :  )t{|
Z4aeݺܘvnyI9
y-   jD-  ͘1C͛7$BSVV$)))I&O`A-     ~`p^  CRQ~bQ~[궧H2qt"·   !&{j4 "jպu$IG̙3(;ڿ$)==iLh    8 o3Nj[V·`·   &+x ~Xh"<Qhq6lP3yo    %  [MݺܐVfuQ}-    rK.UFdە±Zk&I<xV!x    /9| jhQE6+oUbn]nHk[gu{@   n4 P...Nϗ$޽
V^-&I1b x     19:_zQ2Im/3{\!?MFE  3 3
$IҤIkDtjʕo]-Z0y"o    N  
/΄nWЭӭOu!)cz?-  @4 P"eff=NP_ÇK222L[       C{C(=A[KRҬ2d(W	  D8o ,!!A'N$ڹs,IR\\k4F4     킱{u<tĊvmn]~;,Ifua*-  @ ͘1C͛7$䉂Onn?Ih'B0     ?08 oct7>~۶!=  @x ٬V֭['I:zf̘aDgժUr82C#G4{)o    N  |[vCӖ[a+·?=-  @	4 Pd_s)''䉂ʕ+%Iwy5kfDV4    K HMo*35C_]n&|  ah fK,QFdە
;vPnn$)##ih    U> pjV
N_~~GZIog-I*G}f  4 P8-X@{nwkʒ$ǫgϞ&O`F-     ~`p^ pnۧ|bQA~^̾WA>{·   A {^4 ]ZZ$I'Ov7FÇ7ߔTX,!Q3o    N  ·[h6]8
	ק׍Ova*>
[   zeo 8+::ZEEE4{SeggtbhĈf G-       o9Lz=nm]63Y7>M!~>&|  h 4i$Iҫ;w<9l6%Iw}M[     : :=~
kSZ=O𭤓_Om"|  h vO͛KRSSURRbD}vI222L[      j
P|bQ&B7>-  	E-  cZn:IѣG5c'
,IR||wn44     ԆS<t;{MjE'~33|>H   q2  ^rr/Iz甓cD~o$9R1H     s  TszkYvZr㆕t
ӺːT}6e·   a[  fɒ%jԨvRRR"ȪU$IE&OPA-      j=pR3;|b=[?~ݴ%C:}6%·   a[  &..N,$޽[+W4y"lZ~$gϞ7y"
o    : x
ݎZneE0AJ~:I  gE-  u$IɓkDeI222L[     : xN{

lFiVm@YvI{s·   iEٷoի'0p8#FT{)SL@8Y~UTTѣG=_eggK5k;iJh       )t7*̷j3KoЍ\bc:+qڽo  B5			+Oa" *!!A&M$m۶M;w4y"ؿ}Iȑ#e_h    8 -tcߔ7Z-zfݚc;+q=2C{sG^$|  hE(:u%K/D "ռysIRjjJJJL.]*IСCM[      .BOL8%MnM0Nfڽ!@  'E-Bj/P{衞={q" jjݺuGj&O[z饗$I<L[     :  {	ToSLEm(Wݛ·   >iE֭zqV !99Y$=1y"yWTPP IJOO7y"o    %  *-	GToWLE<n&tL{~Pŀ:M   xPtR]|^2e M R-^X5nWJJJʒ$hB~ x    /9| D$o)X=RE5{ZNO+|-  @+ԬYj?!!ASN
D "U\\}YIݻb
'p999%I#G4y*o    : j
8P=w= ע"|kPko·   ='oFj[rVk'RSS$m;77.̲e$IVU)))E-     ~i L旇n?w
	-uѯ/0tj-[  iEʕ+C=N:0H~zEGGHG6{V\\7J맆
<B       B&~bc-zjw%f:ո.JC2S{ח  r4"tI>v
; RBB&O,IڶmviD_Vqq$)##ih    8 [voUP`SLEmro
I%_|  j4"\,\P7$͞=[W^yTӦMS%I*))1y[|$)11Qڵ3y2o    : 1n'LNvZpѯD6];S2|=-  yĞ7ٳպu>ժuI=ӧ׸l^5V}Gɑ$1i|x5    8 Wbc-Z0AI62{\ʐU{UäK/v/8   g	R7VPСCթS'!a8bU߃hӦMz裏*1125RAAN>z4ٲ$IנALΗo    8& DCzl*(pcѢ
3׌*ɩ3/W[  @bZB8'Oŋ󕒒O>DacǎzS𶠠@%IPM[     |Y3  ,yݎ
1ܢtkpt͸n2$}55|z8[}:[    %!\ 3pX,9Nޗg*--Mw֊+4n8=Z^|EJFm44    -t;nr

z~aBan2Nx*;藥k7g  8
۪a[!.Q>ײ P[UCEQQQr:X,X,ϥjݺuڵkFe8l2I7߬DA8     ? 'o۱m"tq W.Iztu,]C  @k+pAz2ŐGN,ƙrRnWmx,_itVZ󜫺WX瓣!y]{.h>C|r?Ɛdx,cggf4sئs?ߙY9ծkSu_Ugs}Z*uޞ*Xo&[)PޓW
?1j%I&OpA-       Ԃ)?!kE/,(W.Cے/~+|p·   &
[&[)ݮ=~&Hg8
w <
]
8	c3OguΊ坕7TԔ;W8gMWe.A{]3xmto[뫲FM_z4pJ33~U	HVNzV7{wk\U}h\3g^fy}Wym<_WyUQrTYeU^{mw~_쬲:Of[p=ߓ/N>i-++K԰aC
0i.h     Gj
Xcbc-&t]Sg7B׼:Rj[  	[Wxk_"]gL{
Uz*
jzS{N*\u8yau۾ʏ͌yuX߳󞱮2zU{|QE3?^p_>+߻CE<P\^zi^>yyyںu$iZ&OpA-     ~1L B.kEKmj2$}3sJs7V	  TScp|_Qa"
(\8g+oBzw`8~zl6IRff 5    8	 [vc/+&Ƣ%^n!u̾!BE*++np\qִ    IDAT  D@pV: A1vX:tHsU\\\cϝҥK%I۷W-Lŗo    9 =QSDC1-{ZuHf lj>PGt
旇om6[   [~_@_6 ąjذNZ YÒA     _rV I'v{)Ǖ_PlE\Cպ{t̾~~X-'|  @xȾ  ~ E_rOdeeeI*?΂C-     ~`y @-PFL+ohnՕݣ+"|{2·   
x+U38lP~}?^6kf6//O$)55UVմYh    8	 [6}q(t(6ЊgmnQMW͞z@aϏ([  s'_6  yÜժq믿ֲeԴiSӿ7+Wf$
6׈
_6FlM       `xnMӉ|1V,ZqB>vIGfl{~KuRhY,g-h=  px[_6  Rxj
R/\*##CCڵkՠA9t:j*IRNtך2έc`N`>F~&[     \8 !J[V.J	<\ؽ::<|CKtŖL·   ~2 TNqެ%ߩb(--Md_tIRZZ)3n<U12o     =  mڔt")kEYdHvyyr·   9Hl4޲wJհ-IKuwp.aX,Ϟo    @hMrB'򝊍5=-|ᔎN\]˷!|  "J pBH P'/'r8R[GyYO2*|,/pV].ΊKǝqN0α\QvUz3eNׯ ?_=_KPt<_|=*Wף6sUz4W_Txu$VXdX,h    }? oۡSSCbL50{\_NOSM߬=CK·   >2LZtk4{S<g828s[rRd<Zu:˗3<ZN>yxe]/c=o~5n)KE8nk~oϫ3?y\ݷ3~=#i?:yn޾=߶߇3ߟJ]W|U?UxN{ş-'^<Zp//{     g @P25_?;cѪt;[/'ܯ+fl!>~/RYYl6U&  
[ <v]NI+(j
9ޮXj0*?ܨFOjNu0w YJʹ
g=OsFsfFޖa7vS8Y~[<9sp?̵=ZlOuuJynOV]U무l6v`D-     ~ =t;xj~wchͼnW7l!juͷ   U]~> ԍgdQrXt߬sTjB5?Ye\{78Q|Y??Ye<v2j	U>ǅngyյ
t?Ttj*I(҃/o	    P!8  jݞVЭEk]A?IO{E=o @M4r	 jzV(p!,ju8ro鸘/o-^       QSCw*6ƢP2[P	=K!۞ots~|<>   ؄Lm x?ve jõ
J
cax-     .y  "VBILY!۞C:"·    TXzj .Hr}$o     n  yzdm}Eń_$۞C#|  T dBH |*~>yg~[       @xQE֢.W'BSMfɶB·   " 2E:~[      R -t:^P0Ԗ-e{2C=[  :[&xA-VB$o    %g  S=|Z(h5"h]6~1{Uo>K  B6z6m?6{xgM0/6lSkǏu]vԩwyujӦM8pn6uQЋ/SNUZڴiÇWw壏>R6m駟n#Zha     A SSv)ϗbc/uGc@O!ɾ. |  B \B6D"ٳGֵ^m۶=ؾ}曀<WQQ;vm۶9rz!jĉڸqc5tPjҤF#F誫ʕ+5h =zO?! ۄC-^B/o}&     B\ RsT/Q^d13M"$4[O,ǞoTwn$5j Ir#T   b%doC(_Z-Zcǎ.3{,7w}5k֨UV6L#GTVV飋.HOoʕ+զMSNNF)ShÆ
>CjР/^$]q@?o[       a['JtC/E[<"Uw>ͷ   2!...onM]taھ}YuEJMMURRym߾];w֧~~)))I={ԛoJKKSukǎgiԨQJNNVvtjŊ풤;wM6~׳gCJNNԩS??rڴizKfΜ"rOֲeԫW/kN;võw^2z'uw}JMM^9ǎ;vСCjӦ~mIRII/_^z)))I}ѦM.CAA$iӦnX4l0[%%%_Z)t뒘QF?W/##CEf:٣ÇSNJNNք	*oٲEmڴѩS*=O>z'| o{ng)      B(ƹMԙ-BPܤ>j<{;|{<·   ^Lm컽[:}5jH;vkzz饗ԴiSM8Q:u$iΜ9;v6oެ/\3gԄ	jƍ5{l=zTo>
>\3g-ZmjݺuꭷުM6Uׯ$顇TPYY̙Sj߾}JMM9s[o͛5m4Zl3fh۶m0`,YÚ2eJ|ĉ<xvޭcj޼yjР222S9Nd]~ڶmd4|pmݺU}ѳ>$=Zp`H;L/щ'x?~.RI| I;k\_{5n8޽[[lӌ3fhĉ5x`^wOxP Ʌ[      ['Nxch&"ۥ(n !Ǟ*"|  BT TB6"m߾]mڴq:v4m4[ڵ$v=ZڵUW]fG뮻Լys
>\v]_|$/Tbbϟ:}6m7n>Lt+!!QTTm۶iРA޽$iɒ%jܸVXduU:~6o\iOSӦMչsg%''WKKKLWrz!CSnn{=糽7nǵxb۴h"]s5¿皳I&jРbbbtW~zYfGQ4a=#ڲe9r?͛7ҥKp84m4u]ի̙O?Ҳ~W\Qׯƍ;뾞={]vZlY/VBB/^ds=Zzl6VZU
;ŧhLﻹx    Ρ mB>YW-¥9%o<o @H	D@*do(.]ԩS:uZjK/T۶m;kEEE-[ܰaCIu]Z%I'OT\vСCCk׮ӧUVVv9']v5j$ԩSQǎ-&ͦK.D+믯t;..N%%%$ժl[;823!/1wҍB([%2PP$c_DMݔl)ɖdr\?9͙Όsxcszωck1t+*Vwi<޽l33;w@ԯ_cyf AkUV-.]ʇ~??^xtokZ62dV+#Fh7+'OСC<SNvܙ="xk-+{Yn9SC8gd7X<:D[WW;5|[p (V ͆w&"""m~S'># ƌØ1c<m۶ÇSlY%Kf-ܒaY@@@&&&2i$V^MBB!!!T^͖fΝo߾(Qhp||< fL2Wa}m߾ɓ'/`۩X"Ŋw̙l3gayHHwZIrr2+WrѦMgfܹԭ[~2ep88vKδD/Lח.]}͒%K;8>s }"7𔂷"""""""f""+}rHMB
m)·"""".~SևpfիGǎ=ӯ_?/_N>}qXn
t\[haԩS,\B
.znܦM7oݞ:t}RfM/^w܁fc͚5*^/%J_]SEԩS8q ;ٳgt/s8o7nܘ=k޽;~̛75kg租~AYO˖-ٰaӦMsUm8wR*ϟbTV$_1|(-o~xrMDDDDDDDnʶ+nMD<-,Эk^nCϦVڽƐwd)))/"""""/LO"mڴ3gЪU+jԨS~}jԨUHLLz߻vz<p#G8zǹ	رcoG]B
q]w?SJVJժU\2s/x~Gܹ3+WfKMW_9έgժUXhX,ǨVZ\t7zlvZ۷5kp8C(U{
6f-[p:TPjժ2wL?3o&wuջ>2ԩS]HHʕO>8&OfԬYٿ]1x+*ފ/W
ݶd
}A7z"O	·j4|-juۗ"""rȋ3xóH+WhѢDDDdYfDGG~z6mվUƆ
Xr%*Ub̘14t ˗/gٲeh֭[=DFFE޽iժVXkڵkTRZڵkYf
{Lתcǎ|tޝN:QdIK.]J=j
.ѣGYh< 5b6]RBoΒ%Kx'2mqƬ[(>6oL\\>{HvE.]WUTpo>nyÇO>DFFҠAjժjO?%44c^5h\T)^z%FuɀρK.1w\V+]tR+6QFr9,X@%sFR[AYV[5Ynh54]B[}IL_] 𭈈Tp'زe-[2٨Q#&L|m1Mɓ'Dhh(m۶*۷o࣏>⣏>͛`ڴi̚5Cb٨\2SLxʗ/ѣ5k={H"}̝;nݺ{nUv󉉉aҤI$&&iӦMjݺ57o&&&Fv6mSNeѢEF~h۶mԫWdfΜIҥyiҤ{n%K`6o̶mp:ѵkW:t@@@{bŊ1{lVX5k1cNeңGz)
74oޜ
6y+nװaCz-̙	

"<<'@pp0cǎe6P"##O5T6[L\{懧SU%""""""7D4vӂ7z""ƕBOup2mltqn2~˗~۶mcΜ9۷ UFϞ=TR.4kgrv|Lx ncZZnl $~5;B	

rX,lt?tDǉ X\KeRhnI?΄Lq`n	^!t MrD`` vŒɾtt:INNvwc}h۪U+:Ĵi2
Ӈ/cf#88zAHH {}W۷{9z왭ٳw}'fk{ɾ3PbEwEFŪU5k{ukea-ʆ
^&M׿+rc^	> )P9gǞ}$oeb7f*ފ\CED^V۽xbXJjnAtqx+~r,}v"##]6Fŋ,XN:1w\TK\W 
|$ƚGU_Dīnה\xg:DŊYlY*DnܷSRR8x Vnz5jdv;+V9[|ٓzw}N:y߶m+Wcǎ^	BjPbŊk׮e߾}DEEx⭂"""""""ԀoRŰNťnEBr:v̞=P|MקFDDмys{=^{5o
`rn<,{ (X1L[)yqbYOǛ
VXA*Uh޼9'Nĉ,Y2v
gɰ<,,':    IDATnJzrwZh۶5]3<άYhР˗DGGswңGWvmj׮?+ry"߿#"7҇n]_'bɉx 2d/2K.iӦԩSg}_~ӦM~:t?q={н{wx4hA8~{+hР7o}ԩS{9s`OBݻ_|
ϳuVVXAx[.ڵ?&..Çz1|p-ZD:u<裏h۶-<#$%%y嘤5zh5jX>{l~Ο?]ի
4 ""f͚1m4RRR 3fĸܺukw			OAzѣ?{x={C Ŋ[oܹsYWn+J[y41;HOp8HIItz<DDDD#x$ko/\yiҤ	abŊ?#F&M"<<m۶#<<ŋӧOV^	g $&&2e5kFDDmڴᣏ>hI&̜9.]PN^u>Lxx8rg1=GٛSʲeh۶-u֥Yf̘1c^?dȐ!<#ԭ[Ν;ezKzOF!..CR~}7n̛otҥKL:'x:uкuk{+ΡX,akmLɓ'vW;޳g=zaÆ4hЀ{T#~	ŋ}nݚ!C\إxiР
4`ذa>}caz?} ɛcUVDDDDDDL[DDtp8{(fÜ@b>Q/dƍ̞='N/2g^}UwPvڵ^xd4h{K.+.^رcڵ+˖-e˖̘1
603f&L@Ӈ#G Ktt4kf	k*TCra k{͛ٳ'F?dڴi:|^{50i$:u|ozLkڴ)qqql߾c'|B)T{Gĉ]6c <{?siӦ=|p-[Fyy饗8ttz;uD&M2r\
Җ"abb|#I;
G~SVc"".+%!!MRX1իǇ~Ȏ2egrL\aў={R|yƌCBBO&::~i
D
(S˖-N:I~Xx1-[䭷ޢnݺk,]c.$,,аaCh֭ҥK:t(ׯw7ٳgoΛoIyw4i G7?#zb̘1.\(weȐ!4jԈ-Z`z)*Tԩ/fݺu 8zAll,[fԩSI&1a+>Vʕ_oᣏ>cٓ;7ҵkWv;Çg߿Ν;nUVo1rH/۷{}v0ɛy%?Gs"">tnSRRp2qAv"<[dƌCxyw?~<5j 駟fĈ<y~mBBB6mAAA ԬY-ZtRt_z%4h @nƍiԨ̙3k׎uPJ͛BOsŊiӦ
wlٲ|gL6￟֭[s	 Ϝ9sx衇1b uԡTR0ݻws^1IF'p?s~ﾛcǺ+l޼]vѢEJ*ERΛ7oI&QB&&&GTTZr/OII_رcf߆
UWxZ~m009&r$R(N0ꂆ&:vXvŊ@/s4.NGo_p~J.Mڵs̙39sf֯_ObdԨQtܙ9s渫10(U
nS|y l¶m0` m۶ ""iѢ
 dɒ:
?Nv ?gӦM8TX`-Z`q]p7p8?>			,]=T~}:u[oEF=cl.];pwsp7дiS֯_ĉ_>MG6EѮ];ʖ-OgCpp05jԠC'O殻b#""hٲ%fbԨQYۊ/NLL{~DߟM6Q^laz} ɛoDD|+M9+,絢<|_[RSEPreB
pyn{z)l6+/wͶm<&x̥K ;W_qDDDPvm^z%
zСC>|]vY"EC vƍxb [iҤթSƶmۜ̂zdѢE$$$ĺu&""-[ҲeKݻg1m4z<i[qqq>|i&c֞={4h͛7g>ߓ\|uƮ}8[FG#/QW+"""78𛊷EvTg\xHpp%XlYSh޼yvvse˖Y[,XUҹsgΝiL819
 NYt)}{n讻rnӪZT2?C=䱼K.9;wac1~xʱi
(nx9w
pn]5kƢEصka0bڵkǟɤIX, <yCѻwo`ԩΝ;l7/<Czaؾ};9ü⭈ԯsb1R/&l!٧rK2c||< fX+3Vu&;w.,`ӦMXJÆ
yW)\0Ǐg˖-Iٲe \9s%Jd'88︸8 ~?~4mڔYf_C駟#/$&&2i$V^MBB!!!T^͖k{g
#<BNۙ<y2v+RX,_p!wy'υXECNXDDD=x`Ko?# ƌØ1c<m۶Ç{0-СCݷv;KB
eNUT)C7+͚5cΜ9.\5k^q[Nƍ3]vndɒn~n0yΩWfsS.gϞrq-;;{qgmWн0ʖ-K``ܞk0gܔqX,(Qgxzŷ"x*ފ߿#"Wʗ2X9<GX8~^{]]ЦML+Ɛ!CR+~).x0HSNzq1>wJbǎ>}߮
CRJuUPjԨ~Jb8q={qXn
t_iѢG;'No߾q2s!K͚5Yx1wq65kְm۶L~֭[dg
!;1L0k݉`(QVDDD$?򛊷:'^Sr`͚5ԫW;z_~,_>}d;$mi2fJ.ͅ;v,Yn_pal6s4|AkSq< ޽{{)RNpߓ'OPX,+^MVm8qr͗eվmלRj?>}-WU(Q0&I:O][<_DDDDDD$̍30(w	Zԉa]|!s>
*]w?L*UZ*UVr̙3/"m}4hЀb+WW^/_?SNq!5k?OWǹZuVZ;w#|t:}=`cZ*EaҤI߿G'f͚e֬YÝw]w^k.W?Pq=޷^z%W.fVA8$:wLʕRNY -w^_o0n64MRjU$qS>J^)Dīnה\xi&Μ9CVQOQV"11ы^X+B޽ٰa{bGxx88G2uT.\p]㹖9U?#%%5kcwR֭[G2e(]5VZ\t7z,_v{
		\r|'ӧپ}JZfv&'mܹ;HJJW0\TVDDDDDD$Ԁo3łbjr{).3<`ݵjEFFE޽iժVXkڵkvxWܹ3Ee֭߿g}J*ڵkZ*ŋ믿fΜ9 \t	
PjU
D=?СCŋSN̝;d֭K||<gŋTZ
hԨǏg͚5DFFzV6l`ʕTT3cLtۨQ駟߿?_u߿pT^ݣ*U`XX`V4Yv-k֬8fi1;３^xۻsδN݀$AnjbZ*/@fDD].T]r%E%"""͚5#::ӴiS/iΝdD<#>|)SЬY3x?c^u^wңGh"x|AjժŐ!Cx\23f̠Zj^׸eNR?ޱcG̙-BDDc޼yoߞB
ѹsg6l@nx)X +V~7޸q7jԈŋ3l0vJ
ؾ};K,'n###0`{ҥK̝;J.] f1j(}YΝ;ǂ(QDI[}ӧO駟DGGNݺucfܜo9""~#m0jbٰ/d+x2~yC:CΑMƬY:t(6ʕ+3elSpaNԩS?~<.\ogȐ!@'Ndĉ4 *T1c={6wcǎ[oĉyq:4jԈ-ZxTy(Y$,_NϞ=	qԋ/g<iL<$BCCi۶-Ǐg͚58o	2}w`e˗g̚5={RHnΝKnؽ{7ժU͛IHH_G
&Ԩ@¾)nfЭ·"""M[M&\;/WMJJb˖-l]5F1a>\
~g|gR
M4ar-׽nȐ!mۖѣG3qDZn͛fQ|y&Ǒ3x9u!!!nݚnݺ]eN^Xb|RtiwN 

e0n8RRRR
SLN:5nƴiӘ:u*-">>0G۶mm
[o1gLPPL80 ;v,ӧOgذa'|rO?oFfqDEEaX af7gFa,""""""ϙIJJ
D4vӂ7z""~4MLt_oILL$11L7
p2΂qmg+|K8?LF<..Ӈs1w8:G
&a=IzEH@@;|kZPv;g IJPPv}{K.It%%%ҏ3!!;yz\ &[;C7z"?:䏿"q


"00r:8NPBBx>;k_/z("!aǜ2L)P9}sSܽqGrX&vsަ{v⭈e>_Do&ROR>_6XEڿQS:S$%%1tPl?baӦM|嗌;FOƑ'Gr+qOyC@BxnUVDDDn4 x|eڴi̛7cY`` 4oޜ1&/W̏z⭂"""""""Ԁ3#|*^8o0tV<`7`rʌ7wyAt:T&LA7zxr%N\$s;w{PG[W9WVEDDFɋ3z>mѣ
4M.]Į]x뭷HLL矿?L_""yy"""""""""Ua`fmZ2lV<·9ְaC6lx!9`:R8.چ0p_9RC@m@@ V㫛o*A8Xru+VcY.]&UW[EoEDDDDDDr_
߾;0or*°Yq`ԾHV$?u9tr8VVDDD?xG_,קdɒ9rcٮ]7o=			cѽ{wV+ >([毿?ŋs=ߟ+ڱcf⧟~"((zMHH .]b޼y_cǎQLZj3<M"J/ڛ|[DDDDDD&jr]toV+vN@@ T(M`8&w\$wn_B"""_"N7ou~/;vGrQ~w-[?:uf޽у 8q"kf޼y^ڣsbfb̙?~Aر={0` w&**
ӉGҺukƏO:u4i&Lȫ"y&{MQ[|\TVDDDDDD$Ԁnw% N@_U|tSsqv,_9̅Q
݊ȋxY|Cծ]͛oO}݌;͛ٵk-Zpo[|yh9BXX3g$,,ɓ'+(QQF~ĉ_> < 6EѮ];ʖ-+B$WH>ssVUVDDDDDD爈oJ;
F<IEx"g:R8[ n
݊7o5/9oO׮]7olْ-[p88x f޽$$$^ժU=n(QK.7|Cܡ[pV\	Oܡ[f͚h"vڥ'UWLL{V[o2vvpGPVHˡ[{bЭHf⭩IXb*UĠAXn-[$11I&zj		zlϋ ۮs|ɹsp:0nfΞ=Kppp!!! ;wSS[|0s#Uʷo˗ynF<I2^ħ8X.
aXЭ%܏M[4T#G 7n֭cРA<n-rnX,>}cilܸjժQHNb    IDAT:'N x+I[6mL
/jWjb۱H2 053?ɩ'G;L+Э8K񛊷Eilݺek.W?9rGnZjlڴ	^7п~7jժťKظq}׮]@ZkDnUDoEDDDDDDDDoetmtoVdѼȵIqG[尽B""""W7o ,9|r
( d߾}|ǄѤI UƆ
Xr%*Ub̘14tR޽;ۗVZqyON5`6]RBoΒ%Kx'ۼ{ D*ފ+yO)x+""""""uDDoN
}4NS|orí+}AOnEDDDo*W*KM>oFpp0M6{@n1Mɓ'Dhh(m۶YÁ͖(NDDSLa̙4"EP^=^|EwӦMcԩ,Zxׯm۶&{MQ[|%I"""""""@ym(H1-y$·\۳n8k'`vwnEDD$_ȋjf~SVoJϞ=ٳg-VGtK/u2ٱcǲ"""PB++5EoE?wsfgEDDDDDDnB35 ".X·Vݎn'  @ʇ2kIpQ'>ظ<rOf#&VZQVDDD8k񛊷Evx+7+*x+""""""?s""R·&>37x"'VjpnTB""""97o5$"rTV$_$⭈7~HN@f
EO0G['.n1U[WV[񛊷&DD*ފ+4ǥ"""""""DDogjP* O>0ɩnj'hNWT[w" 7ou>'"rTV$$⭈H.++
N`bn;p)N{2qnU
݊H>g1~SVH""NoEQ[\uDDnpbf߆d0M`X2F]nb8Ԓ5o9]<Bv][WTVDD7Oټ֒e⚬X2P$Lf(48Opr1M~C\u;g?Э{x7oVKYgΙl69Ç.M0}Hm.OaoЯU+s=kY5O,MW*6KU1S?G}gڕfg,YYU6o>N3{R~9s/o)x+"""""" ""7o
?	hdnb5QH[񗊷ciw l1}0\aSӉr֒mm߷{{R3Hw;vXó3vs8u W1Lg+`d2l<n׻?1^uyqiIM1<7+f>[-""""""r31⚰X,XVl6HLftHD7t=loLr:xs<lK;cX0,_C/RjSm4>ncK@Dvl7m]06~~,\óriW_ڏ\>Yy!C?\xo<7\۟tdxe?f~<Usg?Yl{?pXx0_;gR[\cED$U-UbAI?	_hʷ
oq-X Y[`W(yZldSI8RRRp:`32k,M_2+T\aڻz#viefK̸72?|l/;Ζ^}W;ot}<2l~YjiḭLTA[ݞZ(!(żyୈed""۲0Mڶ(Ô4w9tk``,KnEDD&g7~S("+\V+N)]3uilK;G
Ի~|}^LoEDDDDDDDD䦔52'
^}·r-L_;Ot<RtV'nEDDDrTU8LD*'ziЭr-Ώ*U
	F=KQ$$7 &OQ߻=V,5Qlֳ
݊"xs>bize+pୈIw*ފ,d?g!B-$0(!V}R[38V,f9+t+"""79܏M[?/I;
)t+m}}~LoEDDDDDDrDDkt|rbbbغu{}pp!9?iϩC_?(|+Wa<S˶a{^t{B"""rSˋxci/*"o<ߺ/R[o""r'OdL>?ӽ{[n<㘦_'yiEN0:dLqKYXr۲,A
݊	xH"?M⭈7~O۳g'N$66$ V+Z_$""ARRIII*	o~#.p1INr̓%o쎈O1SiZ֚aQ[<7ou("r*"7*ފdbcc2e
۷ow/		[nDFFRT)Ltf;|;<'NZV[qjN,0g[[4Lr?7o`"^SD$w⭈H.%s1O̙3믿kԨATT<X,ukI8?ωc&'o}f8tN܅a0B /~|/97x=ש⭈k[laʔ),_d V+-[$**zez?ׅ+o'qZVۛSjv'W l5RrFnEDDDn_x>g&f^pc6oR2ˁӽ^N}Ծ2]v{ۓ2k_FVd_X:,ֻ~+W#c~{쮸>s2O=''ӿ\xN@4npIS?EDGoEDDDDDDr]$&&dL®]K(A׮]L2Wm';#M^~'L^4iT)3gprN~o(*t+"""rCZ[aX,{04BiBiz=3A̷71L.o&|i{iiˤ3v.oŸ,ӌ1;J4M#M;B۹+sfK6̟Y?,cr}ύ<gIw9cc9ޒɸ:^~{Oܡ"""""""@s""7ѣGaٜ<yҽzDEEѡCrfv·F+q$> ·7	3wgrb.,B܏ĺBu+^?+;1Nt: ә0M';ӄM3I`/vW5tz鼼UUAT5U5.qy8LƑ?񻂊iO7r3qI&_+zǌd_gџ+Xy83}/ cg]*<cq-e1l>iW>t̳_&Cyy;WeD3M=zNXV
{P\""""""".눈o7ndʔ)X V+?8QQQ4lNv(8,'Ophmf8aB""""WgCVZVjVzd2IIRRRHII4ML[JF"otbf#  @CEDr*ފx/EDLBB.111|ŋ'**ezoCF_0vS6foUVVDDDg*m
׹+xZfXHIItz9x+"7+|Zz*"TVDDDDDDěrR@DDÇy;w.gΜq/Z*QQQtؑ
JYo]o-	cF«ɸ0W'\
O+t+"""C|o]VӉPVDIpuo{RU
60eVZ(mXhڴ){_WJo
 $F!R÷~/'{Z72
݊IGb}-^X,t+"^z6ޗx*ފ]*.pBLO?^^hQ{9zߞR $Gc3ud<my9L23ggs|n-Cv
݊P^R[z[4X,
݊פ
*t+"{TVDDDDDDDDD|2e
'>>޽J*DFFҹsg
(pGxmɒap/'PO)Nvwñ{`xoBUVDDDGr۴ܐFKEDOoEDDDDDDri|'L2uֹ/@c=FTTM4t-Ç1	cЦ·LqZaeV68oE[>TD$o⭈H.H;wï^^H:uD޽;n,;ۑJ0b)307M2y8JVfrl,촧&ŊYѹQ[\uDDn_ɓ';pyʕ+ӫW/{9
,xG}	ߎUNsX
o
hO3S4cbָr
݊\8[劷""""TVDDDDDDět=GDLdL2׻R0~axG2Q0j)s}·Lq<\
 FnB""""~*ފQ[o2g㛪OVve2, #(Pv+x{g#b/E2,EEAa($Gmz>NiO>JΝ;ٳgkƌ:t{2e8ap%|?iOCSƧʐrL܀jwoeȐ;j  (Rh  Uxo    ( @'TllF֫WOSLɓ'X,B> RXXJ*pܢW*U
~8xՀwurŷaDdmB   Ai  UxK    ,Py<-[L:tPFoN:iŊJMMȑ#UlYF·1R!T·jۀy:rdHF/;CZv-[   Ż'o  `o      ř3g4~xխ[W={.I*]z)8p@k֬QnJDPF[rV֐4m-[|K,՗)m巒!E6?-\ʔ)#Iׯ֬YC     V     +p^@	{n
4HիW/cǎIԩI&ɓ1cl4}ʪ\)
."|j:Ka(i"ޢ{GVRٲex裏?&t  Px   x     (n,Y6mڨI&;w.]$IС/_Srl^y	߾jeTuʐ7r·!czbH%)3t[zOEE*UZhu֩B
x<zǴ|rG  (Bq2   
     X: ӧOW_UڵջwoHn
:Tg}?Or8O·UT9!CE3=^m@'V!)iUM-t&ө͛kӦMP^ze˖ٽ   ER(W   V    `|bjΝׯjԨW^yEiiiZji	JKKo
<iᕗVULUdHǄo-cz2=X[!\#tt:p8N)))Q^h"w      V    `2s@ve-\P{5k{Ov?ԡC4zhUPi<oĪrU$i}o-`zJN$̝Ujn}_ƍgӇ-  @!D-   B-     08駟[շo_m۶MAiϞ=ڰaz)_W^·ϏULlfͱEl0=^ЭY274lP)))RL$|  O^[   X%    @i E_|D}|{͚5OkСT終1ciKi:[o^25c;ǫY[CUMqS^u\r8n}6l[e˖:u~Ma   P\L-   B-      Peddh;ղeKm֭d>|X/ K1S%04c^LW-Ա郎mn}֭[o`   [   X%o    Bɓz饗TfMkǎpk׮]ڼyz%iW^·^N24c^xc9ǫxw2$d^:[  B[   X%    @ bӦMJLLv۫WzJO=Ͷ!w:wDH^_<_~t뭱{eHDNYt6Nұ0-є[l٢VZ)--MА!C,3  ˔Xo  `o     u 6swܡv>n>-ZHGK/D&7jEϽVCU]2i=Z.LW'hrwVmAԪUK[lQZdٳg[W   E_(W   V	f-[     8IOOWbb4h!Ch׮];vh֭ݻ\.n-%/J*wgnGKB>[Io  lD-   [~3     lp!M:USzz{ll|I=ӊqB\/ps#ؚcGSoGڡH0=^%!C'w4tSzumٲEm۶աC4tPIҐ!Cnzm      J0o	    % 4zjOecT^f󤸑<o>_֬vː [I"M+ÐʷUɝC^nݪ-[÷>|xО  (3e}$[   X[     ,i w}WӧOWjj{*U+WqBč·kkKGA."    IDAT4ݒi>uB9fczlb]3V{=[*Udߎ1B  (4=4  *4      EPjjx
͟?_wuԻwomoGVK|D?MoXB÷ǫuCH9nn}|vio  B[   X%    : ,`VZ.]aÆ>}>}/W_}}-&|P!)˥0*UJu5J0ٯߓ=vy^DGVa"VMlTRE)))jذ$iĈ4i  Px   x    BPkܹ>}<^J
6L<*Wl㄰ҍo+FIό7|X9cvɐԥONi۫Ock!CZTQ;ЭOttRRRԾ}{ٳGG$5*d3   &x   -     Y8 RSS5m4͟?_ϟo;޽{TR6NP[!|73fZ=`= 
-;ЭOtt6oެ6m  %^(ލx   6    Pp>M2MSܹ6l7|SϟWXXx	mݺU۷o-a|Q!)˥0*UJu[W15JI4w̷4Ƕ/t{tTΪjZHC>+V͛մiSIѣŶy   3o  ``6    q ySA֭֬Y#4Ure+:v옒t}=*lrPvq
z^}bY*M&ЭOŊqF   C-   [WV    + EDjjN-ZPBBqm/<pޅP!Jzr\=|Nл!>B8unV
\ȐTE5t+WN7nTǎ}vM4I4qD'  
SGbi  Uh    p=ijʕܹ6l3fr\zǵeP~"W7juW_15%CzofAǾi^WȺUjQE-X֧\rZ~.IҤIh  %F(ޝx   -      pΝӔ)Sݻk͚52MS111zuqjٲݣKvظ.04o7Z[÷^W+.uUr
)S#l
  x   V	f+h+    Pq^@TM:Uׯ޼ys%$$':"T_ghޫH:!1nV\ReHԢAe"lܹnݪӧKm  h   V      +VP
4cr\zǔ;vnqSn|[ZC)fCZ0jŠ2n
R*n}ʔ)uۮON-  (Bq2   J0o	    :@u9M2EC=kJbbbK/ZxZje(NJZ}v}C^W@aԼbԺuԾ}{IۡC;  EBn[   X%    @QJMMՔ)S`͚5SBBx	8!;_Ƚ#B4h|}~~9EvJ8Qf۫}!RʺgR{E.~[H^Z]tц
4{lIҬYl     V    `2s(LԊ+ԩS'5h@o~W\.K7o_xB4P5%	;zv}۫>ԡJZTֽ<tիWSNٳgkС2M\      J0o	    ~ \ǹs4ydկ__=֭['I֋/Ǐkɒ%jݺ͓$Kv?|BZ>#Z$)Ee;]+999[6>>-  (6B[   X[     ,ixڿz)UVM=:$IjڴΝ'Nh̘1Z͓K6~B#Elb^2}[۫eu?Hݼ+a[0%''k׮  F(޽x   x      \iOԱcG5jH3gԯ*˥G}T6m7|(<<qoOM5eHZ2k[÷^W
^fncrb		      
     X:@w9W?>$EEE=KM66O
\[^·&ޮ2	;杽!g?0E7Qq\WoC  h  Uh    % [דO>X5J$qzw^{MժUyR oT#Bwhm÷~d(yZOhC6/|ۣGIҢE "-bh  Uh    ׫?X5j~[.\#<7jΝ8pȷoGVIo
}0~־n>R!˥K^x<6O  x7G-   B-     H9w&Mz%IQQQzt1}j۶͓7//۾Rɐ>C,z^-RQ		^ҥKKՋ-  @.h  Uh      
kذaѣuIR&M4g8qBcǎUjoÒՒ!(Ca(yNhE6Ne˖     
     X\Px^-_\5jYfr:ٳ6lؠoV
RDDKϤg6Jhv}wA{~۫CVdn%Unv	aJJJR~$]	ߺn'  țP\L-   B-     Px={V'NTzԣG_^TR%=:v>CkI[*Ռ#3|;÷^WPCUn[- 04o޼lۇ~-  (B[   X[      KװaTzu=:r$fϞ4?^ժUwP&7FR2lWZ[۫ECWÒUi?)9÷Ʉo  x   x    8jٲeС5jYfr:ѣ>sڵKVDDKIw⭑2C}svynR>;,C
G6|!CH|͓  ؋[   X[     ,@Ngjĉ[z?\TR%=ZG};(P%|{sdH}Jmq
"04k֬lۮ]*##   ri  Uh    Bc޽:tU^G$wӬY	&f͚6O
ny	>6"C9n¡ڿPfQHӭef͚#GJ֮].]  R(x   x    @0q>ղe?A7ٳuE9=Z~vޭ!C(""q"F۲oQI2oe蓱۴:[۫Ven%UiVI߫["Zhʔ)>|$iÆ
ҥ.^hT   G-   B-     d4gϞՄ	Tn]S6l$UXQFґ#G\ 7YWooߵoIRi$t5jmǎ	 [   X[     ,@n{jȐ!V[G$5nXoN<'f͚6O
y	>JZ1Kmw[X<JC6&N'JnJ  *^[   X[     ,ix<}Gj߾7n9sŋr8ӟ>L}o{\QuKKzZ0t?*PlJz`݄nm2jԨ·ϟy*  x         P"={Vof̘cǎWPA
ҳ>K-"0q΅;Cr>:TE%q
'tkQF)""B#F֭[աC_^eʔ{4   Kx   -     >e޽<y)o]			ׯ"##m(n-%=<N}2:s0]R0ո+J{!Э.I1boN  4  *lF     %9"<>Co^7;Ｃ/p衇Һug
6-`#_@ptr),,LJRDDGQ(~YIjnQDDBd5k$÷Νy*  PRzeo  `o     uk;sf͚3f*TZj8!|:J_H.cȐ!aÆij׮6nܨr<  (iBn[   X%o    |pM{ɓpB]tɿnӈ#O-PoNE;׎t:	"CQxxsN·  آ   V    `2s%Ѳe˔M6;uU			رȏ[0p8zzen}[BC~$)[vX͓     
     X\J3gh֬Y1c?^|y
8P>jժe 
*0|:19n~TRӧvܩ6mḧ́o @H>K-   B-     JݻwkԩJJJҥKo6
>\Pddn};
\Էo_ٳGmڴц
md  ŻCo  `o     pS<-[7xC7oow8zN:8! +i}q(|qW^ڳgZn·  ȣ   V	f#h+    Pq^%3g4vXծ][zn˗/#GСCZb[q8WmCףG-]TNSW֭ui  )4  *l%x    @rF(vޭzzu	IRF4}tiʔ)U͓ u\S  S^[   X[     ,i7n[K.U6mԤItP׮]駟3<ҥK=.  z˗÷-[$|  ,i  Uh     8b̙3zTN=cJII$+WN><+WyR @0tU˗/WXX:D  Y4  *4    Lf[ڽ{ի륗^҉'$I
6TbbN<Snݺ6O
 ]*999[6--   [   X[     ,`p^E֒%KԺuk5iDӥKd|A^ZUti XSNJNNVxx:VZ  Ai  Uh    AQr3FkV޽eIRr唐*99Y;wyR @(uIWVxx=J  M(W   V     ڽ{UZ50U
oɓ6m֭k  o^WVdd?|{Q  !o  `o    uPHn-^X[V&M4|edd0ԪUo>1BK{\ @!о}{[-  (Rh  Ux
J     quPȜ>}Z3g̙3e*>>^#G pM-[ԺuԹsgUVڲejժeh  2e}$[   X%o    iw믿E)##ÿ=..NÇ׀TlY' -[աCvӦM\  -+x        (8BvkѢEjժ4i+##CaK.JNN@ /wu֮]e*--Mw9bX   W   V    `2s!ti͜9SoN<^L+!!Aqqq6N (^mڴIڵO?]j۶m*Sݣ  x   x     vܩFzWkԩ:y	 iӦZj´w^=zv  P\L-   [     dvh"lR͚5ӂ!0Թsg\Rг>e=. jժΝ+IO5rH'  EE(W   V	f+h+      WO[o3gm%L2߿}Ym !ӷo_}w?~դI
<   h  exK      vܩɓ'kիÇkРA4 l1vX}OO^z`X     V	f#h+    PA,YD{5k{رV\jȑn 1C-RӦMxԻwo]p  @!i  UxK    ,ڶm6m޽{k۶mҥK駟ցvZu) UV)66V?^}UG  X(W   V    `|nҏ?}ӷ~+I[&O'O7T\\S pXM>]?   B-   B-     daϞ=jܸ.\(47|SO+W ={;PFFFe8  0#ۭD-   [WV    38|ڹs:t_r\zꩧM˗{4  e	ܹ}=Z͚5{$  PȘ&kƕ$ǔcY	-E=qp%X_~bWA-     Y	cرΝ;pXB:u{,  
P۶mi&=/	  2Vn}SRKٺo	|~#813/o++Cdl=3_b-_Mwվu=r:ܟss^sjzA=eH?|df5 ^k:뙙AZȺ?)Xmc?1\s_/n.?79_^^___s{ z}}zm7:}ߘ2S>?W}.q]׻:mP`\	ܷǜ|U?'ރ|?W|=      ھ}:tݮ^- ț8q$/ŋm  g!#3
M(ŕ33Y2Ku\_NW\xW6gkGL3zqa\?2ʧ!0S_Ue}eՏm=߂7^p*}_lMtry|qxẀ_ϸ|F2o3ӕgCf|/2g\3sugzUI^9.ry\?_s{z}}
\O7^/99

ֻrf}6}]_1qVq<qm\|>sZX憐7    IDAT%u.ǭCpM׾̶^朁i^g=u	|:In|S˕Cwsr:
x    y n[?Ο?ݶo  iw}vdM6M{{$  PnW۩vzz%BM|7\׼ۺܟ˶7Ǻ-ޢ+#%,zS_=y/׼7<f<eO/qy޼_~\zxAk?o
>.ǺVc?7z<o#O!?A~=zA7?F_!u?W}sC.KXs ߯7zޜsd]s%-Ûm+ϚXj/Xpr:]r:rVKNS-     7m&))I'O$t (
d}:}	  EiA޺\.ZTN˦<1e(
   ._Yp:t
-H-     Y(E^3F@ PtAʕ+oH  V50p8t:pon   /0|t:rrt:	    P` VZHh4  _ҥծ];YF+V x  ,p\ D`-   n}6} x    	&H5ji  ƃ>5khTT)G  ŌaZn}i   %0`{Yж[-     ~okn[7n$oa  Ѓ>#GڰaxG  ѠCΆ[   mΖۂo	    S:Ǐ=..I  V\\ի~A+V x  $7t_3Gȡc   @~{O      ypI w-Z?;v=
  (  (q=       $66V?<	      P     *_tN:6O U&IJKKy  PXp2   -     Y8IOO$UXI  /x{e={i  @a   @&     p   _V      -     Wn  D           d1h  $-  ^   !x    @N   d*_J.-I駟l  \   d"x        )Ip͓       [     |         po    b7     r   @&     d     @^   D                   9n          o    b|     +W   2     '   0J2:	  H   -        &$      -     >dJ   |Mo     +      p[  w   @&     d  o @ W   2    3G   W!x      \-     f[          ȅ     (,oKQ-Z(11QJҁ
4  pLTjjj>222T^쓤8s.  (LG    -     ~ޖk111||"x 54sK7o>  ~   v                o             u     	      w\   d"x    @N        L.     v9*Ξ=K[վ}{5k{?~*T`  3<H/Q2ev3Ϩ[n޽$7/4e\.^xU^ݎ]       
     9nQ"\pA'NTzznU\Y.]Ү]4sL=ԩ$bŊf  \zz4t>4M=#V
t-`R      "x    @e:}FwMӦM'|m*<<\7Vƍm ;vhǎjѢurh  ٘   [     (-YΟ?/Iɶp[nopUB;|4h5k(==]5jP߾}O?O>/XGuԱc {Ç8+WЪU__~QXXj׮=zvǥjʕ:vLTÆ
+666{  B-   a       vh޼m۶)==_\\{;}z5j(ִiӔ}j2MSs	  pCCŋtΛ7O7nTǎ5bKNٳx$I;w믿.өw5aϡ%       h    %66V#Fŋ5w\IRʕՠA}jذu?vk*[$鮻Қ5k4l0I~͛7OgϞvg  ȣի{Z|+}W=~ճgOmֿ())IgΜQLL>#լYS#Fadv~zWb

80d      
[     aÆ:uJӁsN{Up*VJRҥ%I5ko$]t½   xܹS-R
TLl*UJ=$)==]?N:]vIʼN:GyoׁBC   $LI    x    %ir
S*UTJkNG+WԪUԸq\ %)""".n nNSט1cpB
6ݻW}?.˥jժar]˗ŋ	  rn  LW     PpD5j,Xpvөݻp6L Uݻk׮]ڶm[N:3flٲz5m4K.Fpϝ;wgϞE      (.    `EШQ#}oϞ=zZ
 :uRڵtlۏ=˗/K.Y}߾}$׫˫J*ھ}LʛsW\\\v      !!     YoK={*55U&MR&Mt뭷(--MvR:u5 P8NW_Ͷ[oЧ~*#c۶m/%I=zh̙JLLT۶mUVpk׮  `9S    @     ?
oK(+СjZf~'uM_0 R޽{mUVՠAtM6MgVzzF-áJ5kÇ3g/^Xcw     3o@    P̙)#ۭ]tIջV#"<!}͛ˠV b^W|mߢE۞  o\%I_MQDꊈPXXN  [     |4         u     ,      ze    [     p	      w\   d"x     g          [                    d1h     +   \v     @a	zꊉ,^Xʕ+|?A `0T~}/;we˖z<  (jZ    [     PDFF*222_?+%%E*_E \aVjjRRR>            (4  s82O!x^'      
     d1   ~NSxl  \   d"x    @N   \k%x  $  Lo      Uh?{wg|}f$Rbm7VmdAj׋r/AqQnTIDD*-Jmꆪ
g8gF&DBٞ#3s|Ϝy~      @%  3׷H      @E̷  t$m   Lx   v  :IRWW# Z+ @     XLN    &   hd[    X   *JΙ Hx ,  P&  
;  שS$Immm h
  e[    `1f   	o  X 93R*7r$O?o9    z[   ( .kS]]+b% h  e[   	 舺vQF-cN=l+iD @kxe  (    @7t2d۽{\|+yD    :	o  )olڵK/MnV      @E9W^8;;n hU  e[   	 N;|]m5j* Z8^  ʄ   ` @r\;~teN8-0*    h=   P,r	 Ёm9쳛\׽{\|-4"    h=   PQ2- @s[oE]ݻ xe  (  @H  e]t$nmN<   eZz      @~6{l:TWWp    U  @S \QMk\_*   Mx   : #+1].
p)   [   hd[ jmH}}}sߝ5R& :[~  (j   @ nR[[<|36M܅g   Bx   "  ĢmMMM9<pœ5mn~|ԽRSSՉo   谄   Pl @GLLs~5OIQ>1s[/N@f  e[   	 (4Ŀ䡫(vfEd9ɿ?^@Gxe  (    @趦&yxIf4yPCjTUWey/   a	o  V h皍n{:y:E6)7
ΚvIҨ[o   蘄   PQrD k.}g򫫞Id~甛5F
NǷSŷ С @   *@ ګE]LRo;e7U2G|  Lx    Ң_^Lf;eO2g_o   P   P,r	 N4>|3g٤9u;>j6-       *Jf ڑggS9makoŷ ٢ @   *@ ڋۇ*md~6S9ٗ.v  P&    vdR$٤zq:mˡ|;//   }  @- 5偱ϥHMW@t`>aOUu)s'     @E96l혿(rݜ~+,m[勣|;7woo] 2-   T؁ UKn1JtNμiΊnlwV9Rթ*sŷ 8^  ʄ   ` І5rR$MԱlwV9d)U;L{i   vCx   "  mR۱k7ңUTUWeδ{ŷ    [   ( hCn|S
,m[gh%;mn6- y  P&  
; b)"=ll:(U3N9- aW 2-     !E\7$Inls2TU2gs   Mx   
 @+v)b|D
9pjP2gڜϱSķ    Y[   (9g" Њ5N{|R$=X;߸qV6~ŷs?ޝ[ hSl Lx   v  Us/&=b"0m~<fp2W| m Lx    ң&[7F
/92E-    m   E. Z'={ƽEznvΞwߥLƷss߱[    -   T| "G/:9g^m&m1CRU]isc@+g  e[   	 h-n>sIlܧ[k\t`ɁcVf#_*V  P&    Vdi픫_JQ$solm̝[    Z5-   4r  -I/f/'Evy7~!lzKwmrSU]yǘ   Kx   %L ZP
/_J"'D
:h?fhc|1g Z[`  (  @H @KYztrRѧk9s.mAfooq2  	o  # 5uuuM{ox)w]rHr~;nCRTo<g[    Z-   \ "&=v7'uytcm~1U2oڜR|   @+"  oUh趶6555^ʝW"I]s
0mmŔ Z-.  	o  $ `UYjt;)ңO\;h;ܩsѷo9^  ʄ     
5rWS[7a[]TuʼsQ[    Z   h5 (5na)uʼiQo   h1[   (9g" --gk)JvECSU]䑣n*d  e[   	 XYnz͋2)JٰXt۬-.{]}hJU7uN9V- BW 2-   s DG/ILtFsAWNG   UKx   "  +Hsm׼ogR*ɻgDbVoɣ[    V!-   T| @KnzJI6f+]n>wX2o<zo`%E 2-   T؁ (ENx9wzR*GߛC|vyțŷ 9^  ʄ     -5zR*eM'u7m6C>wvN~s   Kx   
 G\t{˄s
oT5r]E+fvȞ㇧SUO='[    V-   T3 n_]7$k@tm6h|oqS
e
  e[   	 n{+7R*Uvݮ$
!{R3 V4+ @   9 >FLJlLtҕ)Uq   Jx   "  ˨	oRzlF~x@*wЎ)J̿K|   
!  oAmRƽ7ݮb
xvxdJUY0uv~Myŷķ b @   *@ UsO&'+Ry+&n[JA;fkLUC|[   e[      IDAT   XGJrt{Àj-=Ϡ5|   Hx   
 XZtJ)vgUx?΂[    >-   T3 Xۛ&#?VJ)ǦkGVN'4)o`B @   *@ |tZ~:Jf趕=嚣R[ X^W 2-   s ,Es_m7R)wOn[ރ?,:;[       E. *nn|;TfYsKe{3pэ3>5\|     @E̷ Bn'7FIkf502Yyju[    P&  
; F3vRJz]3#7mk'	ǤTUSg,p2  	o  $  y?O}}}ct{Mo%IlVFXt{dJUL?~ aK  e[   	 X8KMMM%}37L|;I?uݶ}[>=TJʹ9%E8`  ʄ   ` m,55573ڷS$Z%mwzo?ƙoŷ    ,   E.!Kmmmcx{Omd̨	;n۩އϿ+|[;mo   X"-   T| mCx[SSɛ~ԤHnfFn۽&aŷ Pa  e[   	 :Ӓ۫&|BtA:>5*6;=l 8^  ʄ     tHE7_iIl͌v8O;&)ۧF|   @-   O3 FQ_,oۢݎqmOW$:;vM}u-   @'  s&@6
ر'7Hl'6=3NgX|[__/C 2-   T؁ _g$I6lfG-IG
GΜtۆ  P&   { Ch.3~{9{u-}.o͜>^|   A	o  X hwnn7EFO1nY^GG"I݌yyo   :-   T| RsU6)һf`-koSJfķ tl  P&  
; i6f~z)Rw52E,M%;4ķ3ŷ tW 2-     RsqOo/Iҧ(e9mzԮ~1I]-       @ EE>Wkc$u3Ɖo   : -   T3 څQn/EzmrnI߾x˖  ʄ   Pa }Gog5t{mEk}lR*n朼tX-  Lx   @\t;r[rt۷mhw+ǷI%Y[   vIx   " @lt{۹YI%?薕ѻeK   W[   ( ڤ+ǽ[*3zݲ<zTo_vvÖ  ʄ   PaIrgT*-KL:uw=SNmt<FW[IޫnY%ķ3aWeֳoh  e[   \|ݻr??A6pÕ0" \t(ҧwLzk-TwW"IyU|   no  $ݺu˥^\߿;3  h$E^=7ni!==[rRg?   [   (9g"Ç>eouuuƎGnzjnsNo3DG|9E)1'}q6˖
  ʄ   Pa;vlt;SӿU0" EmQo.|D
{Μoh  e[   %ׯ_8㌥ާw޹Wш h.iɝs"{(=UhoGf   M  @%T{ݻw_z֭*@lt;~z~r$I]r8-F-~tl<>#   hk   PQ2-֭[F>exD SsOMwMRoSK/dH1cv^v6Ö	  ʄ   PaK2t2u]tرc[hD FE9ɸ-]tK_?:>Esŷ 
W 2-   5jTtg~ :MwKd]r6!MQ9;o~G[   6Bx   
4
4w9>sZxD Ң"fWc&mtٕǧ(/^C|   	o  䜉,9眓~eȑMf`k.yIZ[tKщ{')R?cN#% 2#	   myҢ!0cܹs~$I}}})-R/=q4^3375?)>=W-c7.lt^)%yuv5$ԩ>*ϥb	@K 2+	   m|3-z	mITB\t{53sHMV-cF[zt?q$?FLHy˳Ͼ*   h   P,rن4D
= !]_UUUJRA\tk)G)G雞[ڡr|[S̘<ŷ       *Zhp[WW,-Bkhl[UU$iooi'I\-#]~)%iR̘0k[ Z"mA  Bo  -&G7j~WRQ"OUhTJ.HU뤔t2/f?җ/r2IJEG_QY^)IRW,啲i5Y%,?u.U;l]at E߻LkAR$}zvOMύ6߆'?G\bL;䇉V  /%   AKv̜3Jߏ*JU)Eykr}*h)wrEnBqf7}GY~u5,h,z	ϟJw7ïpUY,ܾWWY(~>MW_W^.|YUJR>
qxQT*RW."3gq\}k>}77UEn9?eÓN)E^qM3˒      )ooE_ER!(ǎ_.DESTn_
ϳsƽe_ͭB[1ݰ\{_]{];KoNR.Սqڧ^nnkAJ)GtKI$I^|;t-   @   PZg}?NR[#VO(!&ڗEI9_[tKI䟧ķ&C|@(  @   @6Iå\V7(h.΄r5IQOιCtIO':1E3fgf3&}` @   𞣆15mxJy?_x6g}Yjt{Wy=;Ϋzna!럴o6io̡[   "  b6fZ)K^0Ts'uw&Iz;ǈnaII)R$3f-   @  @ELnV]x6g[jt{wm"}zv]c6&EМN7=G}}1+UƖ  ʄ   Pw m|^ ڥK&ʏMJt{&[X띴ozJyO|*0_  (  @{8e]a=Hơ=j>%I윻E\~6E2}Vf
^o   V	-   4h7MBY:"
ɸ/EOkԦ(>=:eU=E!e"I1cVf
   `  @ELnVڃE?.)>=;-|$.q+3fgoXilI  Lx   mR% zEMwחg93VuGJ{9>;sķ $ 2-   =GE.(E2Ңk')ҷg;zc-@
xB"Y3ۙ+[   @x   nv"t Eq_hn5qn&N)}{tνfߞXfƬ{Z|   	o  n&m7+BmQs텍mҷg7zlҽ:#gX>eƬb[ V[  (  @E߁T{hnDIFm$U`'?Nf`p$  	o  h׮0ڞR$5^0q^&L)R$ս:?Q6*!YL/    [   hnv"t Eq_h+n	)dQE1$$E2cVX|   o  n&m7+BmAs7kpkbԆۣSK:O/ǷEQok_$C  2-   TH" 5/G)[h>4]GR+Cr$  	o  9*-r;hPdڂ󯝟{uFn=[zFEӇf˿RNA   |H[   hwŮ7/ows
7,w`\veyWXY>z
gw;fHC2n~]in,X]"ս:@tێ0`@<ez9WSO嬳Z>B0k֬\~<xpvmz衹R[[B<VۤHiƬ
V?   `99   TD`ůH׮]s94~_EfΜ/W^ye裏^M:57|svq>VkYc52EM74;wnQ_Dhw&IJE^UW/m&O=z䢋.Ji?<=cu]Www_^۠._3䤓Nʖ[n5jT׿{*SN);gMՌR?[Ypv%I:u纬?c : Mx   m~^bMݻje}]aÆ_b
oiv횮]0Vaˢ(ۚ|\RJ)g>C=4ݺu[ϟ???xN><'O<??CI80UUU2ulᆫ|\k~p3Ǧj05Sl۷>.oh`   eU-=    `i"VݮN:[nkrSO=|+mݲ{s[o$y3x$ɹ瞛;N9|s˞{:Luv[/oϞ{+/r;|k_ˤI2hР0 ~xz&z'sꩧf=̀rAe̘1aEQd:th8 ^zi̙~wyg?0 _F4~yFnx8p`=<sy2lذ9ꨣ׿uy2z|0`@cr)y駛I'w={w?L:7x#\pAo|3^{;/3fhw}w8nor饗f֬YK*5
3ե&gɏ/oozuC-q<Ç3tw}yr'f]w3eʔ&}7sy|vuלp	x??/2bĈmۅ^o;３. oaÆ妛nj\˲5\:(KN?~K~dIF:Ş9?xv~G?Qw}}n0 3gl|}xӿ׿n|;$gqFLW^y%<Lk`|͞{=373}&Κk#<2{WmIٳg뷲uYSRHixAjy%K}}}   `I   Рݴ+~E3uov}\zyg~5''\r%9s-'pBf͚-2cƌIRb$?O<1;w\ys^k\ٳ3az>|x-&<HooN޽sgNo)V[-\rI~3LڥG&MʤIrG檫;3]vY}~/ζn+"w\nWe=yskō	rf	)b-.mݖ#<2#GWռ9<Ѹ_?!#FH}}}͛O<1<L<̌92Gyd|ƟI\yַO}S:*sON9.uS_Dh7okkkkjmQWZLf%\38#7|s6d\x9묳rae'?/q2cƌy'rg{^v횓O>9_,K..쒛o9~x=??sYgeԨQe]r{IۡmDÁ}YlAڏ,ɲ>ߒ<ce]R*2tor;{]we<A9dMrme؆1ַ#F׿u<ۗ彳3Zk[oM=馛.טVN?8k_~Jy<~35ϼ/<5       ֢Ewů̙3ĵ
]wݜtIxȑ#f̘1Y}Փ$ԧ2dȐ|9ҫW$I+2˕W^xJdС?~|.$ImmmN9tAMRWW.,뮻nOC={,C3<v!ӹs$ɮ{,O>d)?!oy=$ɿۿe5h}L0!s&)Fz7n]?O&Ijjj|'뭷^d}
7ܐi$_җr6{g̙1bD9&~7of6t\}իWE袋/&믿~=/IO&)wM7#Wl6gx`"Bpt0][?/Tٴ{u~uY+nN;-Hq~!CdNr){׿5zɓ3ux㍍.9c2z7q
Ó$zʯ~<#9쳓aÆ5>WkfuIeM:5rK?r)Iv-s}8e~dI7MF$lͲN;eʔ)6lX__לxIxӵkt9m2=fa뭷^Fݸ믿~:<#c=`֬Y9묳=GNN-f3I2묫S5}V?/~;U;n!`10	  o  "+Nn2rȌ92    IDAT6duW\N:13gNd=HNR[[ڬzaK\ԩSꫯf}mld
6O4n26d6)2I2o޼$СC3qĔJ+yG3q̛7/555ͮ?<39ruǵ_O>4ommmN:5Y7޸1Mc5;Iҵk$iv.]ꫯ!3gsLGy$I9瞍mR|c˶nI&_~y7[n?z<S_,mݲ:OSоET1[ǭ{ۇ%myKw˖[n-آwQ}?!o|vm6`̝;w97xc:g?oO>9[e=obp_/vy_E}m{y7|!C/K^y$]wݕ
70\+?6IM|sN7.;*[M>"EJ3fvn   n\q:w]v٥=#sLN=\wu|͓$N[n-ܲr6d%.qlbm@ݻw_~Z$bL2%ˆnw1:uZjTrGd]wݕ1cdѣGN?ޙ9sf4xz5\sYt䷿m<sܹsr&{ｗ97|sL:5]v6lxw4sӋ/RCݒ;/ϠKykzreeJ9`@Z%]ؙ3g7hvQ3fhv9RK.ɤI_"=Pdvȹ瞛jC
ϷAIӿ˻]dQv۞$>hviƸ7I{\ve{rI'{A<2-Y*믿~qY;=zhg.6l!3yTJ;|ZzH       VD-dk.({l?\Nnݒ$Æ
{\é0ߴin&i2޲Kss޸!C,qR)CСC3k֬_ڜwy'?8C矟ڪu[Q^}՜yԧ>n)[lE:u{qZ+UUU>}zE~8o}~.GaÆeM7M\tEyG$kve7n~;;
[OYn~]lR8oAsޚ~w;֭[6`|X믿~-Ӳ\s͜|9oGs[nYPӧ7O?(c5`W>?ϴi2hР$ys@]]]|!9s,v̙3jY^z$N;1RuyoSUJٔ{|K
   իj   @k!ZVjլȶn;,>ln$I׮]ӯ_<fmve[o	&׿uqIgp
ӧO?o2{6ԧ>x|4hPck__ꌷ'|ro6^{/˩[oO|ԩS^znk+ȋ/Ǿ~:,::~<oΝGi7I?欳/'|29Sۚ<䓍iRUU}Ѽ{'>B׭"BQ*R*RUU٨[Ξ+2!7?/R6h&_fɍc?Ȍ3~oO#vX{Im;;sy,hzY+ʇ}9sCvun:th^{L81ǳf%Y
36I`<SMrqIO4ςO:wkWZ`S[_y6$TWWw 8L  x   m~R=sgر{ｳNˈ#rCIuuunÓ?{ޔ)SREvi׿sfĉ	'Ǻ]wݕ*/bƍ(2wf7p|뜝Yި,D_(?"B"DI~D_xRwIA~7{	k߫"콳㜭%`9]/vv㵝K{9]|j޼;^xA			wܡ%Kvk/(??_7>KJNNfӲede{=[NeС9rF={ւԬY35o\[o^;vѣG|r)**J/+"ϧVZ)77W-RrrR=6 KQpgfqtkp8TOg:IjjSo]|;CڴikСIue瞓VzW_iڵ$wS߾}l2Iw˖-zw%=	\[l٢xկ_7KIIQÆ
}vM47uj֬
jɒ%r:RVZ%P4::ZЊ+ԦMիW/ϓ?\,Эު?>}7okFٿv6lؠk/-hneokygܮ(C
o (3   Gx    @(#n)J*9ry=쳚:uZlkѢE<y"""cZǹ;Cߵ~uIڵO?ŋkĉRSOnݺ=>(43ϨPuQ߾}kݺux<ofoW^yEQQQjٲFU|{Gz׵zjEGGy>|TxiWf̘EiZ.r-YDCg}lR=͛1cƨJ*5bEDD{:x}]k5\ݻ.p̘1UV^7xCҥRs ~To#""d|>?+cntLC,Ӌ/^sΕRݺu5~xk?-[G*..N{СC%{p8[oiٲe+4rH=ӪT$u-M|ȵ^<uW灙3g'SO=hC]wV\Y|[nEzzyt뭷*''G]tTǎ5jԨl_;yyyڴi|/hGTnl>;69##8MxK|     [GK    0c^<\.


4aO/9|]_,nA)<
UPPinY)CߏST$;wjĈ뮻#İg;|g+**JQQQ`4;EBrX%9f!1zHŷI~~t5(..˗/׼y'Jƍf[\@~\m!okyTd -ݺgο  I*|o~i$ɵuQTTT  Pϕ     ,>Cas 8O^W?^{z ʣov"""p8)ө#ʸ|]\'TIGϭ.GINS?|A_^[n˵pB3|-ZH<rrr4` G8<^VI\gn)* @I   '    PAy-*/BCQddnf%''[=dL,oO~miŸ|
}7硣Z5:^ڡhY7oϟYfɓ]n
8ΛԚ5kv5qDկ_*W{>*׺n-; N3   Gx    @جܢ1bd(ςoW;HQ>#,%%%iܹVqAvVQx:s
maH}Z˜>     <7     T$aQl*SE8_*m6v"##t:Uv.f6'*&=mC}!     (     Oc6
/P߾<@WmD[2]}/S!wV- <q$   Gx    @@/ au/ 
6}iK1>zLxDiķ@0}t*Ir%    -     8`)8Jo'η&VږZ<9LGu{T2%Ðo+     "[     M6
TQ2Ʒ/N(T|5|{CGot{uۣOL2$O[         i@P!Bŷ
>g[ԙn[CT٦Jt (U\&	       H)  \xŷN|cmjﵞ(۫E;ʐTg$ :   -     ardrC$@(&W۩܊N|ՁӔCa{ssg3*8      (E     Fas @L%~PT|[ǩ%݊oNN[<9LWvi;$C\n[[     Ax    @@4as x,v?-	#[ଘnOɴ2$nnYn I   ~     v[ BP<|K|t{MqtkwUr  g       pQScd'AǷ}ng`      -     E¦Ab(`E|;> -;LW_<C?[u+-     @#      |9TH~pl|poM
Po9i@ng紝D  p$   Gx    @@/ d <M|_ݔ#J0^<S'v0$r ,   #     W~+o~*$C$%C!! <&qoRۧ; Egͳ[uRQ3     X(     \o[2d%0l)4eȔM0M$.q2Ӿ&0}Eym&Ik3M̿%-}=~_q=GyD 50eL,oO'`KfHGquԮe27;W(jf_[          BQKdQoqi3$EQL?V5LG%#֢ϷE/y~/|{y?:_ߔ3Cd[)=ԯ)/Oɯ_|~;S?f=de~AǷhȏo#Ebwy.y[3]Dt )        P,6-+dw=#+|**v15%*I%wI/SY?Fm=y;\E{Yߝ4=%c~|n)U</מ=j%_c`֐f(nv
Eool|;/;iķLW_v0$4- ri    ?[     BXYCR$'GLMJ	&P^GB!n=/g;ç~Ӓut]*e<-PvLW9=+֌     !    Hmy[rТdp8wʳSwn.
b" +
4rW?3u׸<-y"E'!
Uћ     !      ScxdtK|d4dي_E&([s
4jW?].!EX1^}qtkHnD G   o    (yjQlQ(D%%㡒.1P1>;@{tGSwF/"Ln{>idݚ
-        +G%CMpPT5|-v6;7ݣ~iȸKoi%^D      -     )!ķ%ZP1^ZGzfRc5WTetO?OdHTD      -     0.   :ZobLWz>.a(k[ @g*dh   PNK     *  zEaaQ|kp8p8)өKDը.}\Ot{:aޭ B g"          PΝ%ۧ{[{۫<}.C[L          P-o (7oLvF5Cnacķ(LW_򔎭\nMn     B-     4
  /ƷO=;omɁ_3^e-0Dզ$ W   o    `	 '"=Sߢ(n?-Ð]:-  qf   o    ` r-6J
ݦFߢ0^e?-CEm[     Fx    y-  (w*ޱ_i-,bk~\[EvkX[     Gx    @   [0%u.S.Rl5CnC|2n֏d"En& 4W   o    `	 /)FuCncs)œ0^}ihCrvj  g*          RoRI;ߎt[\`۫]яdP^J1;-     @!    [ 2ogOjnF=%-.^ǏdHt!
:_poNt     &o    y   Njo#`YQdHN#SRNNw믿& ,W   o    `	 l|;sjVǷ?M|Rsy:QdzjϾEK_|QWVRR$iݺujҤ&L|[ @         !-vJtq|;W1'G<3:I.ꚢ&gTN:t۷kΜ9Vnx	%%%_ir     @!    <  ۺBS&9<3q^IMt9N5J6lv:;SW\qlb      l    _  ֭{fLVl!ۧcg[ՏI?=7mDDvP54|޽[m۶$ܹS-[TgQ Ǹ^   #     $  B_pm%Mc"h>GoyVG7$U꒢gn'IOoAW_}U5ң>ˎ
 ?   -        N6}3f2E|?syNnݖԣGٳGfR*U)SQFz      $[     -  a#ѩUU8K|P)umө+J    IDAT''G
aկ_?iF;w,     @Po    &  GbT=&ۧ|h(o|.2{=6aܵj=ryE%]|Zl233բEIRzzJu]:rȅ<<     -     ,  ~omj옽L| ˣI*wiڥݖtUWiZbԩ#ϧ%K(11QO>nwi  Aze        V  kƷS
};m<f䰚?6wҥj?rnK0`߯I&)**J?Ǝtt      8      l|;oܷGۉo+,ˣ-!UϪSmJ*iڴiڻwz%IVnԡCݻT      g    Rj$  @9L|[J}?Qn3*<kl/Ðoj\mI			Zj6mڤIEFK9 8W   o    `	 Gw}nݺiw'UXӃvV >GEѭUg}%mI[֮]pBSbbϟ/{A  W   o       ]v}͕$=8v[OժTi,msy{lʖaKZl2drrr4zh91b.rmذL      o    (  T%9rDZtF:u+i5T-֦BW>q\ޔ-Ðo*_mIњ3gԹsgI޽{uuשGꫯ|&          	  `!0tRuU.KUV?O[r:S&=ZCbrHpsyoVҩet[RRR{=)))I[oq?~N<i|    -     ,  PL8QwuLT:uyfnZCD|[Y=ZCիUX8۰sy85Td%@t[Rg͙3G111r\z԰aC-[LO W~|   o    ` 
vO>5k$YfTrrl6viۉTM.WGҧ[oCѦ>ѭaM0nDDDh/5dl6:tHTmٲ     -     )   l8qB;vԪU$I:tPzzjժ%I2	U-֦BOFgķ!hc6FmIqqqZpvڥ֭[Ko߮-[j:x     6[     yC  S^^Zj
6H>@*UŊiHPsy}/%M>ےRRRi&ZJՓ$+jذMk W   o    `	 𕕕TeeeIL+Vn~gVnЫ	#w賭Gpn|%[MTjxE%K{մiTreVF[=     (}       ajJn׊+4u߽0m5~T].&߆_Gz7})vJǰn8NM4I0`_}M6ڹs#     [     -  agժUرN8J*>ЀyƷIb*tA|[n
=>K0TԠD%ժUK+VPFF*IRzzJ}:r          QS  $͚5K}V||աC??k[3rW'}I3-EԲeTV-|>-^Xzꩧv Pq2   Gx    @ H  ϧkĉ2MS5Rff5kv֏l|;vzMTЧI~J|[
=b}KIR8CnA);;[ǏO?|P)))Zv# ʙ>3   #    #  FAAt颥KJZj-[(!!3vF-|ijJp}g۔#0{S>Lt[Rʕ5k,۷O=z$eggk׮С-     |!    <  Çk/I޽>cĜc>8bb*tyO2mzdHo$#			z7'(99Y~z5nXw?n      -        ,(55U۶m$=Zk֬,6SzķzQߥ.=Gp{ mVwּyTF
y<=JLLԂ `W   o    `	 дm6]}͕a?̙sA"*3bUi
mߋ:)G].eSlv
>\9999r"""?hjҤ6l`  p   o       !׵^Gtj͚56l}`Zu聙u;ߺ:bmz/76TҤvr:D &&F>>so^뮻N={Tnn     =[     -  !eҥ


?Xݻw/6=w}dxv^0B>076TnKArr;aÆ5k֨QF0aN<i      e       BǸq4|p|>%$$h˖-jժUt|;n`@|HYQ|o%CҵkWٳG?V*˥ٳg+))I/L+  _y          (n\ԬY3effQFT|{I7n`[A|[cnGq76Tvr:Dرcf;-[X=" 	         !رVZ%IСo\AǷ3/Q6b+m)z~/`W2)D%On@\\/^O?T-Z$m߾]ZuA'     0o    0O  N^^Zh
6HN}Tœߎybb#Tiy=Gt +Ή3mkڴ6oެW_}U\rLʕ+ӧ     J-     4  OYYYJMMվ}$I>,Y"ndl|;r楪k|;|9zAu DD~~M2E]tN<ɓ'+99xj @hze          (ԪU+:tHv]+Vɓw;3AUcr>|3Y~u02)s5ܖԩS~O>}M6ʲxB L
          ʥ+WSN:q™hVuFA|;FӌO^y
Z%HdHwJT$nݺzWyf5mT&MhȐ!:r     .[     -  5p@y^լYSСc-%U4bV=Ua+{'/<nZa
2ݖc-Zg}ŋO|>^x5lPs̑zD     Fx    @ M  |<x&O,IjԨ233bdg|{Oiۗ]7au$P`l;V:~ƌ[ Aze          V~~t颥KJZj-[nݺOvo5<zfݓO7xSѻ_̯֡%CSmȉ?/B]v$߿_]tQm 3
         ;|Zn_Իwo}Ǌxl|;lv}'Ff3[y
<z:Ϳӭ?65h@Ҕ,IZ~7n_ǏxB     ?Fx    y-  (S999JMMՎ;$I>^u9N'+=AǷ%*&.B>*||)>/P7	mh߾vޭgyFիW3<
o|>#     -     4  ]}͕a?x	Ǻ okU=5PL||^SOWorFQݶ!
3v]Fҗ_~Çnȑ#6l4i
6X=" W   o    `	 o]v:zf
6.*:;Q1q_lA'/;\3C5;WS۰yij۶$)++K]wnZ<! @8   ~       2`C.KڸqwnXe"v
y,QU
z
<Zwn˓aթ>Dt[Q$''O>ћo
H|M5jH=N<i           -o (cƌeuV5oŷķ
Ԝ{:-n3$TOj#g趂ѣ٣YfJ*r\9s/4     X     
  .,˥>}hΜ9͛+33SOfŷo~bzM),[OGo]nkwf&NƏ
4Ha4hRSS}vG
    ?[     X@ 9~ڵkUVI:w7*>>ɬl|{cIw瓞I;6x)huߕ:-O2Zt-.b-[LjѢ$iJMMmݦ/D3/   Gx     +G  \PyyyjѢ222$Iwy֮]('+o/SLۧGl0o=l˓!
tD[UW]͛7kSLԊ+3frY="      o    0O  fǎJMMվ}$I3fВ%Kd钂ojW/|7o3dPN	knkҤIɓ'5i$%''7ްz<     PM     h8  (]iiijݺ:$á+VhĉVUnK(FoQY=Yx(5tHtTTIӦM޽{իW/I[mڴQVV@xze          (=+WTNh}0`cd|35MЉo=v[CsåjNtsUViӦMJII$I&:t9b ^8   ~       R#hzY222Զm[
)ķxwwF}7V}FneVD8/[֮]pBiѢEjذΝ+c          P-o 8/^WԩS%I))),މg''2}߷\Ƿ^}+CpRnQJl6=ZCǏ</\#    0Ax    @ M  .??_:uʕ+%Im۶UFF֭kd-vPv}Y9o=ה-Oa
(ubK[h͙3GYYYj߾$i߾}馛ԡCegg[<! .W   o    `	 ssanZiii޽{?Tttœ`۟h^Srz
<zoe.]Mt,))IiiiZn5j$IZ~RRR4zh8q	 pf   o    ` so>jǎq_xL|{)+mԆrEy۾n' E{n͙3G111rzՠA-\P>    @!    <  %##C-ZPnnl6ϟٳg[=V:s|۞lxLpkxʭIpZ=zK
2D6MG=ܣ&M(==    @!      j׮?(]VÆ
z\|oM-iM|)heUnj[X*..N.Ԯ]ԺukIRVVڴi^z)77	|ze          ܹsգG\.jƍܹcUgokԎ'/Wt|L[OG+m$ХUK[#)))ڴiVZIիI&)??	|L
          bx@i*11Q[nUͭ	&;߾0,ݮt+C	U+[SzҾ}4m4U\Y1c|r&    "      .˥=zh͛k֭JLLx+S	|kꅑk燹lOG7E
ujB*-5өI&);;[a:pnvjV     [     h>  8G]vz%I;wƍkd&J|Lޏ}ݿK}wG/Sl; G׌'EUVX]uU۷+55U~<h `=W   o    `	 W_IҰaôvZEEEY<6)oD~Uj_n? RuԚ!EԲeTV-˗+))I3gΔzD gn        V  8;v(55U9992Cge&_ o?-]dHw}ߜ!0
4H?~NN<zHzjG     ⷣ       u:|^{57oi*NIKߺ<zi}$C6D#+W֬Yo>|͒իڴi,'     V        KSNWtt>C`>s*:)SK?>]Ѳoe__[m_Et5kO>Qrr$)==]M6=ܣGZ<! 
W   o    `	  zUn]eddm۶VL|{N3EGJ|lmNЏ.odHD0ڶmݻwk޼yQ^.\D=x<V gr           ׫jڴieff*%%p.oPxLT|.ŁozqW*nÕ#G*""Bǎѣոqc_    Fx    @ TP'NPNrJI]322TfM'8S|[;Z[3ķ|[0kZ[TP111zg矫}luA7t-     \(     Є  *CUVJKK$
0@~-!+T%>Rq]ђ(w{
[TxJKK;Ｃ
J{=Љ', J+   ~      hۧTeeeI&N+VpX<Jә۪eo͢/wkqQt+C
:#~k׮ڳgqUZUn[sUbb-Z$g p8   ~     r 222ԢEfiɒ%1cc	&9JU8ߎJӎ_0߭EQC2Ck--pZCcǎUNNNl6>|XCU&Mn      IDAT       `r @[jڵkǏRJZvNL|cUazeTCjx}-]7-pqqqZd>ShB6mڨw͵xB     p>o     TO>+˥xsV2rF<%_!)j7N[ XM6͛ꫯK.$JNNɓo pv^   #     $ @83MSÇرcef͚Y=ŷEQm:1lUyjԩڏ8G5e]tE*((ueiŊV AL         @+((P=`IR͵uV%$$X<rp(22RQQQ[MQIU:[,EEEiԩڿ/IoumiРA-         "ly CGյ^~[Խ{wmܸQOηEխ6wW;:v[խ[W+W͛մiSI/D͚5K.	        @3 7ꫵm6IҰaôfEEEY<ʋ?(e[hB}/^,I5qD%''7ߴx: 8=W   o    `	 NmۦT0=?>$~ۢ (f#Ja<xrrrwaV_k֌(R
'Pюa)PA<ߤޖlӶY24̬.EQD-= 
ܿ?82x\fZ{=
yޟO$I|vao2sO2? Bx   V an>7o^8guVǢ[1-oV
ocȐ!3uNIӧg]wĉpO   Hx   * Ѝ]}9dɒ?wygƌSVo۶ضmֿ8 >`⊼oOKKKoeС+R  o  `9
	 ݅^	&5}ݗ#Gz,Uw-trI&˩rfҤIu]3}ZbW 
-   TY@ZlYƎ/IÇϰaj< oƦn+2>`w$̙3~C?^	7  P!    -Z:(?$x`l5jv]wݕn)CI|e]rye5   z-   - ?#G.>:zkW X=<ClYti.:4_   ,[   *yD 3fdwό3$_|qO@Ghlly睗ٳggܸq)Jy2nܸj="I Bx   U .O#G駟N\w\r%Nkߟ=3I?)#G1{= Bx   V FntAYhQ[o5ǏX t뮻.
JQ2t?s.]Z  G  @- tQOYlY{'x`><裹袋ҧO,^8]tQvy?x   o  d[ L0!~Ȱar=yOG۷oLYfe̘1I'x"vXo̘1= Bx   U 芖,Y>8W_}udȑx2 o><I2})xB;s2  To    f}-ܒ$=zt߿ƓЕ_o8p`ZZZrUWewW\Z   ݖ   .dc=?1Ir'禛nJccc';	'ٳg3HCCC^xᅜ~u]3mڴZ   ݒ   J3.cc̞=;R)_~y=%? XG_3fcXd̙93z<5.\  [   @Wp-d}ؘn)gqF:th~_fԩ:thw9{n/^\	%`  P!   +G tW]uU>,Y$ϝwޙѣGz, z8 =P.?MMMWw1\sM%   -   @
wy9Sښm6w_FY sg	'<?~|   e	o  d[ j`ٲe9#r饗&Iϰaj< =݀o;_{'I@><s5J\  [   @g[hQ:p
I<0sOX Mv%I~fСҗKv@Kp2  To    j駟ȑ#3}$s뭷o߾5̙33eʔlFYxq.Nk=   t	[   hc[ :Ɍ3gƌI/~wr\ sEe֬Y9S*Of̘15j]   [	o  =ӧOȑ#ϧ\.Z +r-su{$=ܓw]9餓pOt6+ @   , ~䠃ʢEҷoz9k= ՞{?[5;Fk="I\  [   r@';6˖-[l{'x`U*rqe֬Y9ؘ_|1'O.iӦzD   4    jX^5fc=#8p`g̝;7SN; lFtI<yr~e֬Y9sF$y饗d6,ɱ     PU-@ښW^yS5hР4(sgr\ nmnL>='tRfΜ_ri_B.]i?gWշoߚz"4     @Wa[ :ĉE o||[fm\ve:thZg[        oJ\)ٳggҤIϜ9s֣  @  @[  )W\x p@  S_   (yD  dvԩS3uZgE     
oz?O뮻SOeٲeyߞw]G>M6d=n;vl
]zWOK/4;S&O*W;>C73<3Æ
K͵^E.EQdwτ	j2n Bx   V z;#?vl9s.o$6lXjO ̙3swg}}n69묳Аe˖\.g0%   1[   (VW[ָߞ{/<wyg9$k5& t[na~d]vy݈mo{['M   o   Jvuŋ3pzذaG>7|=n;vlΝ/8'NwܑYf1FA믿>_А=#~xg< >Ooε^3<s+zGs-'HSSS=3rHr{7wqG̙
70}{3z۷^:Ei  $[   XΆ OT{{'}l6ÞO~ws#oz~?o[o޺_ t9niƌ;}hu]3a$[nɀ2jԨ$O~~Ї>ѣG/~<9s:uAo# 
-    ЫyӧOOo=lA]w5{W6hv{.>׿uj|cKl뮻2{- U5*ӟrM7evWl9S__Ymf֬Y5jT,XiӦG>[lEϧ>N}m   .u    [Jg>}k9Ӳgɒ%s'hnJU__ζ}k!@w1v{^Z[[WQX/4559I2{촶f=X鱻[6h<B   x   U%+555e
6lÇgIg}6W^ye\r%k}|ccjkۥ 6,cƌL6-
ZMMMs)ϐ!CR.gIM6d߿]I  -   ,g[g4iRΝ׶j92sISSS
gԨQ>|xn~G?~y׾|+9餓ҧOh$/j/f7   *   `z;ߙ$Oܜ~8ni6`Z =رcS__g+}~֬Y~^{-h͛(*JW_]   :;  b[ z-2Gs-_BwgM6g޼y9j=& (niƌkvov{'γ>)"K.Mlfo2mڴE]v%s/~l61bD-^      Jv=lv?!j6p7n\vaZ ={?yӟtO~477g/}ZZZR.sGdM7o~L>=lIFC9$


5|UгA  $}Y   ("---innҥKdɒukڐ)k^$_ҩ4hPbN=& ܹsSO؛oyzz_ݗ?~Ad>CO>ihhH\N]]]Jh            o        !  *   fW 
-   TY@   X3+ @         o   Un      ֠   @WQ-@R.3|u~G?9ꨣr%c7`u> tG&lΏ{|$Ir}{:?GCC:?x}Ei  $[   XΆ KTJ>}q<@ylo ս


yg$˖--  Tz     ^HׯƓ @S_}k8	      75IR~p V.RI   `̈́   PU   5bxk[Z\v  [     P[v  P!   +G   ]B}}x  @W$  b[   jbo   tE[   *  Vo[ZZj8	*+ @   ,   V}}x] Bx   U   jav  P!  *H   U.,  P!   +G   ]B}}򏅷   tE   Un  R(Vo/477g9j4      Jv  ,Ȱaò`O'o馎
X"4     @Wa[  αf.[}ΡGt  [      Ӎ7.''  '  6  TַN<9;sO     @U{&  tgʔ){m&^xa'L Bx   U   :ߤI\zׯ_'M Bx   V   j\.;N~3L'O   k&  b[   :L8qϗ\q5   Lx   U%;  ̗<xM81;s&Vze    @$  xo~s)Sp"`EW 
-      %z=zt+_JW   `e    [  7,Z(ƍ(   -   Tg"  @MEvРAۗ.IJ5W$  [   XΆ   kWvV  *   `  ӭEE^Z
7&IR*E!  j=    \-   jඹ9Y`q3񜻲lYs---iiiIkk  @   l  ݶ䕅#{)gRǿ82)_WWg["4  -   ,g$  bt۶msss^8םtW?R%+%$E>OHCCJ#
  *j=       )]lY^J={(3vϰ}I<p?.MMMYlYZZZښ	   Ɏ   z-  @Xkt`qYR}--Zs~Y~D|tޫ=o  lv  *   _{NO,JdE{ewKrw>nz2^45--Ԉ2    @$  '^IQ$^4rytfT_M|5ze    #  nd$EɋF惫Dm
eI<'#  f   Pr  [nt{b5Mɋ>kUn(g~mG~dn,  P[   *  -[[tyOȧ.@}Mw۔Joŷй|W @   ,   5E=NvuzrC9GqmSJ诞mMB'q2  To     lm;'.|%E.3ctۦPΑyHvw$]|  @'  @   oJ{Oo!mSn(~ߖ*ϹC|  @  @U{&  8wYԫIp?nrrC9Y&v4-t E  P!  *H   립DI\zn۔wGg}K<~: Bx   V   Y{/n`|h=Gm
QoK۞L  a   Pr  @ڋnu+mQwvY
匹w<yۓz[   :   Jv  x]EW,xI%=c6rlIJy'3M|    @$  -}a|2RE>sxN:[%d{&  P!      ^W2ג"M1uXk$n{2wo  X   z+  ^q6ɑ?(mSXï=mD<[   -   Tg"  jڋn<-rA
I*a׎6{oR*][xK|  @   ,   Nc%-uHtۦ>vLƷu֭[x\  [   r  ۯzI$G]6Gd뽷MRS~<ŷ   [   (V  ڋn/?ϙk)"co>|;k=ns?]oK"}    IDAT  M  @Uη   Dk9z-)-6Og&oķN|W  @   ,   ]{e9Z$9#릲g2x$O6;I|o Bx      ~ɼ$)ryvmrc}FWR=;-[   0-   
  RFo=ZR94mSn';23~,  7Hx   U%  Bkn{5I=;zXC;*Fmgn},B|  @   ,   M_*mQdyzHtۦX;*Fm홿Z^  *   `  ڋnݦH%=gEmʍuGgKJɳ~,o  h   Un  zvۉܧ&I>c|j<m*7?>IggB|  	o  d[  Xkt;|y$EN%;k=n(7c?FmRgoV 
-   TY@  zE,ΗO}mXl9jHJIuV;iZT|I\  [      ڋn`<4Es.T/n۔j|,  `9-   ^
  PE:#4(;y|jʍ͖OJ̙6;3-   I   \{&  =ڣWSgdMI7yˣ6W̽cvt^Y  [     4kny5ISCRʍ9-M%^  P!   +G  @~tPYȸӇpseQCRJ2wcӤo  z1-     tsE4̟ӔEƝusw!R2ocD-  @o%  o 9R$7yXLRqrc}ƷI)L^Y
  [     twEOys(?9bv]wCJRM},3F- Bx      =@{E%EDoA>ηd[  ^Ex   m  T{텓tdCznX~4!cdYķ      J3  ڋn/FI	nחrc}фcSJ2U|K, 
-   TY@  OysgOό߮(|GR)Y0ŷXW 
-   X9  Ny7HϞ.(eਡIJY0<   ф   Pr  ŭ-;՜{c;ݞpڎ9mk=nVn>?\cJRN}4c-  @%  o nvviNvvrc}FgǤ,Hfoa  P!  *H  @Wv9ǫ;VۣDX|B34Iߞ#-= Bx      ڣri6IN4$GMʍ
٫ߖ0<$  Q   z'  Eݞu;%)8i{m23`wTJ^:3[  Bx   U%  tAE?̝Ӓ(rҤ!+ygR^}ffC-ݚ  *   Pe	  jڋn<̙ۜ"EN>m=~Z
22CS*䑓ŷt_W 
-   X9  3N2s4'Erʤs8mWTؐ=?m)yqyo  1-     X{˜9-)2i3npǥ+ŷ)ũ3׉o  )-   T|  tkn}՜~3gNKԉXmPק!{\J6;SJ33Y	  [   @z*lIJj-Z$9sɓ'xz g>9s[BtiןM?8,RgK|Kze      b뭷%\Ώ0`@L677c3μ-)"'n
	u}2S>Ò]}O|  Ѝo  L V0iҤ6lկ~5렉 677^ig>s[RȤۊn>
y
+;ߦEw>ٟF|  Mo  =XA\UW]gܸq7 =ڣ2g3o^s䴉dܸj<-C]y%d]f-]  *   Pe	U9^~@ۉ6s絤Hrĭ38mORo'U۔izm@|KWze    # qeeg6lX'M@O^t{j5MN:ǋn{>
y
)$H  ti[   (V0 SLY׷z\xᅝ8 =ڢg{-|̝ךEN?upeǥi{n<-oN)W''|7M-  tA[   *>#FkW\qEН>ZSEN?ukm/Qק!;%R^kf6j-]  *   Pe	)˹ꪫR.Wѣs衇h* ۓϚZR΄㶨t>
y׍+;ߦw>.  P!    xF'.}~o~ݴݞ<M8u趗Ӑn՝op  t)[   hc1eʔ0 Ird뭷D tkn-[g{-'=7s浦(3O+4d}p示SS|  Eo  =xW6,gqFX[tg^	g˜ySg}G+Ӑ?9#9$p-5, Z    ]$Y5l1{ls444,]X*W{n풜p,XؚRyʖT3a_ˢ;3㿓AW.ٰO[WW(C9  Bx   V^- jx[^СCET*	p^sgςER9-s±z\>
'ßZ=#PeO  Ԉ   Unz#֕~uxڢv_+'j/֔"i?|f~,P^<7ŷ   5   *@obp_+F\ެUۺ~J%acݎ?gAКiޑEu}O#j%<?B|K'*M     r2[qGִk䆻[RJRjW*ZST?.RJ+ݮޮ_<>)5uE嶔qc6SRѺW^x^*ǯάpԕp55=
+_˟M].sWӰ[Gk?]+?|wϊny4dOΣj5⚓ķt
g  To   Yqۖ{5OͫFZTGmaS$EkI嶔r[y\rTzRRk[|=J{Uq۾^g?]xe]/%㵮q[OZphMTh-*E%N-KRҲ|'\1Ӵݎ;,xv>At˺Ӑw<ɯ3䎇2;ķ   Fx   mlymmkkkښ-6˸7VvbM.~ocHX)5<
>?]aGض+Y+}M̟Uϭk8&_Vg]_k>ڞesi$ESҒr<LK"zE{fIƝb5薷OCy9ɯd{Uŷ   @x   U!bo+c)˟۸֣5z3IҲ<d O{q羘+r1a`&OXq4dMO^gd322P|K  _6  ʆ@oж;&N*UOs<	ڋn=_X}\tVק!;tn6wR;qזy}_*d  
-   X9z|vLt4kns_*?b?0gn u}Me'm&-  @  @-@bhZ|":T[[-fڋnǞrPH3z\z>
ryxIif1Lӫ|/  ['  exKq=K{6I? gnu}2gg}Tۣm[g
  To  ЫTr=ڢ'Y[y/$)Ϗ,Yǥ)iv7-R73+Դηuot  P!    \}@*`@nt{+B>薚plw߮vyሯm[  u'  6Ut('y[$EYRC>
gfývN)4xŷ+   q[   *iLoAr[{g_\6E:~Ӝ=~Z)iȶ8SRp^:,]7Y  [   j.>`@7^t^jt{.oc*m߾l[ 
-   X9ppZg^E99gk=.oc?eývN|ײt[  7Ix   * PN0Y[t;sjt39x-]W]?eýwNP^9r-  $  &t('н~}rs[
T>{U<ve9+  Bx   U^tFڋn)^*9Vq
+m̠_}1}%$y(oYF  [    t	tkn{ji>uaSTy<-PocӸ.IJi{F^;2-  :  @@of*:ڏneK	?߿Vo/ķRZ~(U-  $  &t('е5})9_NRDtKQۘ-uI%IRPoy    @$WsCWn/8~\0nZMoceJ%Rz,=+[  Bx   V b'+ݎ9_qD=Է1K٠wHӑ_I  `   Pr81b&L)]vYM^fG?/V,#FzgĈޏ8#FȓO>Ư_ve1bD.]p<\dK$E.I.at/+GΔ)SOl좋.aV-sN>g}͸qr]wU{ľ4}R-  Zz    *J 7~bС9C7
?(zkĈ2dzy>l?е-tS5_.%iE}GY<@2
ց((QAqB
Rd$Q*.T*Vւp:lV K"	@e|ޯW^'yzc̈́g塇aÆtܙzl2^yf͚?	'UF5"---5kн{wjԨA>}Y&_<x0]vۡ(A۽Aޜ{6f	BA@4%UNO$IV$Ib&A2A?#kQFv[jEVd]@lHI*vFY
A4J
5zc''Ncǎ1뮺*n233ӟd ]d?/ׯ緿-?O8묳yxxcys{!X?AJgX*F$I_D$I$ID{~<[r%s/\r	 C+C<tޝVZ1f VXر#gq۷gСdeeo/`~//M6k;{}SO=řgƍy9YfMo&ݺuu\{|;l{ʕ:s=3<ݻg͖-[xGiժ]tgQ9==pҺukuF$NVR9FD"7hh59@2oAf[iӦQfMKD ~8{O';;=W^yk6mбcGƏƍ/Ӷm[̙õ^KVԩSL)~Oҥa<=zo.~mF6mh۶-Z^x;^zmҾ}{.\ȗ_~wA۶miӦ
7|3|A}͟?^zѶm[ZlIΝy(((s=} :t(]t)~w/\uUlْ;2i$mV|KϞ=[ 8,KA}>lƻȿ>6o!??H$R"^$IV$I"J`\/_ӯ\ >l.by(ÇZjdffr1cЯ_?&NX4lؐЮ];rss[Ϲ;4i^{-f*q0a_~9z+͛7.Gw9j1z7cewyMVV7tͣ_~;5jУG,X @~~>={矧K.jՊ'2a8~6w\
Dnp:GT>l,¡QDycu2oHltL˖-^NoӹsgC=Ĉ#h޼9ƍW={$//~7ofܸqr-\veL<YfЩS'̙Æ
zj͛GNXۣG=z4|t޽Di&LB^֭קW^A}Ǆ	Vcҥ@,tٳ')))=x38~W_}uY<{Q͛w;]}N:u*FN`ĉxO"##x۷׿uXzs9g@ŷcHiӄ  ]@U%V$Ip I$IRyogTA;1wUJ;v,۷|'{｜̛7Gy8$jذ! קAۨ_>ū ~ԩS!Cppg_3ݎugN96lw<L .\ȝw޹<䓜|Ɍ=6mڐZ">}:k֬gQF nݚ믿Gyɓ'3sL,X<Piӆp8֭Gyn߮lݺ1cpg#|)
oZ0a끴f"Hܯ+Wkᮻ3䨣_~\z D".ڶmK/ĻK袋xy뭷p8L 4i#--
͛s饗2cwpHΝ
YYYū4nܘ~x5?M2n8˜9s?~J=c{.xSSSw%h    IDATÔ)S8s{ hժv_zիua{Tyc,;eg^P(D(*o1]eDt*I$	o%I$I*f$J+N:na5iҤkԨٳ',ke˖{_Wop	bҥKooJ3'pשS'ONnn.iiionݺ;Yp!}-.Dxs1pG_:SuV͛GjvXsL>sGl> D;bo27(xA pl
/uO?H$BǎK|M6Ԯ]yVKխ[-[ psio7Ϧf͚l޼pW߿96mʇ~XޖGMݺu2d>-[3(.2.2YhK,/$77w񼧦x[ڿonJJUVa>
6гgO=P&M8R955kTg}J_no([I$)V$I$g$L'z*
6dҥ}qo3f0m4֬YC5hܸ1pxqζUE]ēO>ٳ9sy7رcHvv6WNYb.,rrr[իWW8mmݺ$RRRvFYVR2XH\>4F&-%Zr))),]tٸq#k׮g?999 ;}[n{En{eΝ9r$k֬aƍ|zq?<?9#Jyش4~2m4{=^~eh׮Cf͚lݺ'ꫯKz8餓~{j&~g;wUVdgg3}r|A՟D=,I$IJ8[I$I.%*Jp9m4VXGѣP_g	\wutڕ
 0rHfϞƳZl
8Sx79Yz5:um5k֔~NNNhf͚ԭ[t;uԡVZ]vV^]b_Eiܸ_dAցЮx+|
{~!/?L%똃&%%ѢE>c6oA﫯ʄ	xᇩU k׮+qիWXi>wƍc֬YdeeqӺukشk׮\r%;799ğK4lؐCFy7! A?~<HOO笳*~~ޝ=|xKQ w܎jڵww}OvBL<Yκ b۔~$ ~v$I+H$IT^8(JK`_2e:ƍǊ+4iRPci瓔D^ۼ<ϟޓΝ;3w\^{5=X?ޮv4jԈ%;駟w}ǡʉ'X[o1}t0v[lw-q_N;
O>p8?ïOiѢŏ}
ѭ#  

HJJk]lonKku]GNNƍ#??uK,aʔ)4lؐ38SN9P(oQvgfÆ
:蠃h۶-3g. SF
?x7n\ըQ#L￿Ξ=m۲h" QFՋ:+V N:/8]t)˗/gxSaϟ;v?4k֌p8w}Wbjbĉ|;fԩH,gw]E$ɷùHJJ"
R':I$)o%I$I**ډ%Ks+H$°ahРz+)))׿']v(^YW_%rt{M6_Ggݺu<3,]tWݕskѻw޶wӇs嗳h"MV6_=ov7x#g̘1nP(Dy6lr?裏/K~ {L<mےʢE5k5j[n/
\VR9S&%%INNfصK[,=oO;4wΔ)SK8C+B8f	B!?pJ{9"ZbѢE<4nܘ:;wL>}D"9uEq}+ ))O>nݺr͚5#--AqM7Qvm>[n 4i¬Y_qǷ~ɓFlٲeێ=u۶m{ܱoѺukyꩧؼy3'xc6m|
&LSYΚ> 9-FRSINN&Vq%I[I$I$IeD~<.cʔ)cʔ) pM71sLF3Q7x#3f૯cǎ;ޥ^ʊ+xWHiݺ5^z)Æ
+^ǨQs3ge \UV7gРAq9~ߦ^zL:Gy'uV6lڵ+ p{G}ӧMÆ
߿?W]uU}vޝ
/?͛7S^=."~_sGǿD
5$E`QxF_#%=+1uуM/aFN9Êoۿ~//PN:wL=cF-[.իW!mٲ%=O>$a5j?k֬ɣ>ʣ>ϦM~СC袋hzm۶ѠA*VZkF~~~ۋ=u{ܱ^SzAn5kOonݺ;}̛7o/~:e#>'[	?$I*)I$ITDQ


g֭t3i|dO;$C2DD"ů[l(|?%j'd_N@>Hڱ
IKK#99yxGH$BAAm6n֭[$^x/NMcJB7YuDWfArGn!)JrrrP(V%^2 DҎng:I$UYD@$I!IULyI*?_3))$III)GP/ޙKkk*o9|hrGns
J$I1$I$rIRf72xI*g (U|;]
A;e[U:y߬`eہD".n3S$Ibo%I$IrH<@e*&ګxwV^ö<_T9o+(nhwF$IG$I$EK]JRUd?2&|'(rz*`9)~=PmF$I7[I$I
9(JR T~ߎ9%p͐Ʒb9
ۀn"|^3[푯z$IR$I$I@TQ`ʹŷp8MKKeTw* 0UœhK,IDcs[ţ@$I1$I$I*SQ0I@6<mh3Xe|
8]h(Don$V$I$I$IE/TSLyIoGvbm0-*{[{yVmzaty[I$IG$I$r>QRf/2&'=ypʱEX67F7I$I1$I$rIRfW2xI`vߦƷ!:"Ymߪ[E2_hRon F'$IR$I$IIgLE=$U@ķ{8E>Ʒ*ba!/[G4omt[J$IJ$I-u)IU}ʔigmrrrq|[Z*{$ѾEG>}.o*k74&v}I$IvV$IB/JT<$U\{oRUB[n[%жL#JגjtW5I$)V$IBN I,T0ITR3[6xM8xmVy/[K4t=67~Q"I$J$I$IJ vD0( h7
^f|fۢL#
Hx-ibt+I$I$I$IET[LyIo9yŷ6mj9oyM
6$I2cx+I$IR!%Ui@*S`*xѽcm FnVefy[QݪL*&I$J$IT	$IUMBe( T)¨>)<J FnVݶEÈXt
H~WTT[	I$)V$I$g$UA;Dv@*Ctc#"4
4'6Ew>-Ʒڏ-Z͗C,͌n%I$= I$I.ZR*bgp
k	%VA4?+T!.C/qR]rnW<(mw(5ǻy;_t0x~K=]<OlB,яJ,u869<5$':}ujl?展nV$I[I$I
9(*>
BBrFji !Ģ$?'EA"E"ce Axa%-'!iWj|=n_r)/|{v]<ޢ7q_c/oJK={_7Rt}-c.d#R'y(97r<i|}ujh?e `7pѭ\lnI$I$I$r[IUEQtDfO4R@ +P)j]upU% pԠP6O>)S=_yh;>(DE~g ?NkN&'[b(c_q^끝gOoh'Sx}±FvH

k$'/}0?w?mjl]ۏ$o:P@q]nuxI$I1$I$IRR^W	syC~~H$B4ZTeWشih~mn=))hMJpPr2ᝄ@TYߎ3ʰsX|c"&3U|.ZE,ARSIMM%%%V$I[I$I䭤*"
F HJJ"99yv&99jժ%zV;))p8\"*$Uqŷwg9e|ںh
9y˲>T(5$Igx+I$IR!#%UvۇEAPQY}i׊G=>-
p]VReO|;.> ?7Nm];4˳ *!;0$I$0$I$(>4{pD\~UKReO|;.|ilJ]F|Pslj*A<$I[I$I9TA@4-1vno
vR[[IUI<=wQ ;|ˣm|+ ý/*n0$Ir+,I$IRԥ$Urc? HJJJ0*]sTߎe|?ȡ׀VqY[E
5
j^V$I[I$I
9?)17GTE!$IO|;r OCa*+w>0Yc/f'[%^i$I$I$<J$I*EQdIpdRRRHMMz4F<?Ȧπo_)UM5-ςVG$Icx+I$I$I$x *]Ʋmzm-[I$I*wo%I$I*|$I2O|{Ϡ|b,zmx-:c,<2ju:V$I![I$I
9_)I$T0wWƷؖkgqtpȘKmtrW!I$)V$IBN I$I:o
M9dsmeZy8."
3[[u$IR$I$II$I:o3䤦I/o+-ٺ|=ԹV$I*[I$I.%I$ /E&a o|[lY/C ;dt+I$I$I$I$It\	370,^GgD7b[UH$I1$I$rI$IR"ߦLӦIAsswύo+-a	+ә/4UQ(I$J$I$I$I	R~M!f1Bٲx-t|
s!J$IRcx+I$IR%I$%P<mF!,`nmyZ^ C(=si3[I$Io%I$I*|$ID'8L@lAƷJF/ѭ* _e$I[I$I
9$I$<S|[Z*S!c]1-6/^ǜ$wy6
CtnU!xTJ$I1$I$9s$I$'0.͚Yߖ#c]
vΣp8lt+I$I$I$IR$IT=.'7K&>;IЫ͋~ߐb=p=wF$IT	J$ITMI$IM<m8d>ۄڼxu
CݪR|eI$)V$IBN I$I*os))@Gs16!6/^ǻblݪr($Ibo%I$I$Ir.99kzo|{lZw.ĖSn%I$1$I$KJ$I*o|(MOI
~6= blYM4nt+I$I$I$I$ITK?NM%>L2i:޾n;CnU	y$Icx+I$IR!'$I$Uķ})9kmشxou~8m8<ѭ*%ZI$)V$I$g$I$U0ķ}ɩ|2g
ÌoMQ,φ arѭ$I$Uz$I$EK]J$IR_|{x,%~iq3;?
8rX;V$I[I$I
9)I$'F |2{
폰iIov~+bO3qѭ W$Ibo%I$I*$I(WO849ka|O6.ΏeEApTf[ѭbI$)V$I$I$Io8"mՌ;v/l\;?9 ,[I$Io%I$I*Ⓑ$I*x3pi̛Ʒqٸ$7:Ofˊl ~~?1$I*V$IB·J$Io{f4SA0o*Fg|d6
5
G\VU+K$I1$I$rI$IReW|;a,%`ޜՌO۝ظ$/~+r ݪ
$Ibo%I$IrH$IR%O|cHCNh^ 7{5ߖqI]d,~>

ۢV$I[I$I.%I$'mȑ4n~0o*-Ջ*n|&
ڴ    IDAT.obt+I$I2$I$$I*x#f* `S
K%?Do6ݪ|eI$)V$IBN I$Ivn۶~O&A0*Gs 9oO<at*ϣ\$I1$I$I$I*]ŷ'Ndƍ$%5$AfUvÒ)l^h jEj <3deeJ$Io%I$I*撷$I*ɓ馛8c)آ:٫WE
KK˦n
jőHff& yyy7V$Idx+I$IRK%I$UvǷSfM222HMM%--Ɖ- z{RǷN$55&MpOl2[UY,I$J$IT	$I$IUA?aƌ 0C=ƌ8E
b>iÒtlZ䧗@jj*0l0  0j([UY$IR$I$II$IbGwI8&99D|{CQآAW`nX?_:8m<p8L&M6m}]"-I$IJ0[I$I.%I${y9r$tPh?5r&Rķ9Keش2]GpP(Ĉ#BD"FK$IV$IBPI$I]$;QFtMA@(e|{]iܢ&Zo*x|[ݮ-ewA1Í7oĨ%IV$IBN I$INW_}ĉ=ǷG[bC}V6gI6/\;6 }s=$%%D:thty$Icx+I$I$I$Uddd кuk:uT|j*hQ r&U6gI6wlZnO؂n<Hn ?_$H$IV$I"gX$Iڄ	Xj ?^qǟQ2&S!ۜ%<ٸb(4"Ç'%%H$Bfff$I$)o%I$I*;%I$UR֭cر t֍͛vķd-jZ<Y('ٜCtpӣG ^xWUR~K$I$I$I@$ITY
6M6̘1cv{۸!ҨEM_HDa|$W<(Ml1]OاȰaHKK`Hʒ$IR$I$II$I.\ɓ9ꨣxx۫G3jC0<rƢl\(Ф_s-@ݺuի _$I$$I$EK]J$IR%ҿ


UÆ
~ķ݆G3j𯷖h9od+eÊ
DҴߩ۵n<իQE$ITJ$IT(UI$I0Ν˟g өS^?!hԲ6YKy{	ofϲa I}OBl۾}ѣʏ'$IR`x+I$IR!'$I$U6{AoO|{Fײ6ofϱaFI}Omz;tPr%I[I$I$I$5jiiix_9ΨM|:k	zƷK~ذb#h6Q$]6J$IRax+I$IR$ITIп 6m
7W|;1ǞQ l&zķKsxlXҬ"v 0`?<I$IRygx+I$IR9*I$IɓYp! Ǐ'?ӂķ]6ؖC٬%<Q9?aF@8 D իWg {?zRyʒ$IR$I$I@$ITlڴaÆкuk.x.COŷ'{M _m6唾's|F$-ү_?֭PJ+K$I1$I$9s$I$3f֭.}^1iy0A \w_Ksl\QN{ptFFF 1o~ݾ$I$|1$I$)ZR$I*UV pWӼy2W\m}!g-;ʷ0+©}ONHt[o 33L!I$I*o%I$I*TF$ItKrr2w_/9!Ag-fʏo/Em}rBBl!C Uo_{2ۗ(,I$J$IT	$I$IW_}Ŵi ;8ꨣ~o/lqg! o"~{[߮_o
+6QN/m[o#<8*W$Ibo%I$I$IJ_~D"jժEffw<M8z@g.;fU|~iS.?-@JJ
C>_> $I$X$I$q[I$Io7 222SÞ:iqg% f.o/_$gF(݄[n"7|stߒ$IV$IBx>V$I>} РA훰q^4)Ǟ]31on(n/X.[$F	_|>x$Icx+I$IR!'$I$UD>,, `Ѥ%t<ŷ'q ŷvf-| 
lL+gt[裏`ذaD"{^W<_Y$I1$I$ə#I$IT^^
iӦ\	QL<m6\nG6kYh4=䫎+-@(b@l3f$t<$IV$IhKI$I z!-[	_<CN昳 |HA|KnRmrrrn\uU4nLW$IJ[$I+'$IF@v<=c
gB~wyc+ORmQx[[(~3<I?+K$I1$I$rI$IRE2brrr 4iRGk{oS 0
>k+6FiqҭbEEtBf̀ت	㔿e$IRbJ$I$I$I̲exkhڴiG{{o8;o#Fiճ1ͯm,YԩS<I$I`x+I$IR$ITA8<{=vvo9wOZZT/.^vȑz+I$I$I$I|$I$0|{9 zQGۤƷj/5.݆
7n[Jh}ʒ$IR$I$I@$ITZj1tfm,-JII-\@- 1b۶mK}SqI$IeV$I$g$I$Us ##:u$xDfh DE~ V\O<H$I~[I$I.%I$D"u] 4hЀ}&xD?NoV-*^(*VDg}6ڵ#777#$I$+[I$I
U[I$IUԩSꫯ {IKKK~+(mcUo{F{,I$J$IT	$I$IUnn. 4mڔ뮻.#owUѵhт. p[ULo$IJ$I$I$I܄	Xj ?Plmiƍ`ڵ<C	$I$i_TK$I/\V$IR9n:Ǝ@vرcG}լY3. ƌæM<"I$I2$I$P%\LI$IR%YhN4)я5rH 8qbG#%I[I$I
9$I$ꫯx' khڴiGYft	&I|eI$)V$I$g$I$SdƏh?5jPl|DG$Io%I$I$Ir`ܹK ݛ
$xD_7nLn x\V$I*[I$I
|+I$ݻ7 jb	Uo7mĸq=i<_Y$I1$I$H$Iʋ_|0djժi;裹4ik׮M|eI$)V$I$I$I*G


hР}ITVFIRR6mbر$I$)$I$q[I$I?H;N$!]ChУt."WPQ|APz^"c^T$^v<l
$-뵯9g7e0kTw@4lA9$_n[  6@x   
  T̙3sg&Ir2#beW_=s9S@  [   hd	  ;/ovdذa1/'pBK.Ʉ	<"X<+ @S   3G  @+0y><In_BGĪr7_袋8   Fx   "   UpYgeΜ9IK/ʣaUZgur'&IF)STyD   Dx   
+  U#FJqr-<"V|;ٳsWT{8W 
-   42((
tg'Ijjjr9Ty4TFm'IٳgWyD0G  P!    XeY.t	 /n!I2dȐ߿#ZN?$ɔ)SrWWy4   ,     *83S__ڜyU[f}M'?I]]]G     ;  ڿzI/V9~s}Uy4.+ @   @  V/0


YgU
80[ouꫯh]W 
-   9`9H`>}zƌ$9#TyDsLdܸqy׫<   $  rK X, 5jTfϞ$7YКqYc5Rej  t    !  e#F$Ivi0#z뭼;ʫ5\3/
uY'k
_ei  $[   hfB oXƍ'&IUy4TԩS3u޶g7OL2ew=,-  TT{    Z@`YoX$I޽/~ʣX:G  P!  F& X55U< ڪ[oMx[ Z3', @   3G ,+A=Ù1cF+_JG   ,-   \on$Iӿ*   X=    h-
+#-1cFx$GQ<裹{g}y{oy䑌=k_r7f驩IYvms1ǬʡA  o  uXV;vl̙$9裫<Zz(',u
70vZV[m̟??۷*%  *j=     Dxq-$IWy4&zn/u=z_~ݻw'  Xx   MS ,- ɓO$I?*C
7ܐz(}#W^ɼyҽ{loR[[$;wny<yӻw|3{|<    @# ,544Ty$ 5?pSE8jVfyg#dp
?ό1"[ne9$O?Gy$}ɠARWW#Fd	w}ӯ_<3[oeNIt  IM    uXV/$jWy4FvXv믿>uuug6xp	jV[娣J/&Izꩼ+9>[mU;|L<yU>,	-  To   Ax_*I~#ڵk<΃>m
Odĉ_z(ku_xt9Xhvءv   ޟN    T]% ,AMMe=*dĉy嗓oYdϸq&ɼyrww]͛ݻmf̙Y{߳o=$g^y     @ʷ ,+~?o}#-8sϖ[nm~{?#'?t5Iy.]dڴiSNM}`yA  $5    ) WUcXzUu%CɄ	_z^|li7x#oVɦnsBh  *x     Mg>*ⓟdva_mQz7믟_=<@ʲܹs$lM\wuw}ӯ_<y'뮻wxH       X557khhH h+~<3I~U
mag}6B_+2cǎM]]]v-SLק67r̙3ӷozmݪ   >-   4*g" ˠ6IR___ Vhn[^{eZmkV.ֵk{챋CmkKV&	  $5    `YoX^O?tJ0ٿ* @    ,^z)I#   >(-   \oX^M>*      Ш- @xzo  P!  F& X[ [oiӦ%m Bx     ,^z   ھN    `oX[_~ٳr3nܸ|ͩ_xv}  	o  ev5zhhmt.],>kv~$ɴiӲ{It  IM    oXV`y4[lEGB{&4_嗫8:-  To   Ax4iR_~U	G?oʣ  x   P.r	 K `y̜93Iҵk*SNիWwn   V-   4*|2<f̘$֭[GB{ҥK$ݰ*8_  *    ˢ)mhhH hx   [    j%I< -+C  `  @KV,V  -   4*g" @x>}z-+jp2  To  	$ EN$U	 ٳoY~JW 
-   9`94x+`i"HV  -   \4uuuU	 ܹswܹ#-  @o  Qa[ ANX+wkhhHhoV5kVGBG|e    @#H ,hС)=GN<Ӌ}h<sԉ@JW 
-    b\tEݻrS[[.l%    j  @K޽{gذa˵ϱn%    j  @{&Cf]vYms9g%    P!M    IDAT  F& X1cƤsKN߾}W  `s2  To   K馛nrqǭ    P-[   (E~tM[.Kmm*        FohAΝ3f̘vae[# U  P!  F& X]v%_ZnrTiD  8_  *     袋.J޽?
7ܰ#    `U  @K{ΰaÒ$oyN=*    UIx   
2:thve><;wp  `p2  Tt    0@Kʲ\O<go  9 
-   9`	ʲllT[.    @&  rK h6444_/2͚kwNQY(    _5    :) `tА̟??rW.uuu	s q  [   hd	&F?~ϟ_??L837hxuJϟ׋o h  [    ,6t1/GD"'-G,o׋o    9-   4Gtx[v޼y旣IY&k9[qR$'ǌyY      @{&thnϟw3cKգsz/dHQ>iV<ո Q-  To  	$W?_lR&ku|c$yޮO$Egcǋo h  [   0sС---2kuޱ}B]O(gc    c[   (h)+K2ku_#'߱{&xEʷc      @ʷ JK/.|.I.طɁ?-"Eg[  G  P!  F& :۲Z;k?=eR$3&=ǌ n8_  *    @RtϧLVrDMf)"3&ʽ<*    hG   D-)}l)ˤKmdne[(f徯<ŷ        3]k)}/$u>~?#[UM[  ,G  P!  F& گ/&D߼?>ptdߟOe"3'Go h  [   0sЮ>~7Ŕ)ӥ{|붽VXtd|>>|G?_    U[   (h9}1Fnt{Vxtd?o(2k<ķ     m   VhWZnbvF}Jn}p'"5iVʃ[  G  P!  F& ڏ_#Wܶ&qTc|;sҬ<r" p2  To   v_ãI^k;~J!:S)"3'#G?     hC   DƗORk_mB>y'S$5yf=~-    @!  FLhnn|9etFW.+<b@"&̸eʫoo h @   @h5n{IGM`luħ5yf~& s2  To  @`t6G_IR[-'mTƕo    j[   (h)}W2sqN+n|REfO_W|    J	o  Qa[6^W2eܲ{ٸ[D{\w<b@R$'_'Sŷ  "B Bx   L eY=c^+=;޼[n|}N̞43[  Z
+ @    hSۦ)药%ev9
EM>w>O(̞43?    *[   h_hZno<qIt9g޼kn~đNdQcŷ        3Uk9}1O5!e*+]nnvĐ=iF~y[  Q'  To  	$֫^&,ۛ>&^_6?rEe_u q2  To  @Rt{e/e]YWӎ&/M3tWyM-    @o  \VcmJ?3YwJ˰#I"'o    Ix   
+*-E\<vפe{sqtǇlHfO_N-  L    @#H GK͗=?kbʔ޳sνiPn|vl)2gҌf[  V+ @    hUZn_$޳sλi笷Qǈn|1M9fCn    B[   hOۛ.9ez~|N.m2ِmnm[    UDx   
PU-E7^r5t۫sm/:06EQdWķ  <* Bx   L TO+y7R=W7&;_tP>6dE2waȭ& `%q2  To  @UݦL\=ܰcۨK۪tAؐ풢I!o    V"-   \ʴ^y7S^xY_tX;J|"s&ȟܜi!    X	   Ш-*vItzݰv)v藶Kd#o B9 
-   42^w?7^tveɗOQ;iz<ʷ  8W 
-    J^{?طR&s.܉ԑ7o    V -   4t-GCcJYc~[Cɐwۧ1ŷ     +   3`j)o%eң@tl;RENA|   *   Rt{o'I\=_']QlS$7iz, p2  To  JL%mFkU{fvLRdiï    | [   (`i)jk씔Iz\-]v%fġ7izru[    Ix   
+P-EcF:%I=VەnevLQ$&N6_, `9J 
-   42;tjRc\~E|iǤ(2wķ  ,3+ @    XZnGwԔe=WȆUFG픢HNg_[    e&  &"Q{L=Wk?%~6Ey׈o       3YbtөIzv@6趚]Rȼŷ  ,B    @#H _KQrOIZF_l5<ZJ|>$7qZ;*- 2CMQ8$׿{{߾}oVy7W 
-   9@ZnG{y'e=Dіwŷ Ъ6,ݺu[.g%   -   \Zn'LKY&{1ln[-.8,9~E@+ѧO}˵3tЕ3       Ф-ri)bČgZJt{͵
5)̟N^<ttfoU8S2peڶ6FZ#r  [   hd	`ٵ^~夌wz2{k2뭷F2ąķCW&oʚbڥn{'/s  P!    {'e޽Wun!mc6pp6<~E2ⴼth- ̱m6`s9hD       +'{WzFtV}óHR7VG?Q\pAu
G  1	o  Q=+'{LOd:W{| IM|'|qTf,jӧO.޶nexDt4  Bx   L vIZnz/m6k\6E2;yБ[ Cfv[k;wΨQ4":+ @   ,QK%ȝHRnoݶ;;"{	^!*5jTjkk?w6۬#  X   P.r	@ۋG;I^妫?.m6vdmo&~@lf9䓛~U  @"  Fo,޽W-Wo&m>6Ȭ{IQn sl/8;;cp  =    h-L vrǽR$ۻSnjSmaCR$pM|'eSV7o^hP=+W.]裏x=vmc|q9  ,Lx    ,vr}RL^rUv0e&	C.wkF|,<nv)B  4  @ -GcJQkvǲzW{T&})EIKwC.zwM|A5EM~t;EM0MmGMMMHYs    @#e@GRt{јs}$}{|TtK)ʷrit8-6}4}zGR&qT  [   hfJZn,^1nIl|QoY'L̈́/ɺco:Wm:~s뒲LƏLM|,pLMmIQ6T.uLMw/EORa1Wli_gq-ۗB-fej/]`~ܗ^ߧfq__S[[@G:8  Lx   fnINQVVst-袣Kĩx7[bcL|>eRSIY6ERIυb޴_Cc6}qo5TbYdk~F+hEP.1	?˷_eb{/W$)ˆER6)jEIRLm  C  @%@Rt{)9))wniFÿ"+S3Sŷ @YxP6$)~9l՛W2MVMJ|v+.vAY\V,_iq]WxzZW];4N,~lݮodÿO.5qL     3:LͭM)wXt}dSW,ufȇ~*oˆ$dsnY?,+yCC𷣭z[ƛ @ʻg    :۫,+1gC-`C=SHĩy?g3Uƕb ڶWmhhx:PHx`x`|Q/  *    ݞ;yI)?Q6\Wt˲p=iϤH'Lɛyh:h~nOSIN      e Znݖe{FDt/$E	SA2	[vf>-LwWu  o  ak)Ur+mrh+?9)"탆e]Zy܊SE^v4Q {	o  	$=k1zZn^ʔۻSrlj.#'~!E	[lFg58VI/  *   `hZnϻzzn~CDxJzWRi0%SP|О5={N  .-   \#Kno~$}{uWnnY	qL%M0aJxjjxK;Sz   X   ڛsKRY+ݲR3HѸ;/h=^0H|e  h"  F&GWuԥ,jD86=Oķ儩vOķ MS(RqlE    @;rt;3?Xe>ԫ6nY]|lzId?\-@9vGr
  Kx   M
@K9̵VGF+*>|qqI4L8s.hWxK;Sz   X@j    Zs@[Rt{5r
)ۑ#ziǥHi#JÄ)yyɽ'ۼMmmmi?rmА޽{'Ijjj{N:&8A;STWnCH  xu   Bڲ%E>P"ёVC"ɴ+L9aJfp^rķ@5}˽߸q㚯/Y}7ttmj=gވnn IM    UghZnx\`C$Uq[Zk$E	S22gK}}}ʲl kzM  ][   (hCZnϺfv~!eYnv֩%'T")'9+hD+Δ^0      F憁kf+q{fҪ䄬_(H|5=G{)`  Dx   L mIsrCm>Գ66%'<-@'io{$ywQk  脷    ƴk+Wm6%'kc|	oggo"Ѵ;S  ][   hbnhZnf̃E$U'.[Yt+̸q㖸:ks\N?6}80]vwܑf֬Y+dL'N;N;msg^7n\_}0cƌ><
/~馛RWW|fuI_%)	S2oVeyGs9SN׾{yzޜ<yrN8hxkN:i{?d|_s'|
C=4W]uUf̘Qq  W  Z0ڹP"
pޭ.M5\3;CS*7|sYgƛniXc~ַg}6|6dOe]O~~KғR̬+O^~yln6āUkɟ|S6l$yWrw'$ܹs>O{#Vqǟ;6r
+B}}}gfmrGK.ygr5ѣ;
VE2 Dx   Lق+|6444Gg\7ݖe>ܫ6w6^v߰
/huvqqڵ;ꨣV?Sy' p@jjjr^믿R{Iz\_)̼⾔N~gegcĉOg>m<@|<lҽ{|_H鹸<'㎮]K.Ɏ;[o~ꫯ~=Q{SN9%#Glq6  Pno    IDATT{    PufVnvnݼ~&eUng̘m6zB_3gN>dȑ}{.'xb
}7<b}ݗ;,;Ck\z饙7oBI'v-kN;18p`~4hPz补w[{~'ci{͐!C|'rHG}{gn>G{w9ַ;g\Zkyc=oM7ML6mye~WOQ)_;~geקao
L>=Iҷo~6[V[m$ɓs	'c׿uog~93?1׿2lذ|wAHMO+yΜ9⋳>dw~O?=sfv=O=TN>afȑO'xbjjjrg/τ	rgdN;픣>:oo?s{nΙ1cFw
|smݖmv+򗿼ʿgW\:(;c>r-=38#ַr7f;;,/T~vdiqkhhsGfwN;-?|V/     @%@+jg\_+IYYOm~yYt۵kl-I_2g{}^{{챙9sf~e]mwuso#FdС뮻}o9j3̷9k}6lذtA9[/u;o$y7O6G?oaÆsI׮] ׿i\\pAp9ӽ{>|m[SOM.]7o^ׯ9~5k}u≯r/Px?}͝wޙ{,'On{<xpgM7ݔC9$?һw\+뮻~>яo\{Mm
\,|رcsgĈ0`@8<K/|;<xpjj}sI'eWϏ~\tE~s\hۖ/zj|q-_ϗ<39sy[n׾'IgL:5wܸqe]ҵke:^_3fs\9Srq%IrI';/0;cFaÆ-oWʹ瞛o=lA7ȇ>e:[㸦Zo[N?80\rI套^׿+xjY^0   Щ   ֢*{4x{3"EYfybDlEMgyyײ'I}lh@tM_ݻ':dȐmM:{:$>v~|ӟ%\6,\rI'v!x`ƌ>}?=#_W0jԨ<9T"N:e=L+9蠃r)4&CO?
6`o?iN8!I2hРL:5կ{??3fNˋ//<:Ue/j:eΈ	ow^j?{*6zjn;6w}w^{l&0`@͆tA'>7N;픁&I8ϫAǵ4Ox'9쳛c.'N̟tܹ~%{;}l9W%y&O=T|x`Ə/<
j>Yu]9soo^iv]vСCsg=Ȁgܸqy睓T	W_ͩdَ&M$K=vh2~oE]]v%ISN3xU__aÆGI/~79z췬q馛RE;t5Ie_י5kVt򁏧GQ+|%綨  -   43VƷS7Ʈ(3V6YmYs5w~>駟[o&?l͟/ܹs{cwLN޽7Y4P
UD"'
ܪܓhm@)DAc0ov[?A*%nAMDh9%MrȁjiIJ\O?[jTu5hڵY"8ˢe.3<S{k,Y믿^|M8QUUU/l2IOxׯak}>J:ǥm޼Y/zodm!kN,ҎeUo$''뷿f̘#G.Ӷmkڴiv<g~?x@tJ
^ouI
3jz5~IIIh>Vaa,\R:D>l6x	|ڵӧO8lܹ3|vvVX*I|d]}Ւ"[/lu`}sgڵjժU8
8p#$[IС$=/u\H_hCw>3CF
ܜzꤰ֐Dt   U      K_h^/RJ{r7{4jJ7tJJJtr~!_M5#KRݻw!T]ɵ(E:|p25uԩ5yd}:t萾ӌ3'0u5D|d/BVs=/0{4ڗ=Am{d!f Fy<9%&&*##C'E̝;W_j^WIbwՀժUzjz﫪J;v%\"~k^<L=C2e?Ϋ?1_R`sjʕԇ~pLzᬳ
_Xvܩ8%''sWs}p8j]&t"O(=/u\5g-X@o|MiFwq~_bzX    B    8
CBa{gOi^|}6?[kZdZ;Ք>~JRWO4IQm׮ڳgOرvQ<_I]7dܺn&=Zlۧ$]{ѣz5{l]r%r:ڹsJJJ"}7ґERx'H-[H.i3*ko|y?,!ϯnu|,S ;wkM:/\ݻwĴ|~NLLTeejŷ7o?D	ӧO|'?	vme˖iΜ9zkY۶m}%yܹ.r}JJJҞ={-)_DXB?u̙URRrSkHo:.ǼO>ӧ~z^\^OC   =      Vl6N+uf{~>i>cO>:3j_5\+R֭G([_veڲezm۶z_cǎJKKSIIIݫիWIݻ6o\WKwޑbQ>}Nqhݺ~ӟjŊ*--Հ»VTTh֭8ppDfIvWfX"<.!O:i,FGǫJ 
fj
\h*ڷo_xgϚۧm۶34af"zӀKR8)Κ5+Yn.
4(:m6m߾wG}GٳgW\o8a>Pjjj#'|ESzzv]Æ
ӧ~{].VX,%&&wުG}Tr/X+"Y/o]>Oqqq+5aIҎ;d=u2Xkp2        q 	@sT (lSzk[wOo=,Δĝo-o*11Q?Oy{G|~_Zָ}1b
U]]kV+Q=z$=Zcǎ<o]*,,fӽÇkѢEzկ_?uMК5kyf}ҥK</߯ɓ'?߱cGhѣڷo>L$ם{GvzUV%E|Gzs9J?^ի)1>Wqq[ h*]w֮]wyGk׮E]8޽[6lj=I'Q/܀W]u
M:U{Unݴ|r}gz#/X˖-Sqq?|}zeFDIII?\u^~_jٲeȑ#??iӦպl~4c-ZHGds֯_gyF˖-5\#ͦkٲeJOO#<}ݧnݺiZ;GxkHqkk)??_$r8d=uR8mXu        p@n0~[~Lo,ѽz{J{rWHyoV\\1/ױcGSO=֭[wlW:uꤷ~[էO7Qrr$oԋ/W_}U&LT>}4sZ!m5|Orp8t9נAqPrrj%E3g̙3UPP ánݺg+287Q۶moO.R?^O<D2>.!۶mʕ+5ryNQў]OE?W!á`|ˮ n߯˗kڵZ|<ڵk޽{[n	6ŤP؀bы/9s7СCԭ[7=۷o3f^zIG;w֝wީݻwkѢEz4_NN-[?8Ν;_{M>]>O^xf͚k׷iF7pJKKu-Ժߑ^z%{Zx^u>|X]tѨQt]wUV̙ٳgk:ptGyDwy)=[Ee]3gP'NS=4gIR"g   
{6     hÐÇUUUz4Nv_ڛ=" 0plzx<x<:|l<9lS:(8UFGo.P'EI)>>^6jį</Io.Pbbbf~~xTYY{_}fMT\;GDg;ZKIl6[̜ YZ?:AtxrYN3.7    X     C Ў6Mv]qqqr8W8O~RU{
9q2{d@U$yw6wy @3}eXk
       $ Y0߾_>Cw=ZU&ODƨh	BasM2o?nt+;@zNц\O6   @x      Ʒozo201ʐ~- \D:9    Ax    @ǆ Ʒ=volGuxտd$Bt -ш2`    [     864}}Gg7{}H|fƨjտ$C{,D rve[Dd        q 	@KY|ķIv>\ɓFGeMU_H|f:n0-fjz.?IzztJ_ߢfnCL.I'   =      b0p|[sR
<w]{I'g״ni#JzL`t)۸ۈn4k			+Nkmۦ]J-ZD:q.   v     ZHv='աW>Lإ|U#o$hz9Q    @x    @ǆTǷ>^z
&0*=&qU~yD =B;ݲ-k ~   [     8%4[S)ةUn'GWz-OM!#*[ &lm%   u      @8``|	-W(\IaH#oP- D/"ED$          c @u
Ʒ#& EWz[ԏ6ɐ!ȟ@9Q    @x    @ǆD[[_l2[40G[n?Rd~c@
tˎ2M   o     hI|{vCŷ>CY}r-}~tdV@4=\hCL.I'        #G TdmLS{kh$-ң`tkHVN[ ~6HQ5
   #o    0(Q|9^k")Wz9{ܟ~)Ðlw_#D BO<#   o    0hi|@|#ũWzU0U0mEt #-;"ʰV	'         H Y&1}㿕듃&O_ї>-_Ilw_o#(Wy<>6:   Fx      ĈHYAzo'hӭ[CV- ĔZxsd        h686 X,oYzijg꿟MӍ&6h	}qTnZ	rn |?x^^YdbV)~|qr}:uֺ9ߐk_cskΣxԼf0O;8D}q'9O9yt    [     8n VD>*=4ţ~^kӢ9Wz[ʽ+Yd1j0 bD9jj"$]i苭>"Y0f|[CޢW3Fռ0Q:)8O;ո}ܞaj1L^˨SмG^ďG?~~?N]%YTޞYczPh_        Ć bIJ?uX:)-nNӡ_brJD sBk	ݮ
ujK_w
j\Z;XyǵN"?/o0$Y5n+jx[=o}nWy#֯_lZnq;{z
6pc#Z_c}UkGɹÐjjf^HMS   o    i|$C<Q>~<Gl`[Cr}@fݙ~
|~~1WyQ:,pcfU)X3l6YvYd-   Dx    Q- ĐI1    IDATHۙ1OUi^Foќgۘn%eZeaG"&vx')xniSݰn7   @l"     cf bUsv͞~n]O3+=r,sXJt 1s{hZK[njέZ2yU7Z1!   $[     8 T|;R{-nķ1_՛ejؕD ZkDtۘl6[x'~5ۚ,ֽ         ۮI&{=k~6+=0h,9^l[ qè m5hxLͷu?    a     p< "o?&Ovk^Cǖk֌ķQ*>e1m{[ @P:h{    6    q3 4}1`[~=0v^]_Ӣ1+~L\S.PaW[n G!LlZ5w]=z
hh$~         1fS\\p8X;XzpfV3yr4erf2C!  a    [     8r 8}M8S@|
Z3SVK0n          Vly G4}6Jnogh|^'ǩWVkmVV,[       -     aB PH.['*и|9mK㯪rׁ52$%D   +   !     q 	 -v֯_߶ j}Z!z:   $U   @x       "ƷO=V_j
'ǉג%Bg      Qo    a[ 8HOƷm3竪֚^
Dx:#f[       -     AC H'H
Ƿ76CjyIW-0xW/         $ \DmVz$u`ohbUU~}k!C3  ^   [     8r $w/}{'Zn"ID       ![     :o $ܥ>:_+i|Ud`tk]qn            4}@|k*_U>NIw^T[   D   [     8 .}2Y;Xظ.ۦuǃgk-2)˔:&[   DU!   @x      ADNlz|?=&Ok-a3-       4[     B N[P|7o}XmVğ].2n          D_ 
#6~
|~=1nV68>m}+VVn  pR8_         H pNVUU1/~+O=1Zm>}e[%~U3]*((   Ia       # hǊo}>JUm^%u34Ax݇|[To%Iof̘At       '     [ @Jw߭uIy
Rlg話cSuk[P;.Q؟*>>^򊮿zIҔ)S?       N-     AF 8jƷ#Gԇ~(I7n~_)>>^]ZkSgoߞ
ۣeV:yFjݺ}]]ve_*))!  	q2   @x    @ X,=#z뭷$ɓ'+..N#ߎ},%ukʘ
ĵ[ۣ!/kmw9cnGCqqqj۶>CuU~_~֬Yc   h8U          f̘^xA4h ͝;W6MqqqGŷcd>A,#=ۣC[{˶0NwTz[&ͦ;r)99YUUU0`;            (ϟqI"l6Ycķ	zdYj&3cчC檢lI\nc?ftkXdXtyiҥr:ڿ233k3       -     A~g" 4%KhĈ={jŊ$Y,cƷguI#OwVR|>)Ӫe;M'͓QɐXMN/TOZ/zzeٴuVO4N  Y|e          @Zf"ϧ4*11Qۇvv|mnJ 5y?8
Ҽy$I7nTvv^	   +        p ܦM4` UUU)99Y.K))).y|EI6|}dBXC4B
m5eIʕ+5l0       @]     u Nە+!!AK.UlOwUR@|;4jG^oaJ
n86dĉ9r$HGn       -
-     A'  ؿ233}vvW^HISd{vGSܥf`t+C
݆̝;W999ٳgkƌyw   Ђp2   @x    @ n
0@6mbтמT|.ϯo-k~w(}
JjUQQ222$I***j     [       *''Gk֬$͚5K'uķgvI5ۿD|[`tkH:taG!C%%%JOOa6l\.W)       ho    a[ 8%u	&hԨQt]ŷm۩g]]~LK7v{~.Ðκ|]8'݆$%%r)%%%U5            =ZEEEÇ駟>49њ}_jG?=K2tuQ#G!*--Ubbnﯭ[  @   @ -     A@7m4͞=[y5Fvm_?s&3.v{T7gwaWM݆S/PEE233UQQ`     [     8r d*(($WEEEl
vǷS]]>^Ϣ v{矿Kzېb\n           [ 	-YD#FT{WԆi|_SUd>C/<>+gi*MY]י݆h֬Y25      @sEx    @P#J UV\!C)--MJLLlۋ4j'Knmۣ~?ڽaI9穧mȨQ4vXI
   
       $ 87*;;[UUUJNNRJJJn$mJ6ʛ]mCo-(v{^@tkHs%66d͕$͟?_&Lh  8_          [_~:xtRu޽n?imr|^~V=z'wvm.Ir[w]MnC,XLIԩSUXX3       Yo    a[ 8
effj׮]*..V^|H{ghփhm&5Rn޹-ްC2.9uJ
{)ISqq)       @S#     Ȥ~	 =ۭ\֎f4JLۥ/v{oi2C]renmHBBJKK&߯\\ԙ   и8_         H p4׫If͚\4M>{;~fڵ~J[@t"˥dy<eggkӦMf  F<V   o     0
6L.KTPPQF<ǷJLgh΃koM\=;vJ2s.wUnCwﮥKt       
-     F  IѣUTT$I>|y':Z$]`|5s[ۣOڹaBm-/
ի.\(ͦ۷+33S7{,       h     5Ӟ	 L1e͞=[y;qDߎ~ap[JS[Z
Fuc3ZltRȦM4` y<s  @|e          @@aa&M$IfڜEbEJOeMzҎ
;e9Q݆>\'O$YF&O  2V   @#      V\\<IRzzJJJt:M*2Ƿ=!ϯ~*[g󸫵Վ
;%C:g9=ʨnC&M#GJw	       -     !ly ƭ\2KiZZ\.DC|~ͽZ߈]z[;>))6dܹʒ=yʔ)&O       
    7@ظqx,˥T:%ƷwϨ~(]wv0n֕cDmt+IVU.TFF.7y*   .W   o     XuVOTBB.]ݻ=i,mg\d>C^-`3x}.2tunCNJJJ.I1b,YbT   8-
   4[     8r UTT(33SvnWqqzeX
"S׶\O	Ʒ?W}ӾmZoUd܁g+cLnCr"ϧ!C           `y 1v*//bтiX
*vs=զcyzzc;DWXtR%&&*
       Z*[     wcx<	@:k,<U4KզC~uz՚7]m߰[}PsELF!={ŋp8j     [     8 V~rI5j(j\Ʒw>w$;d
Њo=j>=}.2}`~$ې}HE[nU~v   '!W   @do     bI5m4'jƷw<w::d|hֽ_~X׆鼁]u#nkѬY$I7nTNN^S      !     -oĀ'|R,͛7܁XDmZ[ZķU8t|kn5j(3Fr4l0/       Z[     bc
OH222pBl6s2A$mǴ}t74AWj:ݒo8O\IRQQQ8  @R   @ -     A@͊'IJOOWIINS'gRBxփ.s:<?VaѶw0o,,XLI?ٳg<   N$W        p@[rrss*˥$2]^JazeZ6cKp[C좾D*..VϞ=%IGVQQS          `y QLx<JJJRjjc5ŷ4dj!Ð<Pm#0>~D')!!AJKKa6l\.c      q    D ڔ:xNJJJnXN/QN2$}d(nOUJJ\.z7=      @ -     A@MvڥLUTTfi0{fDT4%tdti޽.]*)ۭ~i֭f  :X         @9x`8^X,7o;V|p8;ߞqN{9Be%)It{zꥅfՊ      !     -oDǣlmܸQ4k,
>Z[oNA?ɻDNnPVV͛'I*//WUUUeP       P-     AQ Z:߯\\R4vX5Zcŷo9vv0|p=䓒2
2D>    q2   Bx    @ tyyy*..OnD-PnV+my4rHIҒ%K4bs  $U.   @x     G DI&Py;PZ,lZvZ[s*++K4|M4             [ hafϞ)SH222pBl65Pd[󿚻aXV-\P)Sr       0-     AR Z"=Z9N>ŷuwEr:*))Q%Iyyy*..6y*     @ -     A@Ҹ\.
6La(55U.KIIIf4$\.+77Wk֬1{,  ĩf   @ -     A@В)''G^7'=G)11QGӦM   p2   @x    @ ߿nTRRtMzz/^,á*33S۷o7{,  	   @ -     9ЂڵKnWqq222ht}UQQVo߮L<x       [     :o:x맭[bh4{,hܹM6);;[       [     ,|x<ƍ%IfRnnSMoȑ8q$iʕ͕7y*     @ -     A@\~jʕ	&hԨQ&Ogʔ)>|$Xyyy&O  8_          <K
O<`y)++KTXXiӦ<      X@x    @[hqJrrr4w\'ͦ*##CTPP<      hGx    @ߙ),,ɓ%I}UQQVIq:*))Q%I#F2y*  $ř<	b	+   +=     A@М)//OԳgO-^X䩀'))I.K)))|QYYc$)>>>~uu 8p@Զm['A,|e         hf\.
&߯s=W˖-SbbcVZZJKK(ۭk֭f ^n ߿_Ԯ];'   Cx    Q- hݺu4h^RRR|rqf4{5wPff***@s:Z:d4&oL    b-     Av`r|R=bWEEEX,*//WaBa$GhHoє8_         H TsNө챀'''Gf͒$)''G> ĲDIhX0+         nﯭ[fi0{,5j4(    IDAT%I.K#F0w  1m۶C<		-        `׫I͛,ZiӦiᒤG5y" oo   <     Y a6l\.$驧
 N߼y󔙙)IzUXXhD b-%ޢiq2   @x    @ 4ѣGH4rHvfSqqz%ISqqS5СC&Oh?'ES|e         034{lIRNNΝkD@tJHHҥKս{w~j͚5f mVk.'A8p@}[    hz     u@#+**Ҹq$I}UQQVh,r\JIIрi&#B;ޖ<	   @_    -&tRqK.D-0y* iɒ%jݺ߯
 tE}vUVV<
;,        H@lꫯ6>-[hr:+cرCz@jժJKKUVV&I*))_hyg}v Z.Hdl٢=z<Zo&gm$5         
Dyjݻw}#	ϸUW]|cܷiӆ@v̈́8m$sU֭M    b     h6   @֭%I&OhaIҥ^j$    o    ;   4ޝ7U&O
-J
-.XP\ 7fu  "PAl*"
ƨ2A\ T-kiiIJ@ۓ6u
MN;K>yW\!-ʇw[l   Q    	$    /DرcJKKD   7     0s   QEyݲeK    @
:      3}NF?~jժU2á;P׮]%INSs? 4e4j(EGG[ bǎunݺꪫԩS'EDDm7rHlR<iT'OTڵ-NjΝ`%$$X    [     <VqIXB+u[4u]wFr8r8Sj֬Y	I[ꭷRll:t蠐O?տo=:tFY@u-޺\.Tǎ-No$]}'A 2A    -     yXW5cرC[.q۠ VM6E2d|{ݴiF3f?ybf3g?x]e˖'A t   Q      |iF׊+ԼyumܸQ׿`ƪG{ｧ~Mi*11Qwy6lX	^:33S_|qҭ^ݶSNK9rZlx@رc5` mݺU?BCCuM7[oʕ+sN+))Iw}we?< ~n>8\.[IUW]eq    \6     7XfS߾}+V믿O>Dr{GiiiZ`N$O.ݮ}W^5m49r2 Ia())I۶mӪUSIѣڴiSmjݺƍoQ}YEEE)99Y;vԖ-[W_UPvmJ4[\.Io   Jx    1]jڵھ}
mSNgϞj۶mNS+VPFF.b^Z1118p`*_~Ǝs8{GaaaO*$$D+u
7(<<iF7t$K.ڼy5jo]?X?s? U˭ުq);;[_z#o}5XʔğN    V     um)66Vo;V
6Lm۶ɓ'o>}yáǏ+--M]w]CGFF/޽{+ BCCջwoM>]
Rv픝UViرڿoڴi


RLLLmU!T]mڴQ:u$I}iP}'.,T&J   [     9Pݮ}̙3Z|y|4iӧk֭y 6CN$EDDndd$<Hr篸
Szg^{뇆:/((aС$?8
4fIRn,N    -     ) ӨQ#uU|_VڵOk̙3fU$ĉnرcyx|ÇQF땖WvmI>ck/.-    X-     +(ƭުX_N:)&&&oݻwK\."##ՠA}2ͳ
'N~P+ .!!Azj99WBBB  tItI}AUvZIRu[   7    H ckҤIoҤl66o,ͽW_}W9s$G;wRSSնm[9sF7nfS.]* aÆܹ6mڤqƩUVPFF~9rD:&jI&j֬~'\R󟭎*bݺu]`QXw   Ɗ      @4lP]v-p^TT}Qeddh̙Z`N<zJ6M?$kрti-\Po6lQF/ ;O<
hzwc5lPO=Z#n6IoaqT#I֭i     v     Tsitp̙3V"^(X-bVG`á;wZv[쾁@`xTT+>kתGm۶n8ݴi4rHرcQՑr6~]FKlQa
Sppvl61   `-        hz$I+W8
uInJ+z   no    `	   @EWǎ%Iorss-N/BԵkW б2   F     f    T~I:
6Xl͚52Mnݻw8
    @x    ٥nY   @%;԰aCI믿nmuIZn    X-     +   6M?$i:rŉHufq   /     x0   oar\Z|qVXl6=V   [       ͛uSRRGM60aB9'Pgرcի$UW]uN

=
sڸq.\!CX	~&%%E{۸8     (    Œ@8m߾]_~6 Ts]+~M7tS%맍7g}:|={H[          c&8Oiii[@y2C
4$?8
k׮Y$矷8
Ɍ3$IW]uڶmkq   7     x0|:tHT^= (oQQQ(6M}$mڴI~ŉ٣͛7Knq,W   (    ]N:'P޼+<x$ aÆ~cҤI?HII$]r%ӧi     (    `9lNTBc,NKս{wIo_~@ѣGtRIҠAdq"    /f     0X  I Tgcǎ$\.M<4ҬY=V
`e   -     L   _v]t:-N:kխ[7Iŋu
9999s$o߾[ŉ_   px       @1(,<$wrԩ.]GJ
fq    @q(    Œ  GPP$pX@uwתk׮9s(--Dl)))nM    -     L  >X@e0a$);;;o\uiϞ=   [     <@  X@eջwoI~5JԢEu4@_   px     3G  xM<Yv]NS#F:*[oݻwKNjq    @i(    `  xĉuСʌ_WIҪUc"\.=ZԪU+uD    P    `[  ֐!CdFӧK[~,N7n$I8
*Ҳe˴o>Iv   [     <@  pM4I7>v͚5d
4%I۶m|`q"Tө~Z;Z(+   no       VZ3g9]g*(@7j(իWOJ^-ZHRRR,N    (+     x-  [n۷o5q
N 筆k.'ByСڶmkq"    @YQ      ӧ~n7m4ծ]dPtt$ir:'By7o^j'O8
P6   Q    	$  P~}%n~rhz$I׼y,N򐝝Wҥ,N
+   no    `  o.2ݮJN =JHH$M0A'={:$Iyj    @A       +44=+T6-o%RWԔ)S$I={TV,N    8Wo    0X  x$$$hԨQΫ]&NhQ" k׮jݺ$iʔ)Ȱ8K/tIv   7     x0  KNN;>_la" l̙+N448ǏWJJ$O>jѢŉs   [        K.2
8D ٍ7ި]JfϞZj:~l6i    (    Œ  7߬}j֬YV^xl6j̘1V9HOO׌3$I=-N    8_o    08f"  dfޗҢEԾ} *			z$IK.޽{-N:u233e5a Q   F     &  o+ `ɓ'+88X.KÇ: ==]\111'+   no    `  `t}:z:߾\ l߿$iڱcŉP	&(;;[!!!zg    @o    0}N @ɿʭPnn-V]V99V`c*<<\4x`Ӡ$ܹs%IO<񄢢,N    Po    0X [Unn>{mޟ:G^{p\99Nʷ ,S^=9Rm6_D(㕓0;8a   Q    	$  Oq+~wN)ClxC9- 0tP5h@4|p\.ׁpBIҠAT~}   7       TJ999YdR%PYztgV`TݫKZƎ+өp=8    rB     /2  J=ښLI
[_WtS>Wo-ȦlG|/oS\\$i̘1͵8ۗW6l"##-N    (/o    08f"  ^}8[I&+fPIRvMetG:ʷ ,fsI<ٳg[^cƌRddju\0   (      ՟op(77W|c>djX_OWjѾSۏQ`>}e˖I&)33Dؽ{|MI҈#X+   no    ` PJ9994M5lQOWQt>V|U}HRRR$I2ei0zhIR5x`     [     LS  PUն7~LSZӀŗn]d۔w- KuQ7x$_TZZŉΝ;fIRrr-N    (oo    0X jҭiJi.nwlWVzV?JfΜ)IԄ	,NFEE#   -     L  PWxnmz{%巗t>V}w-Ȧlyt3[ iݺ.IҼy~۷kƍ1c(,,D@be   -       Z*t{{%NQJhdSVz==J%RRRdt:V^EINN$Ĩ_~    T     xх (t+5J;w+}z-*[MӳM5-JGyDoj׮]'
~n*I7nBBB,N    (o    08f"  BqۭW~iN!;f䅕nSd)iKE&N0ISO=eq}4@`   Q    	$  K{%Tĺ˩tռ}_[ A<x$iڶmŉ_۷o$?^vD@`e   -      P-Wݲx6LSNW@֫yxݳlAv>QPPFI+5JԢE    T4     >  )t+?ɔ8.J^:e|
oT3Fc;'֭[;wJ}YlL   @u     0X *ܟ$jPG*tլCZ]M;G@4h4h Izꩧt:-NT=_{8
P    no    `	 K~ҦW~LSj[+t.){|/([ $,,L&M$߿_-8QrJ޽[4uT    7       *ܟezJO-ҭץ.݋=خÙoTGyD			c*;;DՇRrr$UV֭ŉ     -     ^t]  2+~'m^6&F,E!fm<Ӈ3_ޥ|Rl6=󒤴4͜9Dǲe˴o>Iv    -     L J(t6'Ӕ'H?(zŶU˷iL@%ٳZn-I<yN8aqtg$%%%cǎ'*#   -     L  +n^ޛO:ߔnbƪ{do?xxN@t{	=s-ZmJJi   [     9 J(t;o$S1	uߕnS%zV=)7x:u$I5k,NTuhĉ:m۶'    T6     >  M    IDATW}>dJ1	u4zI;-z5myL}Zʷ *ܴi$Iz-NSu͟?_$M<4     +P    `[  Rҭ(T5MS1Utմm/WwQPZlOh"ݻDUOvv{9I߮$	   F     &  ?+nZ_E2M5IԘZUtդm-%{]YOiK5:k[ fҤI
RrrqٳgСCX   7        t-/ݚ(>BOWҭW꺴lveҖVد|b$iڱcŉLM2EԳgOjD     P    .  ~ƥvޯ2%Eָ%7Wҭ|G`Vʷ *г>pI-NSuKJOO$=s    X-     L /_Ek&Tt|m=fE:ni;'[Mg?x[) Ӱa$I۶moq"wqH-ZX#   -     L  `=4r
n,ا5L):>B6[}{[oؾ?((w#FPzM>]ǏfӤIX   7     0s _n[oaAZzvTҭWvyqAv9O_I@׸q$IvҊ+,N5cIC=x    F       TJ+RGoLSkkB5.zŴkKs|OK|\=䓊$=͵86m233e5a      [     <V ŕn{J)E7UҭWLf>قm:((gz%I׼y,N5k,Ic=b   Q    	$  *_۟i2%5ITi\-]Mo_			gyF'/&LPvvBBB4~x ce   -       ŕnVI28[|"X1lSNimMʷ ʍfӌ3$I>}ŉǡC4w\IO<(    [       Pi+ݾ1w>XuX2&"4y[jܾn]`r2NA@ҥnFIҴiӔaq"0~x(,,Lcǎ:    P      TJKg7dҤE|֫@6=K_ܷB)('3gΔ$effj	ށpBIҠAT~}   F     &  xbovڼ$S1+m%l|\nZݻw$:xŉ5n89NkV+   no    ` Jptb/ڼLSjҬP-Vt_|{Z_YN@6ml6rsslu۷OK,$
:T'         >  yK+.ֿqXZz6nK>A-خ2w-}J/_]vYcƌRdd
fu    x    ʷ  TJE9"TL\-M{mY/榟ޔo\'*88X.+ Wݽ{|MI҈#X   px    H  bKs~ѦwLJ)%Q=G'lWni[ (::Z
$mذA۶m8Q=z$~<xi    [       @(tڜ_qULTL\^t{O.{X۔T'( GVDD$TtΝZf$)99Y'    +     xE ܔX}IąkkQ@
')7v^?Sp~ի#GJvءuYrxWR-N    go    08f"  墸9i;2M)&.\3(ݖNWʰI?؞)8/CU
$I#F8Qھ}6n(I3f,N'F   [     <@ W}uoztąEt[΢;]?,^}*ߺ\.ʷ JKݫŋ[yWQ~,N/W   (      mX!ĆE)V[CcYg+z_ʷ J+..N4vXZb|ڲe$		    P2     >  W]_!ttҢkUmj
ݰ/)߾N92e$5kŉ*SO=%I#<bq    @U@     o 8/ŕnLT5JҨӕʷ~-sve˖ɓ'ĉ'*_7o%IǏn81    no    `	 s-mnsrr<Iƅk֫תN`#)/[ dƌM:4kȑܫ+   no       [,tc2%5
WPHWGʷRpno^fqn:ܹSfc    P6     /&  II9j2ei\M~jJkJ%-ofދt|7[ eK/I5~xkÔQFIZh{4    -     L T%ng6w\ؚҭhع|dhNPPF-[+.X@8хYrv-I2ei   F     &  (YJ46\stg:uKlr|L2Ev]N3oتr)99YԪU+uD@   [     9 T%nSg
ijWC,ҭro69RP&qqqz%Wݵkŉ˵o>IԩS-N    (    ` J,ݦ
d*6.ttn?-}\&,鵀-2?~$IC8Mю=ZeNSǏ$%%%cǎ
    PP    `[  
)t;+w	bckjnҵKIvCcYk>[ jРA^>֭[mӮ];EEEUv<5jԐajԨQ-ZmJJJeG<F   [     <@P={(,,Lar\y!C,NJ3Si{'eRll
]pRRtJ5o{)(ȑ#!I8]taUN),,Lebcc%I9998q$Cj۶e   7      @$&&jԨQ|PT})pR2M|JU%5*#&:((VDDƍ'Iڵkڴi#ͦ7mceWƍɓ'[
    P
P    .	R$''+113k,ծ]mo8^6ϿmwItRwy~w.[ %4hjԨ!Iھ}{
Vo
wIRZTّ     [     <z饗ʼ}uwV`"T}15Mn8^6οm5qtҿIv\'ӽķ((S͚5U6aaa^Najݺu%&F    [     <@P:uRK.44T(?%ng>.Tll
-j[ղ'kN|[ (44TGZ]-ˊ׿dnJHT   Q    # (55Uk.qQF)&&mLIq5m.>W/[ "9sS/
NT2o_Yf+0    :x    s
 ф	<11Qɕ0%n>2etnQ.ZMWt-SNe޾VZtu-vzgw/T    -     +8Tbbb+


D)t#Z1S25[7Ĩ~oޗ),>>^6mҦM_uԩTv۷w}3nʈO|   -     L 8v]J{vY8w%nOKaz}^" sW w7ʷ@ԩ{M4I5k,v;QQQ%^oh˖-K+1P2   F      8OڵS߾}]RRR,L]I۔9h͆2MSaZL6`˷$!׉,vʷ@

՘1cgs=En[ͦhϞ=ݻ     [      8/."I҄	cq"t%nIך
%46L&P
poZ-~RdM7n+W?V-
\fuZ}JMMUDDE     [     <<\tE8q?iVJUjvcLIaZ27A(BEwI-?!lrSu- I7|vڥӧZxT}׺k-T|   n     &P(EG}Tڵar\Vǩ6"(<]I۩s2zcT0-L'duѝIKއu]^5@l*I

r_l6*)jlxl6O#FPddcK3fPTT$1F;GI]    WS     9B5-?DRХ^JxK?OI)s2fSd46L^JEd,鯽͖D{wHUZ)E]EIz%hٲeà    E/     >@58EK [5C6(tQ)[)5
rJ(E;SoYYjj[TI#{YS     T     QyKv_|add|mPJϾa46T+^t2:ro5SQo
T$QE[u:J|`oc   [     0ķHrC7v].2eTIM*pM:i0Ϸ-|Wi{#J>dJY(_]y^^2e%S6/oJ%l_esY>oCɯoz`3ݮ=%(^I3K2uilx%-IIjd~o~Iƪ!
|*$vl)UXgb1_E}w1eGo=Wbsy㡳ex*5^</민6eW0|Bi^`[&^}        TS$grw`[pO\.72m)>i<%JOn4~8^o/*Gܾcܞ%+Fq?GqSTJ=Wwiz8}{o܏qt|q9PJxn(GԬiޤtTG%df/*j_/-NJCwi!O0}>7*+]v"߂
9(.O㨂yTh</ʓoa|/<~*<*oIwwYZtBmqk-:,4*1gf=׳rʒ,pD    d%     /E5-y$޲.t!Xͣ힕
n>cgu}gvE|ｯ|+nf%ezE<B嶊z>ex8}o,IYo+{{r:r:sT}f1w4ռiz%-.HIt@{pwKk(QtJ2^ߺ9|Ͻl,sO~Ny^|ru~s7(*_UL"_sȕoezʔ<^)qYY$Q`P    M    9CT'E5p0u1ڀ@\'OȃJ=VRvczwKdJcC妔nQ.hҩ3:rҪS_˿dWDMC)eu<Ro)gL9ݞ7@`2-y   !     `ՍoDIQH].T;nɕiJbCeVEroKvyF=Corssp8
s+|aH)oH#   E     fP gUwULpJ,nM5k_U:v:ӣbi33JkNSEP={Ύ\
    Q    uTc[0xJ)A٣JO:59$j4T^nJN6]6D(߱#Pٱ    (    a-JLVyFŏJ*ݎuBk8dTz&nQ)."ی^3[>Wyq0$   (    AU%\=[2MS͛hJT=&K.
)REx	<;yHv   (     MjXx%nG:[t-,jtd3Sgtg(ϙIg<@    
x     a^GBh%nSO靭NԼiiLg,*
gt-Cd~7   @~o    `UES&mT))t;*[vݜhJ=Wed)3[{N| ~+ޢ >   7     x0@`0i*^A%n3ݥ[KnD~%j|d8=RbH<$~;   ^o    `"V=L)yt?Uj|dIgteSHa     ?     aQPs+t;"tkJhf7tVj|d7<ޝX_ٌ%(D%eMEDw$doPYHR	?ZdNKH%ː̹~99Ì1s^c3k^׹r'| }0}1    x"x    ELBB[_CRrnwz:Rw, Y[!*gd   -     N\@?0h<wnL׊L9BK)-OGԲ"3.Q	+룄oq`HΛ#   B     \B^o3_8h}tIBȓ;["LB$o    -     .\_0cy&%%)1OKЊ/$Tr0vBBn&*-rCjK        U?LI~9gr%I}$ír8J
>X%iqo<6[ exo        8q	9e=%QU    IDAT1=m,nx:÷R\݄o/=_D        p~x[VMGPbTEr_C*c|o)-n:-@x    |A     ~Lvޝ}+?õjժt_߶mõk.Sԯ__>_~=rr5~,'[ouv
iu?K.y#hɒ'O*<<\6mty<FS͐2FMv2nk?C'O3<
W߾}w\iO~'|ӧgy]v]+WT۶mհaC=7n.\eݨRHCFlRyK#||a̘1
̙3}gӦM
ӧ%IWVxxΞ=Yp   '[n7     [U3eH_|QŋOre
o-[o+W??Ç+44
*dGSӵm6>}Z,P3.$$DWXXXFn_zEېauOiL-r7|J5krҥKڸqwaÆUVҶz>Wddd5g͛7O='Nhܹڽ{.]zC(Cޑ~4DWUd9.oX,σ?UFޕ?\+VիյkW%KT#.9Bph        ߃]xx	UX1G[V{,*TИ1cst_՛oy#ͻ%KjܹRJӅiڴi9ږ/,=Cɺr%I&[d"C.\РAtk̙*Z:(**JoׯRJJLHH￯f͚H+WN{+?$Cb:##6A3cPg-OK7oV||
.]h۶mjҤIp1e:?
1õq   ri     +r3ĸj*=#OԸqc5iDǏ5` ;Vzdӧ멧RDDy-]k͛p}7m;+&O<z-IWN?W>}԰aC5nXF˗%I7nTxx{۷Oڽ{qTTz꥗^zI-ZЌ3n;*GGjذZh
6~ȑ#㏫^zjҤ
_KstivG6Y4MSڦ5k(&&F
JR@@&Mx
\ԩv~=;]Æ
?
K.:x<>fϞ.](""Bƍi3gZjYfzw/!!AӦMSO=zSfmV?Sʕ+?C7V.]Zrrڷo-Zi>joÆ
?Vxxbbb|?j߾zRJۚSBX-(bHcQ%''+%%Evoy
^Z5kT͚5UJZ*4)))={5k
_~xb儇ٳuM>6mÇ_OogϞz衇Ըqc_ǏwK-Gf4L͵Ν;w***J
4P&M4m4hjԨ6m'z-Z~jݺ֬Y'xBرcդIEFFgϞ\xQ#Gc=nZ˖-Z/c ݮsETݵ}v?>Woh2    "     ـ0#Ggi~Obcc5o<EEESr$IvO?_ٳVXgyF&LPDD&Mw}׽˫QF*\poSllΞ=__h	*Rի3f"##|r
>\7ovWlܸBCC#XD	խ[Wz@3Fիhڵ>ԩSҥbcco[n֯&!!A]vw}W_}USNUveM4)v$ӹBj)U;
4UM[Э+VL5kLJ*i̘1ZQz***Jo
*>}h^quI{+~[T=t/^2ehz衇xb-^XڵթS'Yƫ9rVZviԩzt	
4(@$-\PoVI&cǎZr"Q:p>#I	{*X`e^K.UXX6mUVPB>ŋ_v.K.jUdddy3<n{ubHq2!'"'NЁԢEIғO>o&M wтԲeK?^Eĉ3]7|^zէOt۷oW׮]#Gj:v:uSNyMY-Gf4LϰaԤI}jٲ-Z6mŋձcG-[}ciׯ-[VZiɊԛo˗{-{2Csٳu
<uA_ъĉn:I&Nso뮻KV_Y'jJ
    l      n" 9+*TЊ+܏ճgOw%11QƍsEƍu{jԨ$G%Gͦ%KSٲeդIf_DGG+::9Ţ_pWNO>{9IR2euVرC
Rppy}gݻPrrl٢-[bS5~xH4h/RS˖-ن>@EӦMS"E$9B۷wO/Xb:t*W,IW~G۷/[a64MS)))==Y+w8B鋉T.n%Guֲe<˗+,,LԨQ#uQ'Oqd={VK.uWhT4m4͚5˽%JhZ˗ֳ>+ISBBB>}駟v/'%%EƍҥKK.i޼yz5j(Iz/Y;WV-hB۶mӴiTT)-\P:uRZݯϴʕfSBT|yI4yd-YD
=ܓ47SHe.0m9J)Gڠvz>SiӦW'OUV72}رw.1ю;2\ٳULM2ݿ+VLGֱcL?eU\YSLqnׯVZiΜ9=z{ӬY3jJԥKX:w,}:x7o?ꫯ4` mֽ=v]3gT˖-"qӖg ^И1ct))SFS֭Sxx
(2:{VXN:gϞc||6n^wVbȐ#tK
   -     N5x2r2iݡYOiK]QQn6ݫw֥EZds Vڶm
nСCZx5k!Cf˙V/^\͛7ק~f͚ڵk.^XjJZRrrɓ$ڰ~ծ]0*U讻r?Z/^,ɧNұcO?_KKݮgZ
C%Jjʹkj{Uxx;t+9>c͚5ӄ	**q_{Q
 IRʕݡ4I[mƍU~}5oiْ<yRC)11Q>W"""dW_õCQ6mꫯSn2ܯjoz\-ZKjȑz'3\%,٬M_KqJ^IrYȗwkתq2MSqqqljР֮](2MS=>h۔<xP۷駟JWԳgĉ۷WQxqEDDh޽^Ϭj0=Ӆ(  Lu	

_%IJ6jH˗/Ç-qHڦoZtN:HEDDG^mh޽Kfͼ׻O)i-   @     T1<<\+Vi%Jy3'9E/^<*jwUBs_ްaC)SFGbѰa|^Vz=6=]NmܸQ5kƍUJw5DM4Ik׮UBBTF
l6K.	Hiߣ˗kѢE:{
,*Udi=o]\tmѥRqi5-㏙NsQ{ｲZ~]]|̿>&&Fׯn.\yO?Ռ3ܕgL޽[SL? s=2111A3g+VL
4кuԠAL7\-ZmR[I}l#a(ڲErWWSvٳgamذ!6mR˖-u%IRѢE^O}_n\ŋazu>:+}dzcO>7~гMo{$
04f-^Xm&I^{Wҵ@.\}L}]Oa8f    F     3o s\<p
.sΥ?k<+VLa~KuWB-C;vիհaC5n6dWUV)**J;vP^ܯ;ڰa|нZl:nt}LLNI^P֭_#=zhܹF61
V΢@]5l65DDDh:t4Oj߾:v쨨?gϞ8||PB*^pW|+-X@Æ
SZW_}UkֲeTBl6[N_}U-X$i'ϊUR%-\P?p72\cY?gΜ˗yo	]')a+אfVgYF%KرcӼ6l0ZJ-[tϝ;;=+XPY,?y4}vU]d4ĉY#sZP!l6͛7OKJ/
(=zGߵc͙3GCՊ+|,YRtygkm	I[    Hϭ=e     l2D:u(>>^۷oz~}jժiӦM˗n:*UJeʔ`M0!
9y抉̙3ھ}TF
=̩Stiuվ}II:~?ժ(w$))IsW.3CEEYl`n5h1\m7n\PBBƎ+ͦVZIrTo#4ayi*^Kf}xx~~?_|,Yi=zhĈa&MsJIIљ3gʕ+ԩ*U^k3:xl6/^m*\&McǎI4j(Z`J*QFy}xV+IV[QF!7YLI[Q+P(YeXwyܹS>j֬yߪvڲZڴi2\Wjժiǎ^}տ^Ӈ鮻ҦMkݪ]v}dvWrrbbbӧOk銍i9.\?O>DTT)iFM6ӧ%6Qeo޼9Mu86   b    $#.oذ!ݯ,Ufrb&Ml21B]vw߭ݻwϺ}gZ~맲ef_~Y{?O5mTaaa?e]xQǏ]%KT.]4m4͟?_/Q˖-K3O5TF,mfʖ-5jhʕVYZ5mٲE~^;vLf͒ii/6lؠ={k׮9sW^]WִiԴiS?^|N:lV)Wu=C6M)))^>E
R/h;EKo)QF_׳>͛lٲ?vZ=z;ީS'mٲEݺuK/P^Zogy:tƍս{wuQ%JΝ;|ru=.߮phܹ*W*U
bhѢE@n:IsUhQuQWRR"##uE͝;Wqqq$I'NԟS*88XCU=4o<#٣+VEY?'NɓբE5i$koTyylEҕ)yV/fjEɾiݺuJNNc=-Zj*1B/.\(ͦ:u?O[I޽zW_}UO?._3gf͚
ڵkݻ}駟V||ϟ/ժ.]mUT>2=S
Ν;RJ5k,UVERJVRRʗ/cǎiڵϗ1PXXڶmEIrwޭ_ou-q        
1־},om6f̘ӧkɒ%xʔ)~m۶N8;w[n.nݺ7o}mݺU111*\W:d}ڵӧ~>@O>8k׮!Çy^_ijʔ)rJ.m̙3ϵi8q|M(P@?WFlR?T%-[jĈ:zT-j?

BKv]iFSy}Xo6l_K,֭[uY)RDUVUzuK5m4;JIIQ*UZF}XX{]&MRbbʔ)Au֙.CX,Zf-[`կ__}fS5vX͙3GzrWnݴ4_ңG(QB+VG}B
)<<\zR_jիʗ//QUVZpPBYj$K;vL5jjժY?vܩ5k䘘)vZYJJSAB w-g5k֨\r˖-x@6m+kVX˗נA4jԨQ~}EGGk<x
.z=?C<y͛!C(88Xz| #bє)S4k,}:w3\sژ1c4c-ZHϟWXX}Yu]c(hZhjժ޽{k*P;,aH)    0s     R1MS)))JNNVbb4x]7JY[T404e:QA2$}F!l|r<yFWZ:y8BwJIIQRRD9NХX)4HׄnQ;_HJj\M)3{(@2 7\x[)b~]~%ZyfEFF*,,|ӧk۶m
9!1]xI)A
+00Ы8ǕuIRד\1   Q    -CL
?    IDATV!Oabbf)  @AAA


R
6-"LpN'vs>j.\+0t%Э+C$((HӦMSe}4{l=y"tb@*z   o    pEs1]aZZoWPS	vpN!|||]N2%5&{&[-8pVOEjܸq۷V^]_~ݼ,1J1   pv     u\9#0"aLtoS4KZ
8Q#&fYdFUeN<I{&M͸aaH)    ިx     E|Gs),[ "zTEp6j.Z/CRr-8c         8݀?0eR
y|	VyU8TKg!·ȻK0[F np 
   8    H͑S[_÷s[SOC_JYgY8k$)}21HΛ#   B     cy|
pECM%z·SnSU1+[LB$o    Oo    p:aS9+kv$.h*.TEGٺ8{dJiTU]D4M{~<    t    ,)4	e%|[0}M?zV
#ezB p2D[x#
   8    H͑ǘ\ɗ}5c@
O~-staF:[܂8 yӞ/@w   \    #Bk9 M`)>~Crх9eЭmVW,@ K9/    Oo    aS_Y600
)

ji·%g;+ݚ*-    '     8?0eR
y
;oo*z@BCL'k5[ӮЭa8B3<o6   @     '. \4GC۴|	_)HSb*.-?<I2*pKnp=_D        #אK)MHq	v{J-n_ӹ9$RDELyI    -     .\_0cy
Yyo-5÷)z)/[S}QȊ
&t<#pz2    D     'L$Seε\·5*i@9·q)+'	"Gtn
I2[ ȃQވ`   o    pEs1Jk2kv W֮·'.90$#
E}rL=_D       +Gȧ\a&Pկ ozi

1	"G@qVGft$t[Z y   -     @9ϋai5rAӔ!Ӕ!ɐ)5;%ޏ-)),2%tc:nW:ӹz=^^d8__=Kչ??c~U&"S)s<NBja4MY,[QYzw`cWl\9S˫fRGPg~FTP/EyLy/O|c!9oKGHfy%\ӥt>Nq;u󥷟3_eX^~\igz9w,_/%\H]    [      q$Ş8c0
å_w%T=cv׽^okT!O~{4Ksv,R]tCwuV]ڮtt֟p3|38^wτ-K)녾rYMl)Pg~.Y"*ngx\erOq5ETyCtO;Zikf8ɴ=~5^HӞtkd<O=fs{
_/xOۗiNnH=^`WgH2eڼopeJ       F[G I6ujvd%izV<`ɔUVO4e8/8q$+,iU),xTxWzOSPS_*YNz,_=.?ce8#%u=ezUsv4fj0Z-,,JhoW&ג [dW̜ͲHDTP!BC<CVUᕒձIL]v]==pﮞ%EX|Nro\}4Ҟ_?sd| ]g;2ߔc;]ϵc'OЗ_!S϶n )7ǩs7YL1pw|ǩ7=[{ٯ1a8Eχbf(U4M@w   p x     ϸ.{I.JN6biTKHyL51CvEMd
"soy=AOR\\:EM>5YWP/ExkZx =R3III)JNNqo㤴%1SX|$iB*TP.?8ȯ3l6
`        B[3AWXbf$H6MVYkv8^}LGW |kEcYQAE't<&%׸u	
	

r8'Lυ85M       o</l6w-P+@+	|\Aro;>Eo/s"BȻ\g6MKrG``bkSX5   -     n\RG~&="A^KZeA෯(6.EzEtЛRLM*ֿ[MkGyZbazU͓~ݿ   o    )Ϫ$w0	neπnq!ۅ۱Atz&YdVEzYօylٸye4_    
    7e 	[aQ?ioNOLIU,yB2:0^=)*՚o     }o    p".*PG5|;f4})G͟v/[?ӯ>pT-N[GFUqsS|i        G\X[SJP\]]^AWR
·~Ae1OB;7[ŧ   pV       +
KZVl6*00PAAAr9$XBxfirC      $    *J CBT DKQרu\n9n}?CvB      $      _÷o.`Cqq)N6a:1SVO}-  ~e   -     N\@ #·U
hGGum:1}Iuʪt*     [     r soW@#*m2}NC	          `
 )|[{o{m>qtJoXJ      E     '#  [6TtoSou_rGvIuim	 4_   p x      ml^K6On*E:et6n @    o       ^|	V9·q)"||;d~E2)҄n     k"x    %o p5|;dHag6YQ=#JB)2Ӟ%t      -     NdI  KpaJ+>.E};#Ua(NinM  \+   o    p  ieݳg7oBW2=[·#C>ұ[eRpҺ-  #   -     \9  SoW\zJ.]$СFQB3|{HF*G|}-      Eo    0S  iahܹRRRYfiĈV}[[%
SZ      ׅ-     NdK  \llZhɓ'K+/BڵS``t_0;|jC0tx'i60RN~-  2W       $  2vIխ[W6l$U\Y{Uzd*|[LZm848sI!O+[  u           LٳGjѣG%IM4ў={T\9Y,Y4۪
b

8÷d֏30.
O      n[     \(y @+WTÆ
u9IR~i&*THܡ÷oX1X~=I]gmaHjߩ
ѭ      ـ-     NdM  6rHiFW\fӒ%Kbqײ+ykC+(P|\د_[R!n 
~e   -     N\@ !!!AZѣ%IEծ]4^H
SPd
OG	臙%*PNC  dF   [     r ۙ3g5kH*V})222y|	V^H+`Cqq)osaY;$Ph;T-          `
 :rjժK4i{|לma%lQ|\^ﾗm67SC#t{Ԗ
)T-          D ֯_zӒ>}hӦM*\-|[X}PPE·7
::2CKҔ  َ        8q	 &L'|RqqqZZ`L"%{vX1ٽY~a
2)V)U&t  r#   -       do^nWeu醖Kr=
ǥhpof1[IP)O      r[     \(y #.\PFtRIRŊw^5j([k6jD)g6YCRWlԑ)[%*XU҂-      p    ,
 _O]v%IjԨݫ+fz|
VJAA_ڎfߘM:<ud*TNnN  8W       $ ?ؾ}ԩǏK:u-[p9>_·U/Gޡ@gvxoӵw&Mq#t  nF   [     r .#<K.j*::Z,jTzSAb5npʷM.0\6@զ      n6     ~ vG;wVJJ
.7***ꦵmҲMֈ_o%Эt\jGG      9    D6 ]|Y=%I˗޽{դI_·U(#J+ P|\Fu+N.CR%}'tL҄	 YVB   Gq2   @     '.  'Onݺڼy$)22RSŊsM>okަnK+ v~Эd`j3
5La(&&FSNjuo	    p x       О={TV-=zTԮ];m߾]E:oc?aP0=0	.U})Sܹsn     -     . +WTÆ
݁̉'jɒ%l47÷ed(!.Yoto·nK2Tzj:CAAA
ѣD
:-      p    
  ?2dڴi+W`ڴi^}nV|	Vy^q,M._Cs9k[Эa*T=L5<
wܡ^{Mo.  wܯ   8    H ,..NZҸq$Ie˖՞={ԤI\nY|
vQVA%&͗O4|[[/zC*\=L<&tkZeZ5x`-ZTit  q2   @      ӧO^zZf$nݺڿT-oۢ4.JKҘv펡/2$ړ0tkXT`AM6i֭       x    7  yUV-9rDԮ];ܹSŋer
(>.Yc^w	Qdp0_#tkP=T|yIR>}dsu;      -     No y̚5k3gbhZdsiŗmEqdyJM[ |}FZG"Ջ+|rSBK9>   gܯ   8    H 䭷SO=(P@׿4pn
5|⨻dQBluޮhv۰MmZnB.mڴQڵ%ICUBBB.l	  _   p x      y+WԦM
:Ti;ݻլYnZ5|aTyق,JKvor˳thn	@,n]%I}ݛ  _p2   @     '.  nuΝSÆ
rJIRZ~U^=[|SQwhQBlw·_ިC4IdҭH5o\oY  ܺa   p x     W  yѣGUV-ٳGj׮]se9Ǘ57*( PB\wڦ-ЭLh0՛
n]&N(ŢX
>&l	          `
 -fͪ[N<)0ohŊ
8_÷Fݣ N:vo7٤˔TFq՟W6  BTR%uY4{l9%      waQ_3(.dEQ3=	KjjZdZ.efRh`Y.YiiZjjBd?<^G\TT,2p<50{>3pTLo    p*d 5o<uMϟ֭[_fU

nuo/kV)~JНB6_|Qs=W<  TH\   8    H $##CÆ
رc`ũgϞffoo
]o/\ѬgLICn֯vxV3H֭[8?  PQq2   @       JuIK.$5nXSXXɕp­rogfzIkdHְ-Эs=իKFG      @"x    _hy (>f͚iΝH޽[u1ҡۇ^}rYo/&oc'iD    IDAT}}aHA
vn{Uz{{{4t+I~~~$%&&jڵx(       D     "f\  (;wYf:|$iĉڴiTbreK÷QcU˚cB!vn<u1bׯ/I0a222<^  Pqq2   @     'N  ̴tRuI)))TV^^zcA0za5?|lx<Eoc&oUJrn_Bd/K[oyl  b])   @      Ld5n8
6LQvڥ}]ZWmvvZwPPjv+ЭK^ԺukIҴiӔm       
[     l  ϫk׮z$I
6Ծ}Լys++;
Q
\G)|eL 7)t2|Iҙ3gp      \;     8I tQ5o\[n$uY
		10[jOtCyc۔[7RWۚp=sرcź=  P~q2   @     'N  JJ||tAIO?X\YUѷ÷Xv۵wdRߪC.gϖfSZZ&  (^   p x       %h͚5j۶N>-///XBs̑ʿkэU}MoWۻ_m#jUJEVBCCOJ/_ض         B[ @1<y˗/+((H;w.\)tvz#yؔz?÷1Q_iɐ@uzЭKTTd3ϔ     -     N&d`  ŋ襗^$zJLLT֭M|*L氚H^>V\֛|_㪶%+}d$CAs)
JR5qDIRllvaJ  ze   -     N@ Ǐe˖ڰa$}JHHPhhs
߆ѷ÷o*|VU]^Ԇn]Ə`IѣeM  -\   8    3G bo>Cj۶m
4۞;·.Bo7;CT9J}V|}}]8+V\      P    v lذA[֩Sd4|-YD6*oD>V\҂nޥ%0:Be t2tPկ__4i$\      P    eb  eիW/)00P۶mȑ#.*L64D^67؁MЭյn%>;w$رc7o         8q	 PT/_V~4eP%$$}fV.|ӛǦspFwvS%!Zn~e*t;J^z%9s  @YP:    %-       xӧնm[YFԺuk%&&[o526|D^>V\;lԪiH2Tŭ۪n]^uIRJJL      (;    B[ 5:x/I8pvܩ +Cv	q"U}I(rv/ӡ[Ijܸ~aI[o$s           8 ںu7oGjjZb.
y(Tu1#\>6PW[*V@ݺ̜9S޺r办}Y  +   o    p jڵΟ?/mܸQǏ7,B~[Y-tCX
~W>>>e>t+Iuѣ%IWVbb Ҭl   [     8s J4hƏ/ݮ+22p

^:zhAU,7n3׿@IҨQL      (    `d  gϞUrJIR͵o>5lp-
z{{÷.mf2e$)..N6l0"      t#x    S  JÇ8IR߾}k.ըQP÷6-KRJYܖЭ˘1cTn]I?Oedd\  (^   p x    '  ٹs5k$Y,M>]WVJ.

Z,_6-[I+"I:t}]+  Qx   [       (ҥKթS'W֭ɓ.9PkZs|e^^B.Tƍ%ISNՅL      (    B[ @6v]cƌѰaÔ:u(..N={44auy%IN̙3M      (    TN34 ktyuFӾ}fre()mn:v{W4g:u  @i   [     8 p9z7o[Jz쩸8\PfΜ)ժ.7  Pː   !x     g  ),,L$M2Eׯɕůq<x$i:t      [     l 
kʕj߾N>J*iՊ2,DEGGWv]Ǐ7      T!x    η Pa{N
Rzzk.ҀWn]=ӒM6)..  @i   [     8 ŋգG+ƍk߾}j޼ɕ4iW.I5j  Ҁ          *Ǐe˖$Iڽ{ԩcre/Hj*+      J      *}),,L$M0A6mR*UL(z)J&N+W[      P
    g&@anZNVX3gf4k,IRRRϟorE  L\   8    H P1DEEW^JKKSPPvܩ]P*Gᒤ^xA)))&W  %j   [     8s ˗կ_?M:UaaÆJLLT֭.
(\nSRRmr5          `d ;NR۶mfIRΝPsʀ֭[$͛7Oǎ3"      <o    p ʥ(,,LѣG+66V&Wl6\g}r  	^   p x    ' ԲeK?~\6MK,ѼydQjԯ__O<$iʕ:p    ]      P.͞=[w.^@m۶MC5,̚6m$9:G      [     \hy Bzz
	&n+44T			j߾٥eZppJvء-[\      P    d3;{ڷo+WJڷoDz&WǏWpp$iر&W  J
+   o    p mVxx$ICնmdre@_|Qt!{&W  J
+   o     y;wTf͔$ͦ^{MK,f346lׯ/I-      *     n eҥKթS'_1113fejUtt$)))IV2"          B[ (S2224rH
6L
		Q||:wlvi@קOJf̘an1  Dp2   @     'N @ّN:7ߔ$nZSÆ
MV&M$I:p6olrE  q2   ev       p5ԥK>|X4p@-[L^^('OTjjjnJKKӑ#Gton      \+
    -oԋS=tYY,͘1C>eڙ3gr
JRΝio     P    g&@rJ
2DR֬YH   *C:       F[ (,X:u(66V76*    t   8X.      q Jz
Wbb"[       )x     Pj,YD#Gn߾]UV5*       @EE     'oTYrq&MLuWsL_~l٢~}ƍ˲Z2CTvJt  !    @"x    
oXv}Q
/$t7ow8o-ԲeKIRzzTjժw     f        O0`v6lJիW7, *U{O{u)88XS[      t     P*:TTbbbTV-Kԯ_?{ڼy|ݵkvܩ'O0[njѢ{K.i˖-JHHЙ3gTF
kN;wB_=      >o    p" [hkIRttn&+YӦM?j˖-jڴn\۱cVZ]W^JMM۵d*88X;wN8=zvvZ>}Z=P	?:  C:   $     PZ uiM0A#7~x+_˖-Szzz<yRڵS޽ըQ#5kL
a+IJLLԑ#G4tPuEM4QեKرCN*ɇ  
@   p x     g Tx駕,ͦ+Wf]\k:v6mڔ<РAte=zT			ڹs$ú6meVZ           `:#- }Z|$i	jԨOӦMղeKJ>HPppn,\pA9V$)55x      -     N:iM&I[/[B߿<e˖qvϟ3Fr*UӧO+>>=RRRr799Y.  (=A   $Y.     ҂ `si۶mn+UdrE 
O
҉'k.)))ԪU+5l>x$0ׯK.iYֻ{nt  Pz   x      T֭SFF,cv9 wjJ|U*((HwVhhO?i͒K.I5km۶iҥѣj׮Q۷oWTF
S            LKZnի\
տ?%IEO=֬Yw}W^^^k:|v*ͦcj/tժUKSǎM~T      @    d3ĥ*&&FԫW/nݺ[nNRfΜ徛nI<Ly,?W\YЀ<W,  ($u   HV     - O?T/_$j    -   @     iv-Ioj        [     l s1IRfL           B[ (qmppɕ    +   o    p <   @   [       0C$            (5hy %?Pzz$VZ&W /7p\r
6Lv]O>ZjuM      B     ' %رcx^״W_}d{޽  %͐ĿN    jv     4uYPzUZUt+  @   p x     g a=      :     n  Pdo     P    B[   !x @   [     8  9mrrɕ   Oze   -        8///IҥKL                    @>    d3     r   [     8     ;W       #          @     #-               (-,t  *:t=c%I:vc֬Yb@3w\}9?u=z+ӧM6ZA   D     7  \ͦ޽{W^yΓ/2SN%tT`}ԩSuܹ<ٵkW:vH0	[   jv        zԵk׫ZA8qb1U,		QTTU-SE     [     \hy  pM͛'BϿ`@4j(EDDzcǪAX     #x    L  &
4s=Wy;sE ͦf8oHH&O\U+   o    p  8qb(k֬ٳgPE ʂ=+  *W       #  "т'::Z5k, ӧOwlٳx        v  kұcG
<8i>|x	W,Yf͚봀 ͟?+     oo    p  fϞm6,X fRU J!Ccǎ94iBBBL@v\   8    H   EWfMEEEeoȑ0" ełA7nȌ           Fچ(:: 
4رc?g    P       aٴ`l6͜9Sf<yBBB4x`ur          (-,|f"  apMIi֬VXK7%ch"	!    x    t (\ٿgGfQt[0dX30GS$<d'p8b         p r+<@Y=L+)(rr+#        v  ʍ́8ݮvϮyZX,ZYy^$c
JAcDy     G     '5 Pdfdd(##C/~pI~K!Ȑaed1ǭ2[>}YQ^Wb>{Z&le~_ʳ}9j7fF#vZ״%CV9ZkU?'ǵ-4{rQqnu<"yWyGE'qzr;ͩaQ)h+ͭ"j&IqA   D     7R P>e}=?9BJV#dE2V]VK
ٜ:Ő1幜ݵ!k9gs=~ȼ?ٖ+L۳0k'rYΖB,r/Wg<.2j+}a[v6==]~m??\7qxqq/yo=/z>xt,V^];cz>/v~[>/Nϼݷ(.pQ%   [       @#)8Ȫ!֬(cdΟs>sCkNuBbYG+^#{\Y;-JFǑ#0    IDAT|;NPo]\C~VrX5֛b!S2)==]Vݙ0geSŢjYtsmkK燵=Q{w\;ȱ~}y[?"2vRJ./Dlq    [     \hy @a%Yյ{. J>Dwj]Z9̟{|=ʀxJ	Ǯnww    \    M~  (?\])]_o]sÒ6{@dޏp.wvl&xk   8    H  _lݰ+!1ű(3eK   [     8s @SNZݣqEYY9!@Wcc    \/     tF[  Pnde	2B9YtŇ`3&¶    )t    w  T|^QXDU k tkő   8    H  TW|BG(G[њx2E   [       @B[?ِH	    )o    p  (8    <-     N4 "d>j c@       	$  *++?l;ZX_(8NQtķ        p 
O{#ِ7&0(8N   S    `d  oQv@!    S.     ҂w p~w/WLժUw^IҟZqe :ޢ< 
   p-     N "-G"w&08E          *:ޢq͆,DL`08    O!x    
   l@Q
`    )o    pQ  %-PqT(#6   @     'N  P8_
^Q~8fњV$cUǈF|   p x     g c\EGGkԨQ=z^|E}JOOww)1B{1ZTLRѣPlll׵l2EDDhѢEN뭷QEZZVXGyD:tP4dmڴIv:l[*?(~75o\m۶sgݺuz7e:uk&ɳcֵX~"""|{^zBwzg+UVo\(    )o    0 ŋ~zլYS{ujժiڵZp{>5jHUV5ZTLmʕժU+լYc\h:yʩS4d馛4b=״i/-Ζ_7nTݺue6oޜ</VJJJRcVq-Rׯ_\%''kƍ3fU#    x     PZw P<yR߯ݻgqFmڴI?4hUj̘1&UtYx
WӦMUzNL2E'NТEԸqc
қoKM6{L첨ahƍرN8kתScVqغK/鮻*{1Bx   J     0 hΝ;'IUViwu.\ oooISLc=-Zh׮]O4b}G__>#%%%jժѣ}l(OmZZ.\/B
		ѐ!Cԭ[7I=ܣ|PukРAի^|EuU%KJKKS͚5#Ff)))I}є)Sh"={V'Nt1~xZh||k>q|MݻW)))jР֭[K|AjΜ9Y{'u-^X[ڵk$ݮo1c'|2KױcdNMMՒ%KuV<yRuQ޽{~ӎ;tEqzgT^=:uJݻw׸qg]uE?]tIbccn#<={8qUZ5m޼Y7x>m߾]K.URR|||QF馛nr/[G";hM`){ձcԶm[jܸqJLLTxx{m*--M|>mݺU5k+UR=>nMӧO.\ݻwٳ
PV4~xѣYƬ|P?sϟ?_wyҴh"m۶M'NPJtkԨQjԨ_Vky-YD?Իwo=cYƆviҤI[<;vv%)_VΝ5v\?~ϟ={(==]vF~ٖg0>   o      x-ܢZji?uw(88XTjU=C._?W?P˖-SPPzꥺu*&&F˗/WzJ!\|[04vX}1bׯ۷矗:u$IZ|tHթS'z~'=SjӦO.Ţ۷kɒ%[n ٳ5tPyyy)<<\:hZt:t蠆
Z裏*00P#G>=<Իﾫs)  @+!!A=$i՚9s#G5e~
		Q\\$sι㣗^zszzz)9rDÇWhh͝;WǏׄ	.^Xwy]pAӦMĉzjy抍ݹsRSS)04~x%$$SƍhfT~}=2CĉkܸqJNNo1chݺuX,?8
YD,DjÆ
լY3eddFZvmʕ+5biĈjA4|pUREƍSj?wޑjUTTT3g.]?ZjiӦSj9rnF?~\{9[N6MRW^[Iz5h 
4H.\믿>G}Itĉ5k:_]jպ1qٳ<x܁e˖V\뮻*:           fiܸqkڵ
TzԴiSEDD+Ivs:xZnIRϞ=7())$%#m%$$h޽Rdd$E:yZjiʔ)ѣGTƍ+CiF%x۹sg
6,z&LxM6M{]-]TiiiZjj֬)Ij߾^{M;wVݵ`m߾ݽXyyy{$9rDzҨQW})$$D$n(ܺu89s}]=b
=Cjhh$=#>}~Wp
޽NYbbbt+44Tqqqo4a_ԪU+v-X@={Tʕ%I.]Ҍ3TvmI/ŢÇ_wk.]xQ~~~?f;wvء!CbKuU^]tM7K


-9իkjР$e˖B#2224n8Iҫʕ+ҥKJNNѣջw,Θ1C'OTݺu%|~'.ݻW{5x</ooo㉉)TиGܹsZl6iD
Rbbc     O)Kp    (<) PAըQC#GԬYc;ЯK_ֹs]>ǳIR$Gw\X+vwg^sw
YyxbY,ڵk/^4]r%˼v[Z&MÇwuEDDCdX'O_UڵլY3ĸ牉]wjJKKӡCm6YF5sFFF5grK=$)K(wq]cw߭ʕ+ß۳g$GƧڷo.sZjYB믿x5jH
<G5K.SNx.^.](==]6l(o6-_\
4ɓ'w^^Zcsܹڳgf͚믿^o޽{+99Y}6mڤJR@W~ZlKuQJJJyՌAS
ܡ[Iu}]նEG|   p-     N@|*U hB-Z$߿_6lؠA幼+XY~]r|7<ʟʕ+zfVV|_tIsզM5kI&򒑭ނվ}{{zԱcSRRTF;$G+**JΟ?'p1͚5Kqqq2C!!!PfWsȑ#]*Wgmp Jcq^Ie%I+WVN\[n$wdIR.]rԩS9r뭷|իWkW~SObjxcM5E+\ۯ_>c
<XVkZJ˖-!5l0 VZɓ'+,,,˴ݻwk޼y:t萼U^=UV-:?=0kZ0f*h,NNNvm6        x;Ｃ1cF KӦMU^<VJMMUZZZÇX3gj˖-8qڵk3ǼŲ0a5uTi&˴@>}:2$ݩS'+ڶmΞ=jժu֒QF)==]o4i"___<yRuyz뭷_MOOO<ujٲeygwM6ÊQ6m-ZkN:sЕ+W~YFK,Quwjx2Cؚ?`СC:x$V\\ڶm.@$}g={yݑ5**Jv*t{̙3կ_?+˴_~EƍSxx>r-͛7Zsqyڹs{r
ٳgsܿw^y|    xg     @Ydd \
ٳ={</r9s4B'11QM4}[:~5uG
ɓu_>˴pݻXl٢:u긟UTQ_j֭ڵӧ/Gj޼;tg$GGDDhҥr9o<={V}$5kLڹsg>3ڵk?ս{,ӕF?7|S.\s.T޽!ooo5o\&M$8qx;[lذA^^^0`6m֮]fe9\a;_gbbl6F^rE9y*<<\O?t?._C~(v穔c'ǠM꧟~roK.\gyF[lx?F    :    TM BhӦvZ%$$nN:oVV5K
0;޶lR1cΜ9oY;vP||^{Bo׶m駟oi2CT[vԽ{wm޼9CնmO֯_^/ry{ѣGn+**}͚5uu>SFx-ZH멧c={G~.^/R<:w>@׿4|p|ڽ{>C7ߏmύbQnݴ|r;<2o}f&$tP,W e"
DP*EtpQQ 4QQʊ. b)b!"͜33$$I&|?59w<pLLzӼys3FS
w^͘1Cqqq@bnZn9sW.]$IK,Qddns:>ːtjݺujӦ*Vc\nIׯÇUfMh۶mZd:vVZphܸqӧRSS5o<UZջ&Mhʕ:uڵk-X@?_y9uyI=ܣ//H[V-5jH6M׬YmK~SZpA={ԪU4x`
0@˗p8Խ{wU^=BY   X    F? p~7jڸq222TR%5o\:tPjB]&ʼxk^~eM>]oN<_s3b)S(##CjR=믿WVVV1bl׻mZ4w\M:U?N5jW_}U[[kUjtq~=ydM<Y#GTddׯ'_W_}޽{Kj׮kѢEG)""Bׄ	t뭷zp84}tM6M.ԟڵkkѣGAǎ5o<z뭊l2ef̘ŋرc^u|5yd͞=[GTƍ5}tթSG
||Η270ڞ8p@ڷo<:uҺu|r
<X<&L)S誫ҕW^{NIII;vjժ!Chu$$$ȑ#Zz/^/PmڴQBBƎ~A5ʳ#G(99YrO>2d&L3g*11Q+VT&M4{l=ꫯwG+yvM}N*á={
^̙)Sga_^{۳xۻ>   ,2    3MSNSYYYJOOWZZFqi5csD (~7<xX٤IEEE6Qzs̙3M;ջ]x"&eAqz:=f*+IʕSTT"""de)6PaӘ{~L O'ʹ}2{ 㥇ffu(2lщ;FIҷKk)::Yc  @_P     xh*  e
~\ G    B     7:f ,0^ҏ@h!po        q	 oɏa]͆L~
C%ҁ6   `!x     w  (Ctu0b]ͦ~
SAҁ    -     f+  cxï G    B     7: ,[C
 ?8ķ   #     PRp	 
zR9-W			۷~紼n?="X[C.~
)m   B      y3CǹwiJMM-@-u52D)|$J    '      :  0^ҏ@h!     X    Fw  F+PqU-m   B     7n  P?M>>ِo!`$P:p   ,o      eFٔ/!`?(P:p   @    x  ao~u@h!     X    Fw  xc~W6   `!x    7  (
26\8ķ   [       @B?l &	J	S         x  e;    IDAT
~\ G    B     7: ,0^ҏ@[?~QHķ   [     ܸ @p7GfCo늎=Oh)m
   8B]      !ǝ#  Z,
tk)Ca3m\2iy͓83;^9~,t?,0_A3[}uso#`mBm:6dy1=,yz~ru묠*_ۘu|=9ߗ63n
w<s[9:Kݹ9Kݮz[    ?        Fl\=S%!t&pʴldYΐ_Ns{}K
wu?{]x
?o/{L.538|g{Nk=8~fr܎$k ]1r9SٛUttOWu.[ܞtp%IL'v m٧{o^:ݧ]mr;~go1ݳȯ]|    !x     l6v]YǔLSr].O=OfsZ`O=l{E%p¬ma3{i;kmy{gl%^%')|9]~e^o{$6l}7p_y{ⵞ2æL
I{>N.OӐiH*19Bu_^mUKr0]ׇ^/%Ô}ְ>{~{^xwc7eSv;
s]w};6dJ!IƲی/㝳g{߇XY53n@;v6xg>>FeiP($   -     ^tx @x^zȥLefftr4C\c+r˴b
5mTç.	u9VvΟoppammSӥ,eeeM=	f=+&&&|aq!GDv;[
W   `!x       [SFDD0v\.oHg[_JoT|W<׷'D	zmO<m't:G(ʕ8O׬o;A    G      v|a#$W4fSrB\M|uq7p8?tKr~"##?+W<^v3m    [     ܸ @x1CizCq6MӯJ
oC\MxkN6x"""?GEE~ZvaJ       mr  o#x[<l6$P4|u.cEpxB¥p>
       ;G  5^*=?|t(:PL\оdpi?v    [     ̀W  vʅᮢ1.^)E'^q8    <o    p>$  e@8@e/
   $ɖ,     
Q     ;B   -               P o    [          gA     7L     +        q	      w<   X    #          @     3   ɓW      [     z  ÇKj֬J  @02   `!x    7   KB\	  W   ,o      ͖ߓ@9t$z     @x!x    / (V]t_~% cǎ)++K=          ;XիWCV;|gz  <2   `!x    7 x/_^իWD7GL  W   ,o     Lݺu%_|!IZ}            bS^=I\ h.]*I֭      >    F& _$IZzu{Ѯ]$I]t	q5   Xx^       H P>]|ŒS h"IRrԶmW     [       !DI҆
wW|-]TԩS'EFF           A VTT$W^:uT+PX{Ѯ]$I]t	q5      @    ; $V}JnݪΝ;++++E(gyFdձcW     [     ܸ sϩYf>Hzi2K  @02   `!x     w  *U>H-[$-]T[ַ~ T~$IիWׄ	B\      P4    ` BRJڰa7|e/QbbRRRB\y嗵{nIҔ)S      a-     n=@UPA_|&Nr)))I/ǏD ='|RԦM+    -     n@cȑڷo+0t	=cY~m۶-%Ν;̙3М9sB]  ("<   X      (."͝;W۶m
7 I:s͛kV;wB\)P6eee)!!>|6l      E     yOjP$iׯj֬G}TB\)Pv={?$m۶׿      G     7LqJJJÇ5m45iD襗^RÆ
ծ];XBN3-11Q$nի  @Qye   B     7n @D}7OԳgOEDD4MmذA]vUݺu5n8=z4agՌ3$Y=R]V!
  5W   ,o     Z7pz-Ϛ0aԩ#I:t萞z)ꮻƍC\){95Jt5?TC\      P|    ` J.HFҾ}j*vm2CYYYZln]yzWtĉP:i*11QO<$+Ԇ
TRW      /     | fSΝvZٳG#FPj$I?K.р7߄ZtHKKӝwީ$IR||6mڤU2  Px^       H ^.RM4Io-[JN>Yf/Zn+===%SJJzZJn (x^   8B]        ([{Ν;5m4-ZHO_|/B>링K/
u@w^o^{$
4HӦM ^zIn;y;s_Z    4M:    it*++KJKK9.Fv}?JK 'Nh޼yJJJ?oڷoDq0M_~ڷoI&i.@INNV\\RSSioY}QU /k$I[_Rvl6  @    ! (;*VCׇ~ݻp4M[N;wV5qD`ڵ땒(X-ոqi(%%%QE C^   -     n@[nҥK_U$=zbccu=o+^RR:v쨴4UTI7nTBBB#aÆEXye   B      $ըQCcǎՁ;m۶2Czu
7誫kSbb\.֭-[u֡.@JJJnwX=        ` 4ݮ]>ݻ#J*]vV͚55h }w!8/H6mm۶ѫ$b;+b    #x    AϷ  W\q^z%>|XgV%I'OԌ3믿^-RFFFݟoYK.$uA}.W,?~Wuҥ+W   ,o    p  /ׯKmݺU}Ur$I6mҽޫX5J!(e˖ڼy$_~zT|W^&M봘\2   `!x       E;w>ɓ'+$zgU^=uIk׮iXJ;wEڽ{ĉ5{ll6 }7ߜcQ         ( 9\}Q޽[ԥKv\.{ueWJJJ֮]ŋkȑ. (pÆ
5lذV    @No    p3D @!viŊ:x|IըQCo>=Yk!eݜ9sԱcG>}Z111t]w, dmyp`@h2   `!x    7  f͚7n<ŋ릛n$kjӦ͜9SN
m(sƌx@.Kk͛u7, 3zhƪO>C] <   X4    (3LӔTVVӕs]AձUB]"  ޽[SNu	+w<x6l
233u7ߔ$iÆ
ޞ(>@\sWRP|MXE'%IJ/hEDDnfq   Pf    )o4wC< q)JJJΝ;tM4hNEDDB6G̙3SO9Ojj:uO>DԶm[-_\111U&8mW O3E   F    P-x{e[ @1ؼyOK*==;F0`5kB3fРA2ϺJ^Y&04 7h	}-:k;F[        () (.[V֭5e͚5K3fо}tQ=38q:uDmۖrrJIRdd222}j۶=*IzꩧOw(|C.[ 	l6
~z)8   o    ezmTǮ ijݺu>}֬Y#vWhׯ*W\mٳG_~y0E	p	]xmŊJ6lؠ]*55Uv]oP27pt:,+p'0d5̞6緾mQO.=e<wʥVumza[b{N?zPȣNfX+~=
5[tQ   [     <x4 "aCСٳg_?
>\cƌQ=-Z6Zn?XqqqE(nk֬}էO9Nhj۶m+EYۭ_gi.+dj2doЩ)Ô$S6k
ް_Y_ӳMɔl77luzlo
c,8L<g}m}ސ9g?|΁g9ϙ{[}w_;^y-_?M]"՗z@   %     q_ Pjĉz駵l2%%%iӦM:s͛yyJLLT^]ѣnݪ^\2Ǹ]w$FڰaAk'x	)P(amG_(se>Oo|!z\^=#G-crpjP!3ސLy
2dt??޳{q]７->0M.I$))&&ϗ
.Sٽ
   e[      PDFFW^ի;ZpN<۷Ј#ԧO%&&+s]M6$}zG5cƌ
]6ڶmj׮]U9o]jRϡ-+4 aj]$eov7t#t   Xl.      kܸtaM6MM4$zհaCkN˗/̱_^ӊ+vG}'N9=--MC-Ɗܙ)%%ƅ& Pvmk܁·    [     ̀W  J%&&oѧ~={*22RijÆ
֭֭qѣ}XO~-Ar|Ybybȝory7 bm*޶-   b@     7  [o)99Y&LP:u$ISO=Xu]Zxqe?=zizw4)S w7oϓq&O[whpd   [     ܸ (."5Jʕ+վ}{IRVV-[\ۺuƍW"l٢#Gx~^ -O[aOE         0ui޽z
]>3:Ò%K
<oʕզM1+G -    ?G      8߯KWkҤIgr{w}ʕ+vP㢢Ըqc5iDM4UW]&MVZy\.Wqtau-`z%~         <![߯J.W&wڵ@/ׯ-[Vr:ܹ7\
fw=l0=2+rk/FV    [     ܈   Br
]fM]j^|E
2䜶U~}}79;N9TT<<[?O0I[ AFq   [     s 1ps:o8YJ5lP?U?Pl67pkel6w<J	o VI       x  |{M9:!0Mm2%kxlrfW0MfX$
CLfd0]9=kY4Ϟ/r0_f}9>F6Rn:g=;ɭoʹ/g;޷Q.vrL/15LSG}9]s]SyI_ n) 
z    P|    F^ JЭTffU
:ew|.kaحpr24]2MUd:p':ޞgw|v3owNz:MY޳>w>ӽ]O=6INo=7%N3x=PӴtY\֕:} 15\׎`e߹L7x{]޺LෞLeee0!^7[r Êܚ=          [ө,IV/fW8d?Cv0='    IDAT?9gYzc,-|L/wM0L>sx8#|yü7=}u3d\dd٬.OOo9_ hx          b;xrU7E@ TeTG)B 0(   gu     d   !	z[wϐ|>kf	ߖ2x Ȭ-m
   G     7 P		L3gI)A 68q   [     ܸ S!@ miE ŉ
   X    # @	[/L> IُHm     [     r8  (|>$K-o@#oiU    ?     m D6/-Zɓ'1cƨ[nA>|XݻwW||Z]{ܹ233C]Z/2d;V,+s8qDuرXURY=ކ_Rq   #     PRp	 P'J-owW^Zj~￯=zj=
4Pttt++jҤI*WejժPV`[n͛m{%;['7   `!x       %)IُHE/´[4zj|:r䈖-[Vm޽\P*T2JvÝ-aP    ŏ-       COXR+L{/u!]wu:s挆
;vYfyuwgիc9tM1b7:f}zw$I:tP^t!_^jӦF~[+Wӧ1cƨjժ4͚5K~9HiȐ!jܸ_3ghjJ?TzuIґ#G4cmٲEbbbԪU+
>\UTd{=[:x*T[nEv-[K*99YUVUǎտ9-^X&Mҧ~{֭J?^a͝;WWTT5k!CnݺZ`L"It]wי3g4gmذAGU͚5յkWK:3f222ԬY3-X@)))jРFjƌ:rׯ#G*...9\~F7iD͓$\R˖-rTNWvw?C/>3\.uU.o=
z    P|    F 4	 xOZaUt%yr:V-[?~
ڽ{z)EGG'sIII֭ϟݻwkȑڹs5kiӦѣ=zNcJz)mٲEV:utaz'b
v}JLLԵ^+==]*##CP5l0U\Y}fΜ)ͦqILgϞzᇵo>o4gEDD_^{5CÆ
Ӿ}+(55U=Xiȑի
Ǐkԩ?+VsҴi4k,*++K
Ҿ}4` իWO_|^z%>|oۛ6mRjj^|Eeff~aUVMGVttƏQFiժU9kӦ|MqWoyɒ%zէO
<XN[o'|Rqqq~5;vLCUJoj׮]ސtA{"fK6z   ,o    p   <=Qjaڸq+0p8t뭷RJJZN:gϞڵkkƍOS.Iu=ӊe]oY_$)==]ǏСCյkWzN}Y=zTjkڵkkʔ)@fժU5n8OTժU5zh5lPԲeKӎ;$IGբEԫW/=裒WyYF			9)--MSBB7ڪU+:uJ|򉲲
tkx{׽i&>}Z*USk׮jժiݺuڵk&OoQtupxıLM8ۻo`M4IM6$s=z`%)&&{$iZlz:Hۧ;SCwe{ꫯ>H{ԩSժU+IR֭mA{!Z8   -     9 PL> IُHT6|[NӧOKڵkhժUoܸpjt̙nQF~+VTll.JkI?d8p@~$+Lt:_5>>^wx?~I{Qff$iΝr\jTR%m߾=~tr-~x*|=]vjݺ6m:eo߮ryC;vco/n%RJ
xy'O{LZqIVJNN=Rtt7t+IѺyfI;_    ?       P> Iٱ*Uj*Iwߝc;Ｃ>}fyEFFcL|rr:2[lє)S?*""B]v*W읞*˕G@o͛]*TPFp858qB TZ5o8%)'..NӧOעEd͟?_*Tw߭Ak'r|n7<'55UÆ
SժU5~xkСC4i>sX]y啒w}5{wÑo       o 4D6<?~AP˖-m۶M>s]wuZ5l05kL-ҥ^*á__|$\ͦeM'|8m۶M/{U$iܸqڴi$]I:v.buo˵ƘIʱcǎiݺkY7ɓ'LܹSK.՜9sԠAm6Ƕ+VcǎoIRЃYYYz't1o0riȐ!ҴitUW)::ZGU\9ǱR{8"fXK:z   ,g    l   O6<Up8t=iӦ~zh-[_
4auVIV3""BqqqO_F{jǎ<x7t;vxiڴl6֭[WæM͛Zcƍ7_b.ө.@#O?1cv*өhBF$9rDz̙͛3OƯY;=^x}XiǎձcGhBђϕ-Z(==]w٬,}gႜpDq   =    
$ @IcʤGv@R#RDK-o_FF֭[6mx{}u覛nubQFl7ovLԚ5kKΜ9#Iz衇4d
6L]vɓ'M*>>^Gʕ+5uTkN)))Z`~go@Fh"\.nZ̙3ըQ#z뭹XB[fRժU+ٳGsѽޫ
*UVr87nT͛7OUVu֚3gquEdEFFoݻ9st-m۶ZhƎ~ڲez-u]Kv.y-[L			lڼy_O-[_5k֨qƪRmۦYfnAM6O?AFZdRRR=[/No   B     p  !(@Rv̇O}yөS'[N˗/WBBBV^=M0A3gTbb*V&MhzW_)..NZҫiӦiPnV=r8JHHБ#Gzj-^X^xڴi;V?5jÇK.LV;j̳΁rZt,Y5j衇}'IV{9%%%iرU{qWkɚ={F-өƍkS$kU6m|r;vL>}M?Tڵ5|p#b˖-ޑWZcg}ɓ'k9r"##U~}M8Q+[6MSL+_]={z{.y7VEq6   }    0gN4"Ԩ]ϭ ei2MSYYYTZZ~9AQijuQ.㷌PƯձ#*W"##!͖Z.K.;3g4tKK?Tvm%_~X<LIպȐ"]hEFFpf&cc$)}K!  @_      (֭S||NuMO?wC8qb?zJ-oÒt~;vN.%    #     PR1 1eYdժU˵sNٳG_~yK/,<)U깿|AEFFK.jԨQKΉ!·ō
   X    F  P2ڶm^xM8Q˖-O<Qu=3E:?`1^QmӤI}.(4+ߢ8Ђ          PBfI}]EGGe˖۵|r
:T˗~/]vrzsC5j(IRZZf̘>@ǏWlln-Ϝ99shÆ
:zj֬]W^2A1c̙3ꫵtRo[
n[ˎ;4gڵKiii^nv=Cڿw'|Rf#G;uzCiT6m4j(ZrN>x3FUV.j*-ZHPʕuk$\R/&Lӧ맟~R*UԵkW=ްaΝ+**J͚5Ӑ!CTn]V\e˖ir\S)SoQ
Խ{w߿_ǏԩS\1cf͚iJIIQ
4zh<xP3fБ#GT~}9Rqqq]@Ԣ[ AfEnM     -     Pb  0ar7+WN:uӧvZ~g_NwQ߳A QZ!P* "(XP,xU-T0
TT
(7AEhR(?O
ҶʥPA$;?fgW
l
ww;35h ͞=[|M6MS#F+;CӧOW۶m5~x!

4x`-_\}ԩSӧkڴim7nܨײe˔1c;wjJHHɓ3ꫯzuM6Mr
v|rrrŋk	Zv]viܹz'm۶E4i$]z饚>}ﯗ_~	N8zJԊ+Իwo͟?>Lcǎ̙3/Ý@5yd]}՚6m&MڵkG޽{%IנAtM0AZr>D>H~}Y:x~-X@ƍӂdfrC*fQ@Yo   Q     +v *Ɣ͛7ի$iӦjٲVX>}8^z%\.͙3Gw$Yf]֭[eM8Q=z$o^'|믿>{ｧzgtuIvd~JKK$jڴi[$iZn6lؠ޽{/P֭SO)>>^
6h۶m.]WUcոqc9Rŋkݚ0aԴiSuI~$ȑ#Z`:w	&H222ԠA=Z۷oW\!
@?NA^Ӈ~.]O?a8pj׮-I:GĉUkr-:tMnە?2Csc֭շo_g;??_SLQz$I]vK/Sm۶;C&LСCZ8GEq*@tXo	V$         1dD
jժUO-Zĉg.$m߾]ڵsԢE5nܸuo۶MԹs3f~֭QSK,Ѷmۜ^n%~<IR޽ջwohڻwvܩ<K/-9kѢE:u(--MIIIδZjѣ*Nҍ7ިMFFn6mX#%%E'O$wܡnAj۶.rC=={w^gO>Qc&MԲeKqYݠA't+) mǎbEq*@tX!P;~9       +G *4$Շ~|]{!WXo9δU5%9rRRR݆h6/z%INӵzj)55Umڴ??ըQ#dZbbbsss%Icƌ	;+u]v_[jyiҥZ|/^ڵko߾<x7|Sjƍ2MSiiiN^?ԩSew͚5ö	?pUr*޲D5'=   
G     ~ PEhYf5mڴ걒dzUn]խ[W}:rssu]rrN<_~#G8U\mu	JRHKOk͚5;vg^zJ<.䒐Ug#xx;v_լY3uYCUAAΝ6m())Io.;ƇVZʥxUr*޲DU    *;     @UQN  Θ)3UVe˖رڶm׷o_7ސ$]uUڶm:,k.ڵ_quLg4{W^yN<?0`[ȍԶmԦM|Nv߾}o^98_~nklSO*u͟?_z
J?$igSW]ut%Ux<ڲeK@/(~)x ʬH7   `-     >\@ T5A۷O_~x=~W^w߭{Wk֬5p@y^(!!m\}j׮x	>|X]t֮]O>D3fiߥK-]T>.H7o֟gOӈ_V_%\Jϗi:yd9S/*??_:tЏ?^xA'NP˖-#^WFF.\zH{$-_\			딚
護R˖-U^=}'Z`$9{o!C{UAA^xy^\A9TeV[38   `!x       UT4+nݺUao;rGZp6mڤzg5i$լYSwy6mT6Ќ34o<ԱctEgUVVVH{ۭyiܹZd~G5jH#GT~F%45sL>}Z
6T~w7TAAAw>z[    IDATZ|^y%''hȐ!JIIx=_~y7n
ղeK͛7O7dU~g4vX%$$袋.Ҕ)S/h{tkzg裏N:;f͚Qw#\x ʬȭI   @3̊-      4UXX:uJyyyЫEūEZC" cLTAA󕗗~VeHdXDڲe


L;}w>}hȐ!ػvUгpըQC			rjzzg'OjX?WnmW*h޽[㏫k׮/:u֯_T]Gu8Ū
*~%FIIIJHHaˍom֑$x.n$+..  9     p} P՘2yYgyF
e]Ǐ_V~~zU+31ǩxWF
+55aUo+
   X    C  P2xY۷N<իWkJJJR۶mpB5lذWF-b[A'55Us̩n X!P;~9       +G *4	ݕ(5X~͝;W[lё#GԼys
8P:tpt]=zз~
6v+33S#GTݺuv[l?/BIIIJOOÕ{[n?]Fm{'xBom&ۭ;jԨQ]$)//O,￯+!!AZСCղe
MD5'=   
     Pb @eDI@&bS}K[lM2E6l{｀/VzojѢE!C@2d4yd=Z۷oװazjۓ'OVl2=#z>cZb.͚5K>٣1cƨFx         m T5L%$)U
P6&-ZHyyyZlRSS%I]w3fK.N&Mh2CzGuwkݺuҥ{95jH3gT\\$~8q+%&&of~풤FiڵZ~ƌSN)77WÆ
ӭ,SXX'xBPÆ
g Q|TH7   `-     >D   U!7(@RQ̇O̢mLںu<|j=zЁo>gzfff@-ZVZںu
駟cǎNV<^ug?;ml2`ٔ<yR{Nzrss]W%Ig:<dVsJEb   o      2MR@ ^11ȑ#JII	nO;v3nݺ!풓uQ=zT^W׏kժ%IJHHhcF{͛5sL_R||6m-V[0(   
G[     ld   Ua=W,*Ƥ:u~!Iav^WRzTV-\.>|8iZn<xV.ɞ={~Zt׿jɒ%޽{Dˣ*   @#x    ; @c	T
)1˩xXҮ];mٲ	JVXv͚5ęn:8?(==]jժ֯_/O5j(?9m?ӧ5` 5kLn$Ūxx   wew     H Ɛ !ITE,0`}
4HUV-\R?O=p
~iUW]:H~jСzt뭷رcQ۶mx3vIZh!˥?iz뭷oJN<ybU%~[8        p PE&A Teƒ
jѢE3g~iE={222Kn[ǏW5ԫW/
2D/tٳgرcUN]{*g4iD?y
2DuQ֭/jРAھ}ZjuvJaEnMI       _. TQvX	Dr*޲cM&M4mڴR롇Ҙ1cmҴe˖2m;24b1y|
7niyf~~ԯ_bǪx    U       jL$J I|S-(*ޢ"1   -     >\@ T5ޠ IE	t1 ̪x9"1   ]        gn@&bo5kTvp*ޚA   T8*    `#  b	@*fQ@Yo        1eH*QT*ޢ"1   -     >\@ T_֐ Tzlq*@tXo9T$F       +G *0'Hhߚ&[ ZAq*r^V[)    *;     @㗋 Uar\OѠi!3MӔ˞{lwɔd?Y6b:Lzy22ٞ<~&+m|B[N^|4Ow70ǎیJ})<e3\5Te-    T<       T&U,4eTttQ eHz2hQ|TtC2^}AH'k#wk/CڟA=Yr!-~zϯw)reO`P9}R(°/ޠ}b[bcAi1}ycm-(*H7   `!x      @e0C/r5؝*[P(Z3]T2 !S24=|:wߴV[W2{lP\z|˲0i-`ap=/lo
܎ӷ0ۙ7oN?Pj?(EoC|LH˰î3>)I[ߞ˰Ga(R\Kq-+..	"P@}r_38   `!x       ̮iWR~

NCE|F:4k+lV9!x-B[ QfEnM>   po      T";tv4M2.*쌏W5*7{].ڈv!TeV[    xo    ! LvNm\\Jf;n7JbЃ}C6F8o :o+
   X    C  PYÐir\zrvmųCqqqJHHޜ{õ%pc VԎߢ"p   ,o     
m	V8Wv7Ymv D5'=   
G     3 J"LrٕVQk	 -@tXo         hXuWV%x*2-ۊx   /!     >D    3 
rNH6   `!x        rex ZE0     ]          D~8jjSV״>̐j,]*`2%-Runʶ?xY
hE?pg6~m7ӴSd\}tn	   (oo       poarɐW巅k4}?ٙ^KLk?0|W.CE1MdC=.o $i
ozڛ^!o|˄]=`F22$n}o8f샢~c><|~UF>cp|s헐c<c,?=Ҏ?׸Lo1	/Ya\|C|

z   "Wew        @tn].uIki:_N6Ljaʴu_{_ Ya|we2ðo'볗/Dќ~OEN]
C2s/mo}clV~}w|)y3_1.1h7=gξWc,~<+zǬ_BYL1k?grǟ;?4{gk+F   P        Quݚ6P


TPP +4tav|]=2(
߰|DwyGcǎ$}ᇪ]v7g8eel5R8M(p+F6K\\nPv@    [     ̠[    gũv%*,Sa;-MItڛ'I]	\÷    P^    u9    :+	ݢD			5kf͚TU9xK6B   -     >\   Ξa2M	p%xpJJJޠCvR|1   -         ?fm].nQ*eBBB@fm    P^    `?   571[Į,YJ
pA[B    [     |6   D(CIRqLI6   @     u   C8\qT   _    +G          "@     3           x    `
     W   ,o         @x|_                  "@     %o         -     >     W   ,o         @x|_       +G          "@     3           x    A[     2   `!x             -                    (y         o    1D     2   `!x             -     \9              A          [     |*        [     |     W   ,o                  F[          % x    o&        [     |     W   ,o                          0    cP      ,   X    $     2   `!x               D-     6J         ([     |~3      ,   X    $     2   `!x     W          D]     ҙA  o>-X 켣GJ֭['r TG+V??O>CS\    @q    cP sRF~z]6֭ӺuB/Z{ W&Mt6O>dȴ49<    @\     

 pQ\\\ԩ_>j7M5kˡG JC          7o'&&*''{ ɓq^zw#     JG     %o 8M4Iiii1b7o^=-55USNmbbfϞ]=    to    1D  iɚ5kV4nܸ
 TWNJm7f̘|}e   B     .  ޽{k׮%5k+G P(..͛7رc+G    -     \9  ~fΜİz޽{Wp zk޼Sy    F     3  Ӛ7o1cƄLOLLٳ+G PM4Iiii!N:UB     -     >o رcռyicƌ	
 d͚5+dԩS+G }e   B     .   [bbf̘<n޼Ǝ[=wڵxĉ|B2   `!x       @ݺuS^$I999JLL@7sL%&&hС     B+     T 8,f͚Tuؑ2ànʎa׬Y3=Cٳ\.   XC      b )8DX5lP=^oewZW<&t2qG}T8VS%y?LI!   -     . bP%|8CT=   B      b8z2M3䶤J@EQ!ܺ\ ms\ {}-   -     f-  1
Wrہ4ݦ=37n37ڗqyu ~)j翼W3,b݆,ڿ-Gkyo|o#ܶJFD˗1`7C.Ðe&ʔV\\\2j|>[XtZm)M
8̹&\pצ8(]	Ӟ?AXlsw1Yv
soϳvBk/qXx<"y],0dE_ph,w&#t    &    k{ X\Po<q(!SiL4ɐ7`az|k-'o7eȴk2_7e(xuG$C)oRh
3~/t2?h8-t0BƬg3ch1$_scg_~	CErâ 0q\ҷ#oa=yzATJK|>
6	E|7>~/s|O?|CY_oP#Ș	ڕ	V=vl   8׹Jo     Xz@׮n!_u9Wΐ0|v{Y)/9e|5W|C=}_Kѭy
?C~Co?yކ2Nc?Vcj;c0
_4k0|ߘwl(_PPBCEǈ}I*:)sWy^2^[cَ:-:!YEDDlo?.z~GAS8?~>_o#'aD?Bt~)f㜃C??c!÷na}?{>aG_?B|Jk{Af   8'P       bPp%BI.L^+> aFЦR0f.Svk)}_$|*y/y;=6fM*~h6}jz2Si}rO#}+
kVHȎo#`Va!%oJ%lo˰=F6PeµO1݋}l/{YuDүV澃*{?    @, x    : d_[u3T]FNC;x_L"h+)N<T%Ss    UW      XcLӔu~,RD"l·C0O.&X   ,o      9[C죕FK    IDAT"aoMӪ1Tv4^U_{    ,o      W$wX/D"\ΔdpՃi   [    /s bT@8TYZ$EǇ/wZ!L        Z  !w*Eec9܁jsU{
       H F
1]8ZaO          PCCgq68~j´o        Ƶ> @,jb!+_:!L        Z  !w*]83֑c0P    [     | iC܅3eH2M :0sS   -     \9 TC3e
ӾC   B     3 XD8>v̘r	az    -     >  TY|@`=   X    $ @L#.
j1=   X      @u@
1	ӾC   B       q!pfL9~0=   XC     k} Xfܩ49Ə]83֑c0P    [     | iC<y<rrrCￏĉǫO>QNwﮧz6+WѡC"Zӧ5m4a<xP1bDDgPt_~<O_zznF5J_uԶWV{o2ݻwה)S"n_XXCꫯUW]+++K_~t9J92:tHGoFewgP?氧    ;     @ :($c^^}]g?ʕ+5p@݁?Of͔T!:S
4Pzz"j!-[Lmڴ	;ҥ4qĈ*~V1ΔY^z}ӧO^}U׫ZjE}Qӕ2G_|qMԈ#TV-+??_\pj׮}&]kÆ
+TfͨՀiu    -     f-  ƽ{:yƌ7ZntR.ۊ=SiێTFF222۫O>SNDYILK/U׮]C_|Ś<y>裰[jj̙Se&MTn[M6-2ea]s5
Į   @yrUv     *"( @e܉+Wm۶j۶Zh+V饗^ԭ[7=SO
h;eu=dw}ԡC~b3~xGoxǣ;l۶MرճgO͛7O]vhժU曕7|>h֬Y/W\)ǣCIvܩ_;vTVV~_;?s?$7N}uֳc
<X?n5JvrXB_^{5uQ]tѮ]HϘ1C7t233ÎN:cǎ!ۊ>vXGN$~$L;ufϞ={*==]vVZ\AA{9uh޽/x<:qD}%I{o-ɪNϫwJOOW=O{2e~^^̙[nEk5x`}ڿƏnݺC0`6nX;vL;vPffυhܹ233F~3w}WÆ
SVV:v	&رczwtC뮻sRNK/'TNwխ[7]{zueWZ~)==]ݺuӬYtig?{L]vUFFn6-]4`.effs5jv̏t?,uM,㕝3=Tm)   B[     | iC۳gvءG}Tt7kԩڵk4i"I͝;W,PZZ~ᇈֿ|r=Ӻ{ǏyjJiii%.ߡCO
ohٲeׯ$+5x`effj2C|.\
W^βӦMӀvծ]bou9r=5J+Wi{	eggy2e\.,Y#FW^QӦM5o<
2D#FPN$I~F=c:~^|E
0@/5j$I:~,Xlo?OUfh񊏏_񶢁8OǏwB<ܹsO;OW_}#Gj֭֭[kƍ4iN<o]4uTZJڴiwyG=YsZx/X_}f̘</c=͛7+;;[7ַ~^xAcƌk8}{TNeggvzW5l0=%V@߼y4h&Mz.lԨ~
0@4bիWO>jݺɓ'k~;wSRRƌ#
>֭Kcǎ=Q>}xbܹScǎՎ;Ԯ];͝;Wиq4gg,ZHsUϞ=5b޽[s՞={4m4I#<={hԨQW֯_g}Vwn&}g;vN=՜9s4|pk2#~
4Hiii0a4|>|yð;B`O          P7H^uըQC7p$ߌ3b
5Jty)55UԨQ#Du-hСδMnK
&''y[jŊ{ʺ_|ZnzJLmذA۶mvEկJwjjrrr:uJӧO7|
ݵk~$hB.ӧ[?|g3gy9sS3==]{?'Jk<X={׭[j˖-8qz!Ij߾8O>D_}ۊgLy,ٳ5{i.K]vFTM6iN?==]^W999իN8W_}U/KIR۶muA]}v]tE/~!I+UF*^YYYհat뭷:'Ё԰aC-ZHyyyZlsԿ͘1
%s$-YDҟ'5kL{Gsu|NQFZv֯_oy]ve<y$)++K>}zYѸqc9Rŋkݚ0aԴiSuɩ{-X@;wք	$IjРF۷+жmtm9G5ky'IOeڵkK+>#8qBn;?Qah޼yκ[nPe=cFg4~!L    -     6 br'*
zjuQi:L^ZJJJ:m<C޳gݫm۶I˴{jJOO޽{w*((ݻw^ܹSyyy!۸K#֕W^n%9Uf=/VJJƍnACiϞ=>|eddh֭Ν;L1cml23`Sff^>3-^X=z?,r,IUPPLl2eڀmtW]uOcǎJOOM7Wk_{9IRnnݫݻwk[nqBdz衩Sj߾}ab7:_#9~jڴ.1kh":uʙֲeˀɓٵkЦk׮gmѢE:u(---}VZg}SN/rڴi
o^ӟo>uAv5;C7p222Զm[]~NH'|;[IjҤI8FroLX   D     bU ̐;QqF:tHk֬њ5kBb7|Sjƍ2MSiiiN,?)Q=_&O,̳Ѯ^ZyyyJMMU6mvCqG5k<zC&%%__^+WT\\:uq)999dQ$-߹QF!nlg:r.ȩFiĉr\?~.77Wʤ;'Xn݀y[JrwVZz5o<͙3G?O4|}*/I7o̙3KjڴiHߏ9RARwwܩcǎ+ٹ077WWzzzuWSOHHgsNkhS~3>UzMLL,}x}wɓ'kzwn:IV%qK.QV4o<-]T˗/ŋUvmWa~/%%	4GrG6S   [     \ ĴrJAZJ
4?2oZbE[;TXX0?z5tPhܹjӦt@cƌ=ZfƎk	#{y$gǏ/4[/^z9U	y	Td<yRyyy/RGQƍ˴EpgPg?Rǎ%Y%ۭm^xv!ɪ$_4lpX]رcڴi.\+Hk~jjxkNK._,ۭ7|S6mrשS'СCBCƶ>H' Zڹ099Y)))~vbfȑ#rIrދy]r%!|͚5u}Ӂ~z=7n/_.Ix<x<׎;/kj֬5k~ÇVZ";ƣ0+S   %_K     kr !Cta}Gնmې{?MH KՀqW,TZQBP@pB%ܤ~E|)෨HEVXAPVU~r	ݝ-&$^ǃϜ9sft>s{u!<xPt<I<'NeeeYIi+رcիڵkg%y~:ٳgk޽9sbccg[J:~N8Q&	X;wTΝuQ8%&&iӦJOO_xbbbԸqcm۶'ӧOkO[o$k$E9shѢEZV(BI˦7NQQQ5k.]$ɕgϪe˖ֿ'Nhɒ%pڴi;>KKK#X>41cĈ2e$WRg׮]裏*777HETVV891{<}')m۶ڻwOi_
Ν;uw|./t:oU^=:ޱc֮]kXZj)..N۷oJjݺ[mY͛Ç̙3ѣH:
0@ݺuΟ)))۷rssvi	޽{}F1OOOסCϡRcz^x   @xa[     LW  沽Q݃իVXM6iʔ)$\Rw}NnXBUTQ5qFY#=Ĩ~ںuZlڵkkϞ=JMM$edd믿nk$YǫUVJKKӛooQVJJLպukEEEӐ!CTV-}:|,IVmٲEigϞ5jƍ1cƨo߾Њ+d5tАo߾ڶm^zIOVfkϞ=?$ZY`[[6СCxbXBO>Nvm4i}QoQJJZj
J}Q+߮]vi֭>돏дi4x`;wNWֵ^[`L:tТET^=9N={V˗/W&M|Q~Fdٴzjv[ߖ2Diii>|{1U^]7o_|3gٳ:x^z%kZ(}A;WBB֭;wjzǃZQFizgt}ѣZzu߿\kVBBVXluQ?/_/Z罸8-ZHjڴ>-[X:hʕzԧOI҆
N:)///8x`[9r-_xi*dz    (-$    v~U alo4i-Z֭[k۶m;vnvuQQNS3fٳ5gEGGSΝ?Ig̙9s())Ij֬f̘˗k߾}4hPq޽ۊ7GgiZ`԰aC=+)::ZK,ђ%K4k,]pAM4ѤItJr~z.]hJMMՄ	%ө9s}Q󕜜W_}UϟWf4w\k4*+xJumzZQ?|MkoƍkJIIџg㏊Q~4|p{Æ
Stt֭[7[oՈ#l-SNZtL
jԨQڶm[4H6Mo֭[(kAG>Ν+IjѢϱ/jٲe9rj֬oY+Võo>+rժUZx?*77W-ZТEԡC~jҤ~_XBcbb͛L5jHǏW\	ҥKsϩA6mƎ[\#Fnݺڰa^uEGGtjȑS$^PrrV^ӧO+&&FqI9shŊ8qrssղeK%''qƒBۏuUJJΝ)Sf͚z}vUVMkPxi0Cƃ3   aoh    PA\(33S.]R<z/B-uhU "yϲt%-z#G/T(1"PKJӹ!Cҥ/W:רJ*naeX4M~ҥKt钺&t;[E<]a۶m4qD/Qlll?f]pAo޽Q||5-++K={T~4r2tӇw)^M~HUVUddu>@őu~w$)yeCEEE)""Bv]6}  F       ba_FF&O-ZA9o4zhO>￯c*;;[{.L1    Ko     p^  o
˔IKE	\ɓsN5iDG.p*QFi߾}E.cEFFADWր-[hʕR6mrJ5lذ"   @!     7~ ̀7@eJr̻wݻKٳg.r+^YYYE.Q\ya(!!A			$+])   D-     n Y#$Iɕ;JGLLLypU3sF)   V     Ps CC%Jڦy"   @x!      pd*,.P2/-LH   nH    ^  o
.\*6   B-     n@ 5F0MZPvS          P0ϊr~Jp    x      QFHBɘP`    IDAT2!   @!     7{} pf*,.P2cpT
fwS        q	 CC%eH2MZPvS        p P0J?KT煋    [     LW  !pم1iA@eB2=   pC-     n  xTX\vd\- P    o    p  0u.i҂`Þ   \H      ʀ<4~VT煋    [     < g0I2+tLH   nH     @1FB*>.p] :<p	   8;      *
n  as}͓;=tӓmg9緜i7I4Lw,g73]|]!:y*`	^oVo-~(r۽Xx1{{>٦No<&?q(C/k7ӯ)h9{-WgTXз>v#·nGz{뷋s!P#O+r)ٰ>L
   x     w  aʓbKY~tVL?Ӕ-U25_2<W0]_!S653]0߻Z.p~`ؔJ,75=p.BꢨU~uUPj$Z۶'K~:ɀWI;WriUz}?KͿ('z=}r
߽7_r>S˭'rYXnehОYt=_!s    E     LW  fs{w'phJaȔ7t7}˔!|z/׫5Ilo-'
o]|W|7N9'(d~`曁滷o]zL:W+OhA~SudՕ_[3­;n[mjwdC}LyuoH2M*8Xu{lz?{7p{<ǍzZno{.̯/|_O[GrOOf>XtJ{ޞ`??S4~'s{{+2g6s         q NWl(''Gyy2
>ds+x,o=x,h^N2Fd3z	۷N>JHHσ
, 3}):*0g幓rOumr8Pd>V$\w?	p1S999U^^L(!S}lwC(c5x\^.KrG}'B_$ڲejԨSle^˅ҧʯ>
8Z^ICmUd\z<K嚁ˇRݖ\GDD(ZA@o
   \H    [  T,4ákMըj('Ǧ\WH-Bs:sFhC1;IVFm&
<}k#eg9OgICxzm圑$]۰j֬Yy|n=x   x       aȓ&IvkEqI$áUwa{T[O矧-޼ۋ'	דtKWDFFZVJ[xk=Ico   o    =  L!4}Ҽ;Iq8*h.G1N"
޼9Obw⭧|"""UTd   @ED-     n ORfIN#tyv((+[{tL$\n+/#edd$}o%Tй>*S{          {DHg+3&JGD[Ͽ}Pn[}o%bc    .*     9 1DO2I+{M*Bn*7k{    
     ~  )WJa(_(s    @E#     q?      8W   \H    H      2   B-               o    `[                7L        o    p     @p<   x     w          [     LW          [     F        o    p     @p<   x               [     <         @!H    7     ye   [     ܸ     +   .$    #          !                      7o     ye   [     ܸ     +   .$               !               Po    p3D     x^   p!     7n              p         @H    {          H    `[     x^   p!     7n                        @H    !o         [     ~3      (W   \H    H      2   B-     9         o    0^          o    p3      (W   \H    H      2   B-       ׮];/==]4uԠW^]@ڻwo~k7nXΝ+    W;o    `[  ZK.n/wNL@ P9N
<[p@D     [     ~3 Tbbbv-]
F ٳݻwW>}`D 
        q	 CN KLL@ӧl*U`+2   B-     9  5k֬"
9Q PaÆ ռy2    x    
  Z			ҥKTtttE nҥKe\yJJJ*è     (     |  $-]TUT	:K.8p`G Tbbbϟ_`2   B-     n@  kdűcLR.]Z@7}tLݻzQ           8qbcc}?^͛7/ r֬Y-Z"     8o    `[  ZcccT@嗐.]XM     [     ~3  xӧz-IZpTR@tRURE͛7רQ; ^x^   pqw      T@ 7lT,\Pݻ71xj*lq,0qqq3fw.F{A8-j   p!      ʑwBEOF~zMdpEUF?z饗$^P4         ~  4"{ |'WhEUp98    (o$    ƽ9 @YOBS^^^@b|d*&0^Q_ c
   $o    p Pּn|3rey_+tz2L/!gyϋa4x>y>dH׉1rFXrA▩Q|݁иO(q[W<(h;
{oPlrj*Gú\	X8u'uیeʐY@
ж`-\q"U`(`ݡ<P/*^
*?x2b^b%]rxowI_CwU/[fdrl*G#eZ   \H      2?dNN.ԧ_2d0Mܯ!׫5]{Cf{gʽ|C<]l;<ԇ-勌//~7˯YS~Z_y~߅t"smOl!_P^oL%]'!"X?7}%+mk1'ڹ˔/Q%SKLvYΧOnW
wUAL)k|νW@\uU>IwԟT}W9P`}SjA~͏x]+u[zb\    ;      *z  b<	it%dA#ɹGS
wy2湇.^qwyóGo|w||^^~㵼<
|`|AvׯX߸Ntz_>ӭ(_óMw.=^^Ż}/t+k~7;\zFP)'677kZOnk^ǆo{i;SakL+rcSu{ŭr|Y|Nz#ǳWZ|Ы߳:\̷Q`{#|k^#zoo?RpCM`|IY'T~t?>ɯ
i>SzG;~'?.!󓇕W{u-Ź    @Ya[      P<?JHsTE3Vi7y$)+/61z/$%;Ō+j0{y3jN)|UҊXF=VMC$Vn'ɪ֕ +ɦZ\\a]R)ƱTxE>(
t܆VFQ:ŉ58!/
.x]T]Gɶesv/!pW*vt2$e'   x      e?!͓x[;<Α-?3C~bb	6m(9 )/fσLޣr.2U   V     Ps (C?IJq^B:PPx'S^y1a\K   F-     +  e;)Mrr>Blb37 Ϩ    5o    p( e?)M"nƕ@iH-34   B-     n@  \(
 pyބ۲A
   x       	
@8Pq JI   x      # (ቄi 0S    o    p  @-<^&IY   o    p  @-<^&e   \H    ;G D4cҧ    ('$    ` PND4c)         q PH%BŅ[x21MzF   .$    
$  p[x21M5   x       	
@8P	 JI   x      # (ቄi 0S    o    p  @-<^&IY   o    p  @-<^&e   \H    ;G *}[	}cҧ    ('$    ` PNGNSNSs-p~tjեZvVVfϞR]/*g-ҹpO0csڵS׮]ȑ#^w}'өm۶C5cիX9x`к뮻wy
E[y90    Gy     @E=; @yRa(--MO=T@ʗ_~G^rO:[n"GڼyIj!oÑtiFw}$);;[?׿jڸqjժuJ
Oݺue4۷kҤI2MS={,+:"i^L1<    x    
 @eզM۷O?_g޻ﾫ͛_W9EWn[nF=C>N=JKKS߾}@}ӧϴ|P{֟'o90x̑t   x       h[۷$	m߾]@PFFV\{O'OT
Էo_=C׿pB}Q5tPuAԠA$I'NԊ+as=ׯ٣/Bth:s挢gyFkז޽{l2:tHQQQט1c#I%.oҥKp(55UM6tR}r8Сz)իWϊ/ԂC5jPu={V/$]tIJKKSzz"##ժU+5J-[$M4IYYYj۶^{5>}Zqqq8q;YfJJJRVs͚?^|E%''ê]{Lahرڹs$OϜ9S]vUzz,Y{V5l0uرͶ$[gחs_R}<M2Eiii;w:t Iz7n:=zT\s~hĈڱ&IgΜܹsG)//O}U^^OСC5f=#ŮիUV:p$ȑ#߿&OT9sFIII{~+/eNմiSzNIIuY*!!A=z)~L˵uV<yR^{:wDUVM{iժU:r䈪TmjԨQjҤU͛i&9rDyyyjܸO,6m*_$L-[L۶mөSԨQ#=#ݻ̤I֭[kƍԤI=ܹsujcǎAJLL/x@			'OjLtM5jZnmgϞz衇G۶mSvv:v	&hڼy.^(өI&k
K#   (     

 @EpGak׮JKKi~~#''GO<6lؠ~i֬YС͛ٳgK.^D3fh٪ZƎǏWrr$iر7o5k֨QF7ntK.iذa:t萞z)-\P?|ݻW#GTdd^x7Nѣw]pAJLLդI}g1b/())I׿4tP?^+w5uT%&&jڱcO?6mڤ~X.O?cǎi͵۹s>͝;W˗/?'|R8qRSSe&L`}'8=_ְaôi&G)))JKK$%%%sjР6mڤ:ĉzGtA%&&jƌѣ{W%ǅ[xr)r/^ԉ't	?~\̙3_Bݺu*7sLiVU4}ttM7oqFwaǚ?޵kF^lⳞZjSN-Qѣjذٳgնm[}6l"""kܸq:|ǏKr%;V|A͛7OmڴѤI
~֬Y5k֒%K4dy?WRRN,X	r3k    IDAT&믿֘1cs݆
/}={O5jhגּ)94M=3Zncǎ>}֯_w}z~zjB)6c?^M6/^ziҤI:s挵3ghȐ!O5vX͜9S5jЈ#'K*""Bk֬ԩSk:r䈖,Y^zI}IiN   Ĉ     q Ps=Zv>skm۶)>>^jY?O͙3G:u$qr8Zvs̙38p5i-rJeeeJ*jԨ$nݺ>\uɓe%Iҵ^'y\?W_>+jԨ,X`-wjڴi:|K\ަMD^zY-\P111JNNVTT$m۶ݻ֯_CW_aJNNoրdffٳ=zkMK/'OZu3fX#v]f͚6mHr|ԩSu)Ą駟FY>|>P׮]U~}ըQC֨ץK~zkTN:)!!AW׮]gǈ[~m>f͚5jH
*Ry魷ҬY__Y5uTIRT~}+[oTc}Zxuy*I͚5Ӝ9sBgĉV6lؠǏkܸq>vU>'T͵`+1>>^}Ѳe4m4}ڻwM7o]'OԞ={Ԯ]g߾}j֬~ImݦUZ	8p@ahذa>[vܩ/zou}iԨQ6\߿g%*Ss]viܸqz:ҥKջwoUZU-Ξ=[\s$i̘1>H})NBmjӦfΜ)I;UV-w֮]SNO$I;vԠAxbX6nX<$)66Vk֬ѣG5uTEEEW.]Ki2mY3u%          ZlFijݺ򔖖c,駟jժVҭG^vZ}g޽ԩ'[nWOK}go&YFg?Ç믿Vvvv}s:z7ϗ[M7dxjr8ɑ$ծ][7|vڥCjϞ=}6mUT+"ɕwѣ%'[Iz$YhϟWjB36JR:uP~Nt+F#o~YfV2-<^KJ&=s挶o߮~ZӧOW=B:BC<#]Vo[qֲ233u=XǙJ.u8ڵkx+~۷OQQQVҭ$EEE鮻\Zxqȣv]:v);vLcƌiN:С>SI`u\uR?ڵFܹuZemVnݺCjӦ+I=$ҥK:v옾;+>?8O>DSNZ~o$5hJ\	ߞ%Y'SNȑ#zg}ٳO'|믿^/};j*effZI-ZYW͚5k=!IիW׹s犮b0x̑t   x     w  </uM[l3<O?TϟWN|j$hu	'ܹsҊ+zj}ڼyvt颉'*::8֭0mZzN:5jEr8>?]w;wNyyyVRA.<?$Ooذ!`
HrlwԩLݻ`VDDzD,jժ-222Pÿ~n<<#2ӕg
4Fӧ~a-\P=zTj"I_}uV=Vٳg%IǏsa?`^\ڷo/ɕnA5kX6X_WqI<{Vt-y衇TzuJNNŋuui̘1֭Zjd[N6lК5kTF

0@O<͚5Kebcc_zNlon
^)$T'Rm,̙3$[v]L1-   A-     +  Đ{ѪUt뮻TjՀj֬1?$Y	<5ҤId+Zfj׮m2[jzGԿ5lP4m4ܹXXzul6>}giԪU+ٳѓdܿwX6""BT^ziU^]t1=Sj۶֭[_r8zk׮b+HqTAԩS4ypOe"gu
7wQVVN<YJ1zhW״iꫯn[ɋ'O֍7Ekb'KyI<qt~ХK|ok!׏aӧk׮]Zr&M[oU111r:r:qF\Rqqq5j(hɒ%['Oj۶mnk(B=FGGp(55U6-`==:xbm^zЮ|V:u>h,$_iaH<    WJ    p*}V  JݕNմiSzս{vm|3}֭;ws:zP\\մiSK`T(gv$l}g(PV|zg7ߔjyTF
5o\_~Zh-[e˖SjjO듔CY<,
2Dqqqr8\gx~$7Pl6}۶m[ݻJ\4h`X:pO+/##CPJQNEEEi/vZIR֭p8ZY˖-UfM͛7OyڵkLo裏>)5nX۶m9O>ݻwm۶[oU|b9shѢE!ψ#4eIk׮zG^)))۷rssvi	\}?cǎW^j׮E9t*''GgϞ'Nhɒ%pBeU'5knPZZϺw~zĽc]Zwy}   /"     *n  sV\(u12]vպu4e
6L͚5ݻ??_B5jPTT{9
2DjÇkGXݲeLTϞ=w7kZxuӧO^<5jz)WϟҥKզM9N<yT˓QFi3f+ݮ
6hϞ=8p$iz뭷4rH
<X999Z|$-Zfiղ2MS[no-ɕHx9B3T:q֮];CCQZZ{LիW͛_h̙w t}WZnھ}ӕ$)㫨>pwܡ[˖-w߭X%$$hŊVǎO?ixZlvu]jӦN'xB]w6lؠӧO"}a-\P{V.]J\E5jƍg!Zbv*Ij߾ڶm^zIOVfkϞ=?j׮RtA-Rzt:uY-_\M4Q\\rJ=sӧ$iÆ
TNk֭jٲj׮={(55URh;Sv&MG}TqqqoVZY:VZHm'SO=I&G:v옖/_.)Aw?խ[W;w2l   B-     n@ \
-[Ltád-YDk׮O?Fg< ɕtd-YDf҅ԤIM4I{$O'$$h=z-wJOO[o?Ϫ[:v޽{kʔ)עE+())I5k]wݥ'|R󔙜e˖ir8ӢEtK֭͝;WSLQ͚5jV$iӦzl29R5k7߬+VhڷoOW(q_~裏xb9
8PVŋ?QjѢ-Z:8f ժU_?VUT̸q{nJIIш#Tn]mذAt:5rHթS'lZ`.\˗+33S5p@;r?vܩn5.]hJMMՄ	%ө9sQF\Wrr^}U?^͚5ܹsuwHRH3h l6ZnѣGpu֚3gVX'*77W-[Trr7n,59sH5kL3f˵o>
4#sg~GĨ_~>|x+NBmwy^xSll&L$|cSff5jǫUo_'   $&    \(33S.]R<z/B-uhU Pəp>P6֮zVQ&{*''Gִ,Sȑ#10"{ȐY*r=Rddl65b#O^^򔝝m]w'1s[Vy\mۦf͚)..ΚvA
4HK,Q1U̙	]UV\pemݭ Id~PQQQn  pUa[     /  _Lľ͙3GÇׯ~+]pA7nTvvz]ą7Pz'ԨQ#<yRj޼54!1   r@-     +  SQ6` ed<>{vsH8LKU\"jEjXPPZX(>Wm-~=Z'(ZҊ-
	9I{w~dlBMx,;3\=/5k֨G:Ӵfeddĺz]!@,\P>q<xPYgy).\>6M8?   :r    DD  ОЬY4k֬XW@tk2|+{wj50:)p   @        i 
(]vLڔ    x       	 
(]- m5    b-        ]a iҚ    
     xY  @WAتk2|cКt8ξ   [      Ȑ Q@7cҦt8ξ   G\+     @q I4 *(]ő#GGw޽%*8F!    t<       " Z8bb^*,,޽{^ڻw>Sҏghir-    x    ;  .fG(((PQQKKK{n8pE葤Z	 m&g6       `r S  D*//JKKr*0_YYYVVV222A)==]5
i;/n=v47   A       :@8P">맬,ek}_~qrjhhP]]jkkz1tsaH&    -       tݷZi}_UUUQ׫WovȐ!JJJjڛ>1Mz   o    2b  EF
Q̐Z+\ۯ_v\@ϟ ptn|F
   $     ظ\ H3 Qza+4UZZ2Lk}.//펪<өN0`QFf :7SxX   [     r $\w|a{Uqq./===wZr:D큿xh;aHf;    8    x  F8okjjgϞ0-**Ruuu'dV6;;[			Db	 G4z\{   8    t !,TE7+++./)))dz
:Tzjwva/{XaxoQm8        F[ F
qfPiio:ᦵ3yTZ	g4?_=f:alݵz>Etzwotv](x7dx*v$lv޽ڷo(UNJKKLU>"H>8wMJ2CόT
l%2MvX(M.v}Z._ZRo藯|}'m4m_ufOv˔pk    x       1dH{zqdw40?ܐwwz#pizg
}k7OQ.O齏n~!
{~f>T?}o=/-!#v
~40쿞:rv_ڿJKKU\\";T[RR"˥h8
0/D4h(Y
y9vFyc᷍
cw߳㍠c<<5}4\Mz2[./M;oB4	^G
v(߿<2$5?|\\~Ӯai}iB,ΧS{j
_
ϻ    Ж    `[ @Fs:@C2M22e=Fw)6n
77d0\4\M
;ݰ4ܿ~5\MC;h93}p
<2R-#)5	nǅ|O;h9w[fxiE6U۪dj?>
fff*.&m)3FcFӮ5CMǂyߴ~u7#`>vw4e0~ݲ:5)ǧkun\XoC96گ(`CQnOx5=cRzZ?Gjf
uZ?ᏁGP}]_          7\:t^
r\2n?$;0֔YnO
]NUf'By-OpygB?G+>`Vǜ7_oׁ:p>4[RI#T;tP%&&Xhooft%
jhh(VR}/ jig[mDqa/XiB|؞vt۠}{%Szիg0n4~PPVluͯ<>vb9g)jo
:"s:r:o;y   -     ^/ 0P\\ejl4hxi;:P_~.
t	.K*--UII"4p@eddhPFFC*--ۣ*Lmt:v5t`2RFCׁzOOO޽{ǸFLзY    IDAT{ҎW\\-k    x     W  1HX!\hWϞ=c\3MSWqqURR"ˣw_633/`;x`֝NUL;p|{ٳ'm/p.    ko    0 hga4M;8b
z$yX8#Ƶi*..޽{U\\"
644D]^zz޳
hµsVPv۟Eۋ\         9 @G!VXpA4iNb\SSSBݻi޽۷233,=++/@V{3}8·v-t2!!˷h>L    @"x     
zuV/466h}ٳ233>:TIIID|hNש^炎   <*       P`@HdiaQ;Lm^w\;.QxhYۋ6   @G#x      1DhsAQqqTSSm۶فbE
<XC	4hP,9D#d    @gC     / ^j}_jlli}õ~i  h+$    x    o @KTTTh޽*))ў={0mQQ
_T
06;;[vÇo%  h[   -     \9  jjjTPP:I҆
zd;PCyȐ!JLLl      F    ` cZ}}}P6UQQ
6hÆ
!KLLTFFF`m߾};`       7     x| @rT\\1T~fԘ1cBkNK  yA   D      йRLKKC?4g-^  s#t   x       t
-..VCCC奤z
2D0           X v7D&1X۷ov\"       [      ֩UAAA`Ç.tjAAZh%  @ Su       F  khhݻw<آ2BPk}Ȑl%  @k   <    # @7rTRR1To>fv\*       h?o    0 8R\LLLTfff`m>}q            e- #jU__uyNS

~0`@;.   :3S<4       `[ @gqٳ'bEe!NK  -   A       :P]]


"j:Ԣ2SRRBPk}Vbbb;-       to    - (566FݻW_uLLLTfff`m>}i            eD @n[%%%C2p:4hPP{q   蘒   -     6:<bD.Eezeddt   m-   A     1CEEEoQ)))!{>2D			D       X x     RgϞ̈>}       :+     x| N]]
#jt:5hР    ])   Ho    - tFE8p妧>x`9vX"  MEEE*//y
6L7o$ڵC晒Çwȼ-   A      @s*---//nQ{C2di        [     ,ty Q۷o_PmII[Tfbb_6TO>D        4-     ^L IREEEPmQQZTԠANK   h   -     6:hϞ=Giq!{<XN   @G t   x    +G *,,lq{C=;;[			D        t.o    0r\***ݿѣ233#k{K  wտo<xP={TVV?|mڴIӟl2%''{s=۷o    }    ˠ[ 1TVVPUUUڶm---mUڡC*##/X;`6^  p/cI~h:r>̙35nܸ@{1C    -     6:^TXXhjUWWrCPk}<xNg;,  n>\}s&N+V詧I'@{!t   x      REE


TRR/i*++kqiii0`@`mvvai   }ᇪҼyB/\owk3ԤIdt]wnзm7֭g}{Gzjiذaڸq*++5` M2EvZVUUiٲemݦTמ={r.HFj5    8V    B {n+pmAAZTNjjij333'xb;-  @|ݻwؿdeek
zjwy͛K/ѣ[<#GkU^/ҥKշo_irJ[oUjjjkkrJeeeiΜ9r8z뭷j-    {#x    3qF/o?Njh}߳o}[Pk  uAw\rƏ/Iw/B;wlqvk޼yJNN$]zںumۦq>[nEiii2>|XsN9Ik/   -     6:7o}Y=`-Z  ps:r-I'WFZZ[\NjjIUV@f
<X{֪U#GꤓN_n 2B   [     r +kF$|ɺ+t*777Ƶ  xw#NSPPL9N{XRR4a4[~c|||P9RVV:3(IJHH߮7xCi&9~7o^        `6oެɓ'K~_讻R\  O>Y;vЗ_~aÆ/..ҥKuhڴiQ.<[SSz?aZt^|E]qk̙2MSEEEڼy|M;:Z=O    @u     ,z i{Oo	 noJNNSO=ÇӺut:5vبѣ$}嗭g޽s=W+Ig}oYeee2CYYY6mVN_        ^\@i&;o]Ǐq   :d͚5K=N5JWeeBgV.355UzW$mܸQn
.bmٲEk׮5l0%$$\d}*))ь3j^@w   =      ^֭$iѢE1
  @rꩧ*??_znݪ{Nߔ_5jT˜3gsSNN;ＣkbbJW_UϞ=uM7)55U<z!رC3g駟~    tit    6LӔRccT[[5n=vFd9~"?~>'?ѣ> RyZxq 1QTTXWݤhᱮЩտ]t$Cr:r8GS5   U-     ^\K    @^   [     to%   @ܯ   x    +G $ڵ<tU        tZo    0tK縸        tVo    2      $W   <    $     и_   y          <x!zuuIKݻpW     zo    -    q8Nuݪ$9Nq9    йp&     ^L             xq	      4W   <    #          Q x              !    ˠ[     _    x          B~e   -                    X         @o    2xf"     @Hܯ   x    H      q2   A              [     ̀w  Э>|X2#UZZ*I;Cc\{ 蚞|ɐW\aOӷoߠ=z_|Ú    ;     x| @{ｷſ]w5c߬Y-X@999P# ~e   -     ^\@ >}>fʕJIIiGzc D   [        	%&&F5ĉ5uv rss5n    h/o    -  ZNN,XtZbE }wunʔ):F     DF     /g& 7 [`rrr:F plKIIѽ4<@@8ܯ   x    H   11Q+W;>''GX# 8M>]g}vK,W\         p  :uLr߯ y䑐kNN~ŠF     F     3  t{<@P lʔ)bT# 8o#tƠF     F     /o WVV,X`OII<W?ugǰF |q2   A     /.   _ɑ$-Y/ h{)))Zr$)--Mw_k+   o       !11Q<rrr,naԩ2e.ź:     u     4 ef>:,m߾]vc\Ċa!?=/ph{?$ݶ~ў   @    k  BTt_V8 .|;	t%aЖLI1    [     l\. X*4vkCiXf|ö'ЙYo;;{
   A      u\r~/BU@Ps:r8vX7
ݺstV[)44·    =      n7P:] Ðd2d$}7%rȚ^M1g:#By)Si0|}~W[So[z]?!c'(/Vm\OڏB8-}۬n'8~xkz+iz0;dIX{
rri5lgwm}[3l.S2y:|uG!?Uv!XtK9޷A緞B/ynH>-چnzgr{~[.UfIj
         xq /nn(Sm=Z\itK3ޔo@5ݞ{;<ː6<+O[T۷<5)i>ևiInxw`yf@y4ޛ[x=>x7>of|`yӻ#oMkD_<3`?1}o0W<wSy!B'xk9;lyV9Sܦr=Oܾǖg[mF{mgn:Mv:7vv;Ά_;.mBcy5plۮ}7qjojo;77ևgv73ݷ-LS-џ6
`/   <     /.  |{3ah^szܧa|>o6M4U$oo7Ug+wfZ:ޯ^l?\Y?p|@d6_S>=G|rB?tYQ-4ǈn]׿waօOBxoOВ?UFIRccNnxvt7hx:8M?'1ǎt,AoXyOt>
(/T9
^P5P¯3,G^Fu̌n=y^#F.>p8^o
   -       ?Pvjl'SCD
nAum!!ZwpaO>>Ns')Us3rL&#o{    hn    F Uio/3}7tT#vB֖PXgf?   #x     ir\~ t_<notV݆g{
   A     /.  $ N۳Zi4@oڍVo   [     r DԺ	tFm    [     xJ,  q$UD(Z-{.         x$q p=vLѩ)B!Űo*Z    x      ~p
wf  3:;릢W]C   -       bS  "
t        `!Q e?x
⯊ >sf3    8:o    * [!t{!p@a7C   x    H  ?V8;3nV C]uSQ!   A      B)SV 	t        `  5xK<WE^{O{.    %     x$q [x
ݙHB$]aT-   A     /.  X =Zg4u#
tvME1.·   [       O;ZD
*7    @+    B ~33_t}V̴g    pt    EGU  ?V<B8*1d"N߿}ME@   q        ~pJߙ_Bn$edd袋.UW]c/i%>В%KTQQ!!45qD}ݭ%KhԨQmR&Z^Pqqϟo٣.L׎!5g?$jkk~zڻw$iС4i$9iMی3n8z꥜]veAم^3<SwqGUҺcC   -     \9 bS>|Y믿+VHfΜLԪ    IDATգGv^FUV)!!AuuuSfffK֎;T]]38D^Zcƌu5="69ۧoQ{Q^^&M$˥>Hwy>-^8b5m3ވ#4i$IRcc***k={n{\p	[A
    Jo    0 zmxJBB&N4.ӥ^_|1f۫]%>C}WBBB݇!PgXhJKKj*r)𫮺J=x	;V~2Z6
:T?яp
O謳β]wSD{    G)sh     FbDo @gexkv\<%..N)))r\~÷nݪ'7n&L|۷o;vhܹ7n&M~Zz.\(Iڵkrssnҥ.ԥ^j/t
7h	7nZ;$_^W\qƌɓ'GUcc=O?5a5J'O?555z衇4m4=Z^z?G=6mڤcJ^|E7NM1c+Лo?_=̙ѣG뷿$T.\1chZ袋4vXM>]4mC4kԩ5j&M{WQoh̜93d o1c_}͛>[&Lmݦ={yO.R{7n+77WQRVVk̘14iR~dճc--BkHg}-[h̙~[˜9steϞ=_W]|7n^y啠V>MQFi7oonO~z{z4ap;&~m͘1Ccǎ9眣nM/P<5~xs9Zh*++i}޻wrss[ootwʞ.L.9眣cjΜ9׿v;S~~sҥ<m୷۹skj>0웊!
   x    H  ?V8p:pڿvܩ{W;w\`O駟jܹjhhw߭|}3g***u]-[Lz֭[͛7U=5|KSRRnfwSnn~kƌ˗K͛}Zl~h͚5z%y=o<=쳺K=z/_/b+++}v;x+yg+Vŋjڴi;ovڵ߮>[%%%9so߮kҥJIIэ7h4M|_+R˗/iwޑ6\v֮]3f衇ٳ׿^lPN۷kCiƍ%I7nu]x-^X~+͞=E4wyZ~RRR$\Rвe4yd^Z==>V!<6`GBOLLҥKuy
4m4]:3~xb_^3fʕ+u-P,ȑ#ZjϟӧkȐ!a8hWnnVX;CvM7wcڵkկ_?+z'_?}}3f~i-ZHo|AIѵ={l٢oYsj۶ma׏(''G[n
9~ҤIua{eM4)yDźJD7   u       S)mOZ믿^\s=lʕJKK?=zH8M2EO?̙uphݻ$)+++q-gUTTh3f$iĈZf냦ՓO>)So$5JGƍب;vSN=ܣxIرcO?Ք)Sok۶mZl:,ISn:M>]YYY!jذa8p:$IӧO{/ܖEtJ~ߨVO?$Iguf͚_yyyڲe6oެ%K*++'|s=7mS~J*))t[3qD-_\ϟ/Iz7d++VQFiԩzǵdɒ5dCF]G˸qh"IѣU]]gyF3gqzm+xrIRfff~wUWWJx㍺K.KoUVVIM7>L<o׿%0tu)99YݴiիW/IСCu0׿*mذAyyyz'm-_|O.ɳ^{=Z`ATmut%IcƌW_|P>hZNߞ}}]tEzGjʔ)<ms\\?ʏ    h%z    B?  _>+Wjʕo~#Fo߾Z|zyLֶm4~xũQׯN9}G<wcn%i:'pRSS_Jw}~m9Nr-:UWWs9o9s?Iqqq:uV^-0TPPM6iժUCC$i˖-JJJC+駟Mzݻ]cnzڡ.ITVV".|kQo}{ڱcf͚'|R;wE]dZ-INNV^^^}UnIK/	&O>:p
5qDޞSSS5zhmٲ%y^T__[F^ۊ!aAF㤓N
;.11Q=.UVV>/_7M1i{WjʕO4rHp
vVپmЈ#ԫW/
}9үީ]CÆ
	'`/i:3SuuuQ/8Pw^u?ŽGbu*L{    Go    j' 26|%>>YOƏZדO>?^7H}Y=A<Xt!}[
Hj=zhz'_g_WAa +zqǅ-N˗//ZSOU\\:԰(n_.K}-[7<!!/%):tH}WzXêTYY$w@nGի^z%=z5p@tM:Z-":u^~e}'JMMՎ;4o<[p=nk:t(V9bРA\h8paK?X+VkذavBM1y'SO=g}Vk׮Urr.r͛7[JJE>[~BB4ahJjԨQ!CEEEP/롔aO<YK,сTUU;woܖ0G    x      X=vIIIZd~kѢE(i)/2O%yJ_YYiE*b233pBz7vZO/{A_~k)??_gy]?ڒ'_eg4M}^__*撴o>IR~.{zXo߾JIIQMMjkk·vҡCǒ7

ԩS5uTUUU飏>Қ5kpB~JKKkѶNӐ!C[o)55UvO>vOV{EE$O;c2BxFCbzᇵaÆF]ГO>TB?gzJ'p+:t-9&sssmݺU=֬YÇ+//ORpvu͎}7֔EGR^^]viڴia9su=wQEEwNn*jRэp>   <      1Ǖ# @(v8c)'t.rܹSׯ$%''+''G;wԈ#4rH9RÇתUHk֭*+++**__II=^[n
[M6i	*((a>|ϟC4h#G*!!A^xAz\.>SzꩺgQQJJJ益F7n+W_ǇQ[oe6MSoN>=Şqڼy_4Mk<xO?]a.[L<@pܹ-ɳt5ri߾}-͙2e6lؠ{O'O\l~=<xPxk*..ꫯpNӯh'~?T||oG^
!5DԆ8餓'xB۷ob
UTT?aen߾]={n?$[#cG%\"˥x}{w!I~mن
hwh$Mh\޽[kȑzwnݺ_Zln.䒰S&LІ
okĉ͖b         3  ̝;Woywy:L7xn&]r%r:zg'h钤3g_OSԏ>_j:zj%&&*99Y=nw
G/ٳgO>J?񏃦ONNW_UVgϞ5jvڥ5khƌJNN'wyG/o髯ң>*4USS#ISO=_׺t??(@6mUW]r{9rDzg=Cٳ;wQT߳( I*E(oR엊@U" b+DVKZ۟
V$ܬ
"@.!؝ٙ&{39s,W_}&MVZiݺuzwh"Iug讻g}zuJRFֲeԹsg__|V^ݻHGҾѣu}/ŋ=˦No٩#G\pXW]u$9L_~~ᤙ۴i_]?FzcO>0`^}U=#8qICWAjW̞=[?4i$9Rv>M6رcuEe_>}
;=}YIrX_B3fرc%I?Zh;룏>Ҵi4n8ٳG+WԀ`33w]_^'OĉթS'c=ɓ';7.HҮ]vZIYz?k׮]<ygњ6mL3ގLA0   !    :%q @cbxk]xJ֭5uT~Zt͛AӪUtm)++KEEEZl:,I҉'|P?O`nZ&LO?;=ܣŋM65tP=裁iӦVX+V'?:ݻk)o^s֮]|M<	馛dY,Y
uUƍg}VHDYYYb
=#ڿ5}t7.܏?X۷oO߯ݻwX+VP]ꡇXhT}ѲetgKޫO/uA?,I~
BzgvZjРA6m/Сp8nݺy
6L{|Ar-UxbK[+WԜ9sԵkWM:U6l5i$-\PK,駟֓)Sh͚5={:u뮻N_~<v)!Aj'$;??_k֬ڵki&ORvv


pB9JC.ԪUtתm۶WoN;zgrLO/sz뭊F۷>zN^cƌQVVfϞ<3F^{sH&s&2[;vLGU~~fΜK/ԓߖ-[eI;vBx)?:,xjժvd03   cXu1     ̲,EQE"=zTSmVS	]E 䥗^СC%I7oV>}BSe4ME"UTT\xLl!Cґ'*'\r%*))т_z'tku^mݺuZ`6n̔
?רQ4w\5ӠY]B?W^^rssp8,0R,yDyy5|VXъw5QFiС1cF}W;Q
ϻByyyjѢHӁn$}gy
C   h6       3UVQQ1ch߾}3go@꥗^ҦMԩS'1(0b|Ccax     D-     6  n@**{ǵ|rp	Hm:u|J-_\<N<D-ZHuPUٿx    Ǉ[     	 x3Z7<'r'L	&K~cǎرcnܹ4].]K/AfEj3z
Mag8.    [     d g4;v*4iHD}SQ=W   @L+     @  Bx
1
 -'X    @5x    { @JxKx
⿊B@    ǉ[     %q =Ex
YbH!$TT#   C-     q\@ x)ܙ4{HHL#
4tME\
4^|   1      @'8c@Zܠ<     [     lDT  ܜc&<h_E =93    o    c* =-?!4{!pn*   !    8.  < =Ffp"þƋC    [     r 4wH	4    PM    ` 34{"+и)   q"    8~I axk4w!AFb87È   x    @  vp
wf  R3ӈ
}SQ=W   @       	N!<h7h0<    j"       7	O;C*,ؠѲ'g3    @x    @ R"X	qٳ*&T   ɪ
     Pp	 `!#rw֧2d$Ê?ߓu,ֽ<^Wm%ÒrCv,W|}_R/SXnIjyyp?J<?η*_*uXDvXZ(bf=֬?!g?|}ްLB%CK2dzJJ]cjY?_@M^?>mi8w}>8q_I{/3^4gߞ*woϑx     1    # K(vH
ybA p/7tN(}F,8JgIY骷!ɴXOrk˴.ڞtrlW\	OJʏz[GSz;?޿rfOoG|GSx~xz-_~|){m_%y3]dec\    IDATjg{p8Lm3P?'#X5GMg0ciޠZC2qto$^2߷1`vi*l$=<V\gyPR{%4j=;G.OG;nO+×Έsϸjo^NoԌ_=-Ӕӷ8nܖb3&1c    T     XG @dp8aNDhTf4*2e9Np?33hrW:+?]"rfumȈLNgP8Qe/JWY]qoT̗OP|2Ktrj#}y˗/Ⴧ4x`zY}uahm{,2w>,~߉[i9EX|-KaɌ/6Gu}P|<ƄpNeo	mÈe'f
ún1hTL+-_Tqx/'+?txpqj$몋ݿϥ{N>wq {[l3ϬaI_CTfq&Un}Q=mIhJ'n0ҵO0bPb<_乑     P5    F ;o,b1SѨ!4d1UYUԑ?ا*<]g^^TArka,'X
͏;6++K
t옥HR4j4ggk$I:M6\ϙ?V8+KjY   ;o    c[ h?!pXhTe9h>쾑z
vp8,՚9s,_ǂn	-Zp2'{oAO   b      8;~"yjvj͓;xQ
dYxGm3w    @    ur h܁)v?p#Pys>#_VVe-{{cD     C-     q\obRAUhᰲ [n/OmlxeI        R9 @VQjѼּ55ݦPPU    [     r !@6l]{c-    3U     ,#               8&        @     q	      +   1                     S         H[     ~3      +   1    $     `ܯ   x     W          d[     ,#               8o     q2   C-     q\@        @               @    Ɣ               8L        @     q	      +   1    #                               `[     @ܯ   x    @      q2   C-               o    1-         4     7     q2   C-     q\@        @     p         @    =         @ o    3      +   1    $     `ܯ   x               d[     lLy          
o    3D     @ܯ   x    @      q2   C-     \9         o    |          [     f        @     q	      +   1                     S         H[     ~3      +   1    $     `ܯ   x     W          d[     ,#               8o     q2   C-     q\@>yޡCz	    4<ܯ   x      Hڶm$)''G;w        [     lLy4kvm߾}&        "    8L5;w\    hx_   Jв    /"p4_;v+"[       @L[˲@[s     a˕#ٻꪫt1ao}W        4PveY2M \    @]nPHaȲ	| H$+R/$nPqqq=
        4TI[/&    PPHpXۚ-F۷OַMt'k\+    h,A   jh4*ׯhJ%HQ|V!+IVt_,Fiˍɼ\I;N,+Y"}rY1w{Sr{ϧ&ͨRm?͒RT핪TUQٶp2|m?RJXc:>V>i/w;1u<cϸ7JvL1X#1W-1(e'eUG~5Tnr{,T8gz#`?R)S&SIH^_x8ok~~M>S[qUǏjJ>u<e?$ytSޟ~l(Jf
4۶mӚ5kzj}GN;MO?v    0̷/   @8=m$#J j7]VSOSsڟ^)S[?(/(6<˵~Pzw.L?\N.<k\hOg^?g}Ly{]'u~c*K)ڥ+$k,39(]WI#7E:ҥiѿ/ul}+-pL[?Q]k	3Z^Ny.JyNJ*b}w?J}[^uۧbng}#>ԷZ(*T^-7i'6'o_UY:X3Y׾sf`z_<e_'G]ߵZcgqg$ڧSۧ
'_yw}ַD0o%鏷<}8cEO:u8T%I)0[*--͛37,0aVZE-        T`|Fe$C]:4yr_陥p.{>j$$3TkJl̶֪3>n7}=<,?9n;4LѿR%Q',c˷Zۙ\ʏ% c:>l
Á흺2ol1fޠLo+Q~|z?9uTib=Tq8ƍlJZ'ktH?:ۯzժO7*tH'm;ٹ]AYqWL_iq]$UYV\5;5kU@cY{=j֭*--u﷼w.L_~W        QR୤۰N˙    PݟoH$,P(T0.а۷Oeeeڲe'wh}jȐ!wrm   iIw;   МJ[S    i+֚3_{fub矧]0uMEEE*..<ѣfg   f3*    &)N$    Կ՚)/PLΝ;k?JN8AEEEIɩ         ͑'}Q#"&3 lY` gT6Fݻ7)T۷oWEEEu[h޽{^۩S:         oS" ٳgkԳgO}{Ӎ7Xす&Lo-[hUѧO
4H?qc/Ν;գGG}Ӈ~VZ3u]/IW6=zf̘K/z )Cjxn \N};r䈶lْ\[ZZ]0{j=zP(     T&   o  ijժ,/릛nRyyn^ts9ڷoƏB}oۺ{4}tIR~q{ђ%K4hРڪ>  3R|`hT;vH
ݺuv]۷ڏͭ-     /n  f TɓձcG{{VXAm=YvvܩW^yEvޟ;wFskQVt7cM  ٳ'iڭ[jΝ:vXu[h^z%su         +c[ @
]vA_օ^N8A-ZP=4{lEQO_~ԣG͙3GH$7xCڵӅ^GJ5sLu]999۷~_xwܡɓ'SNӈ#;xպukC>h#j޼y֭ZlcO?MJ{i	ڵt9hU.λW^CΝZ$M0A}qȑ#u	'UV<x6l )/\_W?kذajժڷo.L~Tǎ/_~U޽_Z׿tye˖ٳ֬Yw} \)h:7xCk׮ռy4~xyj۶N9
6L'Oŋ^NЭa7
]s5~g}V۶mӑ#Gjݺu5i$
<[        Ф0- J}<xPtmڴI֭ӏc'?O
>\7#(
'ճgO]y啒k޼y2e/^͛7kƌ/tROo.
4H֭SNN,رci&͞=[gu֯_I&6m5qDK:p&Nqߖ$m߾]CQII~_9sݫAUL|PzzJ7x'ͮ]4` uAwuڶmUVq]zo[,7MtM9r:u$)6u_~_+
i=znݪ|+ڸqFŋ/1bkȑ#;w=\j׮$i+W{4qDuU-駟E9={̸  #Yé/H$m۶%\[ZZ>۵kkW[     hh,73   @y-3 $qIȿ8p~ߪEQFK/+R֢EtW:A#Gԗ_~gy3mYY?|yzg+Iڰa6lؠe˖iʔ)NhTv&MVZIn}m߾]z=ܣP(
6C~3ϬRٳGV̙35o<IE]O>Dtwu>ҥ$i̘14hO^ے_^ӦMӄ	$I:t.r
6,p-[?ԩSuJ<L-\Puf=SoK.zԲeKIҐ!CԫW/-]TvXw߭?_t
7hƍ4iGtwh͚5zԳgό y3R||Iڹsg^z؞tIu    Ƃ[    o UfiFT^^~[˖-Ӑ!CE4i&MH$Rm۶Mo9
I믿#GK.?{l͞=y_hڻw׿:A?Q4n8O1ctRo%Ic:tH+hȐ!NЭ2.**R2Mәveyo7mڤaÆ9ARg{
M:U;vPϞ=3.ӿ/^z%=ZzꡇR(ӷo_|?~ƍ#GjĈO^u]-Z8޹sg
8P[Iew@m۶bYRF} мڙ)hKm޼9)l:r'~,((P8-         h: P%FRǎ=}_ոq裏jҤI*//ҥ>leggˊ|'bݻWCu7뷿<>C;`WJi>LH>LԩS|g:䓓ַ߳Q3aY***Bkѱc4|-X@Fe]Ye˖zWu]wwV^,]|ZjڷoT֧~*˲|r-_<i=+uIi- hCVmIk:v1%nݺUtm&\[TT         4x 8ngq$i۶m)SGʕ+5zh'PW^:vPk޽z7uJ>z衇4e[NcǎuhѢ^y啤\%GoCǎG%'T9I裏Խ{wO>n:t,oݞ|2qI'iȑzG<gggo]wݥIԳgO^Ze~?:wXkkVh"zɤ  'CZ禜6YXk׾{Madgg pڠ     I   80- mذATXX(Iz5h M8I}vڵKgy$O?QF9V^8m۶U˖-@k֬u]aÆ]v6l^۷O]to[^Z<@Ç<={8nٲE[lQ3n!C(++K=輿n:O;O><˲裏@zje>\O<񄮻:}ٞeׯW4UIIIz=TTT~_~~]vIlڵ׿uײe˜H$K.DWՌI 4OuuFʙ/j&n۶MGt.]     u[    o UUV$4[oiڵիƍ'I:묳O衇WU3g,ҡC$8of-X@[ȑ#[oiԶm[OPHVRuM7i=z	&[n׾5ۚ3gG?y1BsQ4mݦ*Oǎ5cu]СC~Yf'СC5{lmVW믿7U*sѢEzuugرcz뭷^;sK/TrN<D_^f̘!)1?,4|Gw}F.HW_}|rOҴiӪTwL  @CPQQᙹO?t6mڨlKJJԲe:         T3 dl|ɺ+t;{L7߬G@SLч~5kرcթS'XB+VЩo]ӧO,_~ŋk6l}Y͝;W˖-޽{եK    IDATM<YͫvuEn]uUjݺnr-X@:t˵tR}Zbgׂ/ѬY4eE"qzuTݻ-Z^/Ѩz9sh۷/[nEӦMӁTTTիW+5k.]_?~?|mܸQӄ	}kZ~^rDQfyfM9eYڵkW`pWRRAAA         q1,U"4e"=r/ek볮    fд:iEOQtSnneŲ,EQϹ_zhcJN
݇NACo߾m۶ѣ''W^g @t)hϞ=7oΝ[&w~]/PvF $n!k?SnϮUvvBP    3    :#̷*//wj+]u*,,L
-))q~    Z    &[N 4cwyJӭ[N#Fht Xڙ)MiڹsgR`֭[ʪp8br)u         hȘ \{?~|N:FY  aȪ9i-#{رCI'%w         4?x @ڷo7  h)~Ch힛rp9rD7o8PZRaaaRpmIIZn][     @R    3    :#̷nEQm߾=0vݕգG'`_[     @A-   Ì     V޽;0vǎD"߹sgOPػwoegg          1x  HXY@
1|7Y_7<<1Ve˖R<x[l¤ڒiӦ  М}z}嗒M6uQSL@SONzwq/ZH999IiFj     Ho  8®eY PShFZ)amvs1m߾=)v֭ڻwoau=p  G~~^~e)lڴI6mJzŚ@գG]veF),Z(nݺiY5 )Xof   Ɓo  0;gg TpB2Ce5 ȺUc/~a`p]^u)0Pu  Tʕ+uieYg6l&NX{&ꪫTiK@=i8   o  (춦i:h4)  l
%	mjV
sskՁyfO`miitJSaaTkؖm۶u  ԬbM2EK,(}NNV\Y˵mz''d~̘1;vl-
      src1{Qɲd(~(*hY1wʲ{OoHFQe3W~r}U|C>JQOyNg^[=w^ʳ,җop!U^Vrn^'jd,S!v=wߑ!w姬!ɴO;!WSٱXx_ԧƎ}9
Ciݕʊ&BZ4 \ÐU[sZ&BeeeIڷo_B!u=pnݺ5 @
;SO߯4_: 4];vO~}{߫4mNN-[V     =f  hh4c}zp#
YLL,ݯ-<$f@ܯc@JW\/ӗ^N<v]+>`opwo>	}0n/wdp{~moo*l{ v%EЯӗdm}m1,Kx~Q_zחLi߽-WcQRH3_BM{h<_'5Q+3\˭ϾT$qfmhԴ
p+eY׾{t10P-Z  ahӦ.]/8mnݺ[oZ@6qDYF/bt3gTnV 73   @   
=ӭ;68˾wazrf|Ŗg.=ko='/FO}
t${R_WAI#WO:ÕO8eT}Ε'
:M=ϕq}m/OF\46ݫE,EQagiHuuF|׿&זusssUXX`[RRvA hƎ.@6lHfҥjӦM
 +WNS4
\^\\Yfq 5o   y-   ?V
Kˇ33?اk[$KF2MSi*
wRdvպ.]8A={6
 @òdOGMZ6f;j MWqqL%K._rrrrV    <t  М؁
1ce2ぷβxgCxVjݻwo`p|Zl¤ڒjժ  X3gy?''G˖-Z@vw詧yܸq6lX=
[C   4f0   j= כ j;?4$^ZZ>͛7TeeeںumۦwyG(:XEEE*,,UXXݻ| ǬYci֭{3gTnV tiFK._y'?I=
    dx  @#ib|3SH$۷'\uVٳ'<TXX"Ϟ]vU  1999{5j(IYpg͚UϵmرaI    0-  @#qCdϢmȐ%5 ÐUsߦb?]v)To(R=kԭ[7  4H^xƌgyF+WTNNN}W	 %K_~:5u KxS4   Ј0-  @  4ZVuzc!M#_mկ>rkKKKUVVÇgEΝk]{u Ԛy3
ҥKձcG
:qT18iƌ=zB`l   @3  42_oA1cպu뚩P
5uFZQQ[j˖-_YYvgzOwMGVTXX\[RR6mPM !ڵxYUA=pY&H
ۜ9s$c   \1-  @#Å! 5ɞ֪fhƍ5|5Yb{=Ϭ￟хp8O`_[ / -{0O0eCx~
fP(y    *f  hl@
g5dT9ה)Sj}[D-?cرC۷oWYY\}v=z4N:$SFzBZV޽{+++Sf @`b)˲	'0
GXx,wa,1t<   4x  pq@ItF5eBb>-[ҿkvjG;c8p <ڴiBgB	-//׬_*ݘ֧է	= ȊFzgWD[ߏȲLY)YطOkT+Γ6Vx<}ÊY/[]˳t'3^/otF|;)zMJоv:5R;52
}+Rjj!H=­sr;v'msD,Ki%{?&eT~uAwqWϣ'i+j<ñgun;SlwRq<N_Rz~PƄcΑm؛   @3  42_oAFt8K.D7n:D"m߾ݙ{no/%39l8_qqtIkSE"̸ Ѩ~Q)CXPX(%#c6$kW~NX\~<Mj
JZ2yx]K2[]snJ۔fψ{y/WV&ST郏ϯJ2^%WW,h1=-tҎoe9/BA\5j3ݛ}\|Roϱ\qWJO&f`~JU5ywȵ̓޿}SDrIH}r2)e6㟻Ϟ    h  $y|lٵkF-[T> 0vΝD"qr8OBի2?Mb ͖;P4M=ÈM!22If|%I=alyb9{!YZO\30OvIepgIN"?#M~G|#_"q5|!zr۲Xʌ\쇤=no,(r|#`?Xv7<UOe'3ٛI~_ndd97dxU"qoUrwy5Ku<'õE"
EN-F
*1~x"W-ޏ${yŎ8eKwȤJHQowƭzͿ^h$o=/=\a'\NlMK'~OޏWVp{W}fbjJSW&Vc; K"hԹ1[    M3  46|a
ٳhǂYR_o}[OϜ9S-ҁyfO`֭[UVVÇgTv%Z:ԢgWE򔛛, ͛{H$
a}RԟFITcɛ>*-pTS_IV,5}V5Ik]3ߎm۱Mҗ!IFF
Θ!(FXAәFEIexL׳2I_uǳ4m6zhCVw\TkGc/+d(6ahZ    3  4:|i
$fM=iVZ|0e`n>}H%%%ݻh{''=>FX eI!Bih^Z;Fv,CϣѨ,Yԩ]1AFۖ1ҾAA愦=	   0-  @#c&Sǖh4S4?<9oP~~gZyAAA~3R @]"\! ,'(
=~'|ùlHnN    Д1-  @#× j=m=pƍ?uWxk[u Ь?3ޚqw<g5!9    4x  pCddĜUBٚ5kjf)C,  (` ߉
{{uήXF'Pb$ĖCnܕCndD39nnEwB.)!rq<c̵3{`;~>{]f\|ϥ݋-NAś=ZDDDD۹\O]x-"'+ӭR~}>s	

s`/w+""Q˺I͢Hqv9!"jO"""""6DIDDD#tySD
ZWܹs9~8UMs3R
""r
I No5w0wd:x+"""Rxs或-[A4oޜ>}W_ZڴiԩS~cKPP
dt	___2Æ
sS+4Ŀ"""bIDD_o">Vt[x%u1BDDD3x
Quԡk׮ƴbĉ|>e˖QNBlHbdrx|hт-Zp1fϞM||<Ν㧟~r_CL&?ˇXɃ"ax0i@q۹>]Aa"""""6b*Tc={;n:ފ&rw1}t&N;úu
qLpPz+""yQNQQDԮ/L^ABe)bL2e`2X,N]+Wrʖ-Kv߿?F={xbO@@ :P RSSYx16mT\g}:8ՕkƦM h֬Æ
\rF}o?`6^; t҅ǳtRΝ;رci߾}m~޽;ǏgӦMӸqc^|EVZŚ5kr
8zrf̘Ν;IJJRJtܙݻ/x79|0%J^z2*Ue֬Yի9|0;３={Ҷm[O?ٳ)U]tÜ?ykdwy1ǖ@C>}
Q&$,@TDAA"""""}VDDDz촴4N>mLgddp	,YjuƼ7|Űa8rѣL>8
Kjj*s!::~Ĉ#oy]6۷ogĉ$''ӵkWu+pΝˑ#G׿޽{8p 5k4Zh}aʕ*UXիfzoO=+V;}Q^=ϟɓ'7n㥗^r_ƏѣG9r$l۶3fPLڷoƎKy ١CGa2HHH_G<˗/2~xjժEXX#,,	&9{V}F6OtADDr_E6o"!EDDDD(㭈HQ7Dmݺ[x=,,)SШQ# Xt)-Z`	 DFFR|yFEbb"=-r̞=___ ʕ+ǫʡC8u;wdԨQo ""oA 88y`gȑl۶f͚1gBCCY`Q^ztЁUV9emժ{ny睌1+Vp&L@@@ s>(}]e޽tdnL2 |wL&k~|W\r%KoѩS'b{K.$&&ƿ/L&,0]vm~ic;vrƞɄDVz+""yADx0i@qz{S["ǻ/d׫W={pq,YB
9s&!!!F?ҦM222###1ܹxgy[rGaժU|4l-Z ͚5l67_~if`j׮Ν;o~FNӥK&,,̩%Kŋ.C=DÆ
ywiܸ1i? t֍֭[Iݺuy2G %%Gr1@zz: waÆF-@ժUY1k.}F6Yn={l1;xv/HaQNogR>bBOqwd}a
Q["7CBBhܸ1]^=zAX|pzy ƌzN:ŋX,+W.g~m=v~<ʕ+GRR.\  !!Xtu%%Jȳ+ˊp7    IDAT+ٲe`D;n8>jժłXr%			XRJO3` L&Ǐgڴil߾JXXPlsrRSS>m[󻜷U7g""RȔ@Yk*"[>x+"""RXu!=àAc޼y9RJ0~x˕)S%KٳgYVnJZ

l6tR|||r1`ʕ+9?r@.]x'ssv/]nӿN<ɶmXx1ƍ3	'==}OjhѢC!##SN8y$6m2;8sLv={%Kk8MVۢ1̴h$B"ŃFH>9}΋.Fx7jԨABB?3 > f~5kJ.̙39t~~~ԪUm۶aX}w9_p2228zN8|ܷ~Ԯ={F
(UիW租~FzUҥK/oI_/Νm۶|G TP~֭[s	 .\HΝϏ
/p=JTT
402ڵ3<<={pE7rƞHd~2 !VDDrトh(uwsxie)rty3;һwoNҥK	gϞ,[t7n̅Xd	W\f͚ `Ȑ!tܙK.oPn]~лwoUƯU*U2oЭ[7>Lll,4n!CСCܹ3$$${nvzKʕ~	Zj̝;tVʡCX~== 3zh:v@BB<#R|y>cwfҥ $''УG֭[ѣ,Ybd}]nt9oc-"^MpPzv/HaQNq7Q(V[P0yEDDDDl\ɒG(Y)<@TTׯgÆ
DEEѿnv

"<<@DDseѢE;ҥKӬY3
l<{l.\{Ǚ3g

婧_~Nm֭+QQQ(Q֭[mFDD`/^1FkÆ
oY_/,X˗sYBCC_?97..e˖1n8233Y&,; ..8Ǝ?wu'Ofɒ%$&&sqpBf̘K/Dҥ֭9v`vu8M֘cHED0)'or=pMj*󮛨onEDDDD֬3!łb!##TRRRʭ~ԽL⢲VaZX,dffNJJ
?I ZlZZ/fܴ={ADDZZZ?8O=,yfpWƺy
`6d2y2#2H斩p;V+Nc-5|ٿ<[#""Frr2dT-o+X]?<}k%KgϞ4mڴ8v:ubҤInM61n8>c*VrM6%%%5*VH6mݻqÜdIMM;'*TQfÆ
8޽{t'Ndڵ,SL6oڴiC˖-=zMf}lN`;	___|||<;دH%j!%ħ덍e͚5<0 /Zu<x]2sL~a֬YCll,7n,<;^))onR逕	,4Fzuyi|CRH5+x(""""^KoEDDD]b_%..~pe}СCa7+3>0mXɍ;!!!%DHJJ7ÇgԫW+-jԨAv鴴4Yx1N"&&[J(	ݻ7'OfΜ9NϜ9C\\u1އ7M6s='|vjWQŃRRRϹ{Yf
}qS]رc[Ϯ|DDD7mʾܘsjEDDDD ?QDDDCBO?4ɬ_x[.TTƘc){ADD
;r)Sݻ;sѶm[>:Zjٳ'CaݺuDGGStBj]6=˗/gDEELBZZ*R_FhԨ1?rh2FXYݴ3f}a˖-j-u"22B_;8yEظ,,x.oJ1b2ٳ'Wf3f{-y[z~Fٛ/""V$(Y$%KtȘ¼yԩ4k֌?:-{	ƎK˖-yG߿2v"##2۷4mڔ͛3vXN:e_f
͛7믿;k׎Kbu~ɢEh׮M4aĈ\p
#<<zAdffrI>Lxx8k׮'iӦlذ?ڶmKƍի۷owZWJJ
f͢}4i҄]qmVXV/^Lǎ]v\r(s
Diڴ)?|,k֬giӦ4n8G[׏ﾛ8Μ9ٕm0` >(͛7gȑ>|X	/tZɓyǯϺxh޼9͛7祗^ٳNe_
Uo	w]SYf
u֥nݺԨQիW;뭷xW h۶-SNe˖̚5˩MرcNָ[{9}4O&<<<iii ݻӼys"""bdffmӦ
-O>DFFkW)-[dϞ=tڕH:vƍ۷/M4'dy֓Wߦ2w\K.]i٘j*ڷoOdd$=z/K.4i҄gy~ihϟO6mx߿??]9dzjZlG}Diժ12޹nEDDDDx"""""RmgE#񯈈w|ĉ8qǏsMFRR]v5ʽˬ^̙3ÇsQƌcќ;w=z~F)SZ8Ǐ{ʔ)l޼ӧKIOO'66cråKe\ԩS۷/Wcǎ,\͛7e^uСSNL2̘1é
eʔG1?oġC Xԩ^z8qg}3yd/ lXÆ
>[n̜9ucl+b
VXwϟO^Xv-ӧO7nL&&O	dذa $$$KF>}:'NTR?)/m͍?&Lʕ+̚5K.1}t6mJΝغu+}Ϗ_~QFq!ze[_W^yhK^xcۂŃ;=z}Yx	O2h  .]J>}\^~ƅܔ-[wy߄	0Lt8'6685jD|||+VPreFţ>k~6/]Dll,Æ
cժUTX	&0rH~i~mz!&Nx[ZVFʕ+ر#f͢qL8UV9-W_uVf̘%K?4hK.eܸq%/r;v 11*~ӷo_N8'//_fҥ<]RJ4?`sx%!"""tC {'z4bED$78>=z'|2{VZ-[牎6$Q^ɓTT{/|r*U@:uxgػw/u59s&֭cڴi4ix}Μ9` W:t`ժUFba4oeT裏غu+Z|ٓ 4mڔϳm68*%%d[_~Ɇ
hѢJ jՊ޽{e'MDJJ
V"44Gy={2k,Zjŷ~˞={xWi׮ 
6ɓ޽-[?u]~QܹstڕƍPF
㍌:ubȐ!6s=t҅D@ۚ5kңGGFF111ٳgSzufϞmd[cǎ,^W_}ե̛7r1rHmFf\~}M,Ln?ciݺ5 ?8fbՌ9l`*WLHHϸLՍ3g0b|AF
]6SN&M_w^:t`,3~x|}}fff&C!""ݻk.:t`ذa?+WQWn}}vvɨQ5oA ==ɓ'c=[oŴiӌgnݘ0aO6%66
* 0n8VX1cx7{KFF0]ǂe;W8f-""""bz~}'"E2B{nٽ ""9	*T`dYV._Lbb"\pcRD	-Z9vG1XHLLzF-@RXf
f<4m({Oc6 lAkfΝNӶmZsdAlӦSm~lٲ-[x=<<1c8m~-FڵkǴiٻw/ -ZpZwWA̜9={n߾ww¸qhݺ54jԈÇuڃRRR8z(ǎ3gymۗm۶w^Njӧ9z(Cu
H		!22o:ܡEF@f0|7}{hT<|_͛cZr
f&M~z'55#F ̎;ұcG2228rǎ䨣zcJ2e VZɒ%x۹k.vUVӰaC ʗ/oՆRJ{5n]o\9Hl/i~cڎ!Jt,Q["Ƥ˛"R[tF*""9	n6#k]TT~~~^gy0fϞ?se˖uZ/n|'t*p`{yBBB*V4]DeoOJJp
b^ztݘJ*NOv~tRRR%]tgpӽ{wJ,̂7o*T`Сnݚ -[ٶmk֬חG}qǙ6m۷ojf_Y]ϾGxx8t
o[^}@7wȾ>>>+W|ooV,SToӧOOsߴiMgϸp=*dٲe+Wx=553g~zRRR

N:|=lvm9M9<57SN]~Wڐ8Pti8Z>~,X
""""E{/g|*OEADDrq+רQ/@zXr%w}7f
6sNc Ν;c]{!88st҅W_}_@.]x'sǞ3g8ۃnwܑ#H9/#_tiΜ9ӧ[{HNN&%%)$%%ddt;w$>>z!BCC\2111XV~>3VXApp0FbȐ!ddd0|ԩC@@ 'OdӦMa[וTzcϺ\S\}ߺV_vZʗ/ϤIr̋a5L,X,|ײxb6mĔ)S^Ӽ_O?c	՟ͼ`6Yt)>>>9D`~nSfW?8ƻڧG#xgyQg
Q"RN6mjÎ; $--^zQZ5f[#- uz._ȑ#201c駟x#WO?D5Y&5k֤Zj,]/׫W__a[lgzg#	lw~)+VB
<C1..s?祗^l}ڪU+zMff&N⫯y9rDj<x0UV?̙3=z(4h`;n

;dӦMN?{,|
~	LZZwY׷~4ghРAo]CA۝?6mPnڷor
 -Yg`5.|,^}ҪUK:ux'`'N{՟Mٷdddpy5kr	ϟ˗o_~Çػw/kWڧGAD{ZDDDDFoEDDD]ֳS.gwĪ\p+Wڵ;wҦM*WLFF>>>,____V+|	6l  99]vZL߾}x1t҅t6mJ-Xx1-Z ,,!CСCܹ3$$${nvv-[=zob6_>;vz!̙CxGoW^l޼~SdI֬Y?)S hԨ^ٳu]f̚5dܹqsy,YB*UV0zhzE2eرcGR|y>j֬Ipp0wfҥ@.hCaԨQƶ%''l2|}}ӧ *T{eٲe(QRJcXȘu}t֍ÇKxx876^3)c1QOؼy3<cΏbٲe^^zZO-cT^m۶9ĸp&L@511f͚ԪU͛7s}q!.\j}6m?LwTV_RV-*UT FGG3` |||Xd	Kg\;+}ZuVJ1 """"bzNDDDD<BJ)"E
hYn?#B掜gΜaƌƴ?+Vo߾U2i$/^)]4kfٲe׏DjժEhh(̞=^{
<EPǎQQoeDDD`/^1TVsҰa|m			Zx1c0aLRR_}׿tQJx77o:ԨQs	2`Κ5K.q]w1c6m
R<svZV\I@@ DGGc6	

b̟?iӦqeTBLL۷lYv;v,u]L<%Ks=W}裏2k,.]ʋ/H@@ Qreɓ>}:qqqѩS'7o;３:]]Wn_Dnݚh#eAoͪDA^SϨR
5ju~XX> 6mbذa4lؐƍr߿?.]bժUX,5k+ Al5nz\طo(ha     IDATO?9s0rHV+g&--J*SNa222뮸uMv,\{3gSO=E~
λ.]0k,RRRhذ!/kǟpO]ُ[>&mBFF0|[{Ee""""^jbX$==~:LQ`ٴ2_͔bjc7h8`בqe@@@ f___L&G/.E#eGXHƖp;V+Nc-5|ٿ<[#""Frr2dT-o+vE}lN`;	___|||<;دH%j!%ħ)EXLL?3			F.XI-ANc\W7$]3	""""\;EDDD<.^|G̟?ߘᩧ*<L<e&OLTT-jQeT$iLh<A0P<( L.C{ZDDDD[])oٲe$%%ժU㡇*swZ$1[LpPzv/HaQN0P<(8P%o=-""""bcv.x"R{P8qbM[tF*""I$"R45蚊n1wd:겈GBv8qse׮]dddpM͚5[?_w}GRT)Zh)U 111$''RJ@9u۷^{F)))nݚnݺ1p@ ֮]ʕ+9re˖]v ƎKFFe˖eÆ
y睬\_~9s?AӧF}k֬a>|wIϞ=i۶- M6%%%??/ӧ~>c͚5̚5I&`:Dpp0;wW~_|s1ck,;wbоgOtADDr"bMTDA#xKbg
Q7ܹsу3bLje?~ٳg+P^=N3<Æ
0` ƺoζmۘ4iV",,1crwРA6mT֭[INN]v L8￟3gҳgO}#Ա2zhvJJJ
d21ydON`` Æ
 !!X5jә8q"Jb;vwyPZnի	

gǕ+W:u*}etؑy_0;w/֯_,OE'{M5ĊHnt|e-sCJAD{ZDDDDFoEDDD]޼Y/^dTT	:u3ϰw^|}}Yr%ݻwg 4i҄U2l0>:t @ff&ӧOlٲ :-[_ӱcGڷo/Nʕظq#jբjժ$%%tRZh	 |5Dz! RSSyרP ?#Νk׮4n5jOZZ :ubȐ!s=t҅D¨R
f VN<rX,Nׯ}[nUV72o<""">)7'+ӭg-\r),I LXLI"`/L^A"""""6x+"""R+11իA Jb͚5<۷B۶mkڴ)eʔo5^XtP\9 RRR hѢlܸ.cڷoRSSiӦ
ƿHf3;w4]lY#&$$q_|/Ç`ь7~g6oZ tHH.ՕD[ 5kv,*fԳ7_DD
rx;2"
""""EUo_$0]HH/^4[iX e˖lڴ>}_ ЦM- cƌɵ-N2

ueX|9۶mc͚5裏2n88~8ӦMcXVXWK%J(w3ۤ$s?d-cLF_)$
."x[<蚊;hz.Fxuӂ8w\Cpp0K̙3/_ީ̟IZU_Y~=dƍ4iȒ[T) Ə}ݗc2er+W&&&/g}Ɗ+fԨQ2ϟO:uɓlڴtWٲe9{lArsLWL&k "ΫEf0korI]֭ˁ?._ȑ#O[.>>>lܸi/R~|N
طo۷7=f~7j֬i+]43gСCyy9rDj<x0UV?̙3=z(4h@@@  v3#4h@jj*[l1^믿vkZDR
=7^¢"ax(*O)Z
j""""""6x+"""RĘtyuڕk2x`molK.TP~+WbXȑ#,^5jЦM|g2h۶-+V ((~ؘLϞ=Yl4nܘ.d\B͚5\>H@@ GW^)S;vp!zAhh(˗O>f͚{n.]
@rr vMBBQQQNtWfͨ[.&L`TPΞ=kd5xآ3R)L%YGTDߑEDDDDx""""!P={6&xEQB F_>V^Mr刊Ψ(/_N6ms׿nv

"<<:?>gڴi\|*UcdՍ#..c]wɓYd	<s <L4ٳgSNut䇏gfΜ9,YTZlI׮]sdg|R槫
""}4m"!EDDDDW,RSSIIIa"+Q_f[EDDDjbIzz:)))t$ Ҵ`G&edekl=y_:7NJffӹxo~w:FǇ4V&?
>z\a7QD
Ig{Hzl4 ۧPN,6k*<%%u;x~v	Lr%ħ)RlK_ xK9r]An^'p]3	""""\/""""B#DdeŔ_ٽ ""E	E|kѓ>Dߑ咺,"""L)ET||<-GFnAn]@rgo2Œx;uQAѦk*"`"""""u\e`Յl)׿Ҷm+WNq2wmgJa&""נ"b]TAѦk*"RDDDDD2ފ5!J 
=dr{Xɍ"ax0i@q۹>]f-""""|\.""""CDT&zC{M=DD('h(mʓ>Dڽ끷,"""L)"(kLEg""r9(DDÀ">{yHd2~GV x%u$"""!JD
=2?]nz&+v9'r>Ntui{vkYzrl屼zԸZ_P_v:~ɣW}W`۴Cde6pz:7fl؏jWnm{z8Ntk*[S.ZnKum4A.YZ7SWWyv=seZ.qnvdV_3?doE*CDDD3ⵈ {'O̽+"ݲ٧OnGK[j	4`cemTZ볗}}VLVrkZg2}mYۂӴcVOt~5_=֯{_:sܯ,o9l)|c}??W˵z#o"ľ|||g&%ecm?/딳Og>u]8ԞlYlwV9m\걏iwy^yG\iwXW]~^si_|uY7x9KIDDDC8)2zb/w^[,kjYfd:fdz\5ab&XZ||#Y/cQ9zZg+`2^?J^cWCyLYCycŦlɩ|V;sg׫;5G:rjrOmŕɾ_WYxSSyɘorηO.{y{;ȹ]{>~^L>>
,+otLZsONv'Lg|m9sޞvwr3.<ڝaϡc{!lvl1;y\؏8nim)&[{W8jhqyz}FَYsrkOVMO}qXYho(㭈HcM)@\Dn?#[1Hח:g\tbɴv4LyQ&ك\ɟ`uxD往cʗ_~ɻˁexMuFŊJKkC^er_1V]0ɳ,Y»ﾋ	+s̡v'']XO~>p*~#郬`5iKޫ1hl*s9-{v:dd
y_Wo|XcƩOwcw[ꫯn:Ju[s߶'X6?c.Л.+Q_ngk3ミ_@\oEDDDDDoub$"""!JD
h-n;3f_DDcVH?J&#Hb\%@ZZ|-~3^/U>,}%$$[X43w׽xٰaCa7I1l6*S`~#EPI?k(0ď \ҥKr$7O	٬[
x+"""R袵 	{YaV!""^,{}l6;i._L||<-ԩSwqW^b@FELLٸq#:u*fke
*\&	xkk;00BlZc_"""""NoEDDD($"ZDRUw<DDĝZ"-łj5cӧ3g$%%s=:ݻ;Bŋ9z(&MK.vZX`x.ǀ@ >cd%(H^r#GݠP<i(㭈HcM)@Ycg-:#[1K=+U:D\\oiiigȑtQA37ߟI&rQ/_ΠA
Y"gq1n9K7FWx+"""R!)HVڨDDc=mqȔ)Su֌5-Zb늟nݺ1cO>,Y%[<i(czqkm6q3io""""E.ZHg5a*"1mXǠ?gʔ)6^+/"u)osΥiӦ;wS[MPo}<w|M<W`7L5VDDD)q"R4deŔ_ٽ ""8X,}NJbbz`` ={dTR[4iBٰa3f`Сq,Qso=kЧQDDDD[DVDDDPYZtySD
PVOAg"""7%557x]A7cǎ`B3fǇbbb
9"""""""""r\_EDDDc U7DH2FSάBm*EDD\ɓ;8p RJKHHH!TV^zl2~Bn
ҳ`+,8֫Ah[q(r,gu.oZ^sw܆\g>yseo_91 Ϛ}O7ڒr7ٶW޾}{!0qۗzf/WaH&V7GzꦋɓL>ŋsE￟QF3W-ɓ';?O֬YSMqKS"""""^[("""R(rbfb XoY19nbrسZ1lcˤ{y->`ϚΚoʶ#`1VLNVyg㣨g7r\V  ֪XxE=Z/-T**(`Z8+!$̲dBv|<ݹgf7_;,J|4c6l<Ȱ~_{/̆wٖP
7>2þVȾow3C7K>k[lW-d8qtk}ף}y[N 믿&sz2DwyƎǷE?A˗/ƍug:,  &qD	   xP   &ݶOs'r2n2eCT4T'
SJ]N꘦|6d40SCUAMS'u繩jG[
4۩~\*+Xv#O_|ju9xu5h_nkmŀmO@ܡ>GBoϑ?Ea0nx_
niȐ5tѐ|H yf=Z|L04j(y6lX#D8w},Xhԩb       x  |nN:'i:ֺT__/!	77HHTsϛ|c&k:#fsc%))IIIIr$'+))IΆ6_ @Xjf͚qIIIꪫt=O>1vdddׯkmٲE.X      *  !0<.oN7prryE68Gx[Ju:ޤxt,]n6 s\Zhf͚O?;>==]7x~ߩK.1u7Ν;u]wiܸqr:      <*  9ʓVUz Ioo|FW@
 75g}wyyy:u~_+'''h9N͚5KW^ymۦ~Zկb  @Xu   *  )ߤ7+p%&޶k. ^Vpgkzz?
 ]_)    IDAT$T?x	xwM~&O
VW\Yfi˖-4qDedd:,       -  @ߜNL&đxXáGx[ַm<%ZTf3  1GgUUU߯_?M>]&LayiС*..֜9s__	      @#x   p8H@B5q0dF936^7 mݺU?^z%{6L3fШQb֘1cohoK[  LA   D[  G-+n(aH
7F7^ZW ~z͚5KVc{c!ʕ+UUUE[  ,   }T  H@(ر#a}A@ К7xCfƍ㓓u5։'q[7p~i͞=[zrssc      b=    # Ezu)hܸqޤog}6ꡇRvTUUE[       O-     7S @4:tH=N8]wu/%Iz衇k.͙3G;vqBqhΝ
       o    q* {U.]Vv$Cӟk̙ʊq3fPFF\.Op   1    xP    #  ;r-***C=RIRK/i2eRSSc)MFFNIҒ%Ke˖G       o    	#j=S3 _h	ٳ?Ò#Fhڲe*9Oˢ~BIԩSc
      @T    $ÐX9 wyG#G)Erp/ז-[vZ]xᅱ	]vz%I7nԊ+b     o    qϐnnߔH  L+{+JRjj&O۷kɒ%߿#E"ջwoIo[G  2   @-     # ċZ-\P't.r,ySOG1p$m۶M?|l      E[     ,d ¨ٳս{wM<Y۶m$uIfҮ]?Q1ѣugKK1      D[    @Bnߔ{N ۧ3fK.;{nIR^SOiΝ>}ڷoH͛7O[s΍q4  #c    -     !^E  oF7t4k,K
Kj֭<yRRRb)Z38C&L$=#:p@#  m   o    q/=R |~h[SS#In:_OS*1#H<ٳg8       T    $L̀g @fwy:3tRn9N]uUϵzj
><a
֭~_K|I8"      m-     1(gr) -n[/g.H֭$o֎;K/o߾1mӕJ͟??  6       gH
7Fo$ hjjj4|KW]u>CIRNNfΜ~AO>uH?^&L$͝;W1  Ed    T    =z H(//?]o7|#Iҥ̙]v顇R^^^#͜9SaX>l      ,*    `! Z={;P.]t=Xt'ӷ~o]1O>=z$ir1      hx    H r) ._~:uIsQee$3Բe_hҤIJJJq=3f̐$}ZdI  m
   o    q* N/ֹ瞫}矗$ѣG6mڤq6P(:T
$q4  !c    -     EGʕ# Hx?uUW]u}]IRRR&N/R+Vаab)2{$O>њ5kb
      
5*    b,j=S3 Lի5|\R.;SN<yn&u9QXWEEEÈC?hŊ
$ADvU^^0"&==]Ç$UVVv8ȡ]   ~ώ    X2QΌS H3<?ڱcߴ#Fhʔ)KIli>o&aDm}ڷ%zXD]kk:uG}TgϞGYKHt    @-     R
r) ķM6izU]]kVrz  ֋       G ڮÇ/ϟ?oڀ4e]}JKKQ            XpAZlz-UUUy+Ԕ)S4xF	       hx    H r) ݻ+hٲezwU__7W^կ~믿^1   hLI:   x    H FW- pl}Zl-[͛7M?餓4~x?^
A@3MS$- q   xP    # ijƍdۯ:hzmO>D`׮]z;NeddGKթSDuuuzWu'jQ~NٳO~#Z͜93táKNO\sͱ
k*))X{n
<8     o    	#j=S3 1uuuZf/__]{t:5l0?^]vtH
:T'tw^v7PZZZ#<zZnN8XbK.]4dȐrrrq4@կ_?vp8Ν;˰VZSN9%&nTWYYY    x    H!3ʙs
 -sN{ǖ-[T]]7Ojj.?^^zrssc-ZnݺTعsgOdxϏu@w'6vhWVV~: G        `H
7Fo- <ڴi7_CۡC5JǏѣq̔$>'jkkb
*//WAA.s9y{ڹs\.4zho
6hŚ8qx
@FҠA˩ћo>@P^^
?_FùJ-YD_|:|<;w#<"IzgojϞ=2MS9rd	۷o׊+4MG^z:u$Iڵk|Ar-я~}_}駚5kQ={ĉj*UTTꫯVmm/_W^wܡ;֭[{*--M׸q㔞x;T~t5hÆ
zWuM7iڻwrrr4vXuI/Ν;K.$ljvKNZ_^ׯל9sK/r}ڴi
u=phÆ
Zvݫ3رc]gSm^qq^zZno߮Ts9/?Vrr/\nAֆ
tRp
Z|vޭL
6LFZt>S\.~ҥ-['|2*pl1    xP    @\.}G~I[nK\գGuY2d:,~JJ:Ç;\WW~AK.UFFN>dIk۶m5jN8}gzU[[#FZ?t7pO<*,,I}W4yduU6lp84` {n]r%ر-]TUW]%IzgU\\+R㏵deddh6mΝ/\~$wѢEtEi:|֭[g}Vݻw裏>҂Էo_]{:||M͞=[w}


ZY֪$:(%%;/kȑr:ݻ>3UWWkʕ?~*++ձcG+z5b7N{ъ+j-HDUUU!rrrt:CzuW+77W/yh:[o^PϞ=ö%[C̙3cW^3f$I}Лoe˖iȐ!˵w^-[LŚ2ey<.rM0A6l[o7j5j>S-]TEEEakjjh"g?M6_Wǎ5` \.=:pƍ,]V|    x    _ m\UUvء;vo{TWW}4h7ώHR^{5qC=zЕW^:H>s}+5bIR߾}e/_CjϞ=Ј#tꩧJoo_~N<DI҈#_7Ѐe}2e7a_~r:$Bm߾]?O4p@IR>}Ԯ];o^)))޿,={hذa˼tYo6YW_UQQNطo_{z7"fΜr/K
0;<` 5o˥qy߯kW\!ɳ;v'xB6mR>}Z7h֬Y5kG=n[ǏW߾}%I+}6hܸqڴiv-iݒ;t*--M;vN'OWUU+W4i$SNQNN,X۷W^j<LoѣGkܹرkǎaon~y1chÆ
5` }5m4z>@         ݾ)hLݻ	ɵŶs'U=Vbi:Sevء5k3s
_}$iРA~Iv֭[oF={TpB
8P}'Me%ZzO>DڶmRSS[:KomۦBtI}SN)c6&L.w^kl)//޽{ӟԛt+yzm۶5Nz衋.(ݻ
w5|w!9yK~Dsg3o%ӭ[7댌I,ڵ䩎Ѵ[VlI|}t/P^n_jjƶO
n:t蠚IK|KRRRk6D`J	   @[    @0Bn9vܩ}i߾}*..־}{nm߾];vз~f-3##C
g3<SCU^^^ N:y`맂r88qwJIwr9eeeJII~;^Z|6l ákQzz$)99+JUUUJ%Ijfm޼Y}$N5\.]s߾}Zx>s°I*&
J6DӹsgkZ_7(q4eKO=TiRSS5w$)%%%hPRACS@"c    -     EGʕ# q\%%%r:DZdPVZskN]vUս{wu{ܹsCzfMNKOOw!|IRaa&N(4k.m޼Yk֬Qffb]]>|[ZZ*ITFF<+̪Jٮ];;Vcǎ'hŊzgt}vk޼yr\o~=z(%%EvX5ݪvFx+~2%O܁UtD_s-K߼~N81dnFFQyє[A4    h-     aDgj<@UTTؿuuu[ZZ_2m`bmǎ#. \y/h"W)))ݻ֮]*;|?[=31c:v쨢"O>ֱyf
6L͛ս{wwZ~>#$wުЃ>1chذaõgmܸQRpw^]r%:餓+odee￯.܃/dU
޺:ر={p__~Cw1h[BgϞr:ڳg9b|Tm^4[֭֭[էOI    փ    `2= RQQa+qummmk:t蠜}5ΪV	#77WGkUVK/Տ~#[<.bx
u]PJJz)9R۷?ֱdUWWPׯמ={4m4IҀvZ=sKԱcG}Zn=\It^{Mرvޭ4h$O^I?)45x`Sվ}{mݺU+W$Ԅ'Ǐׂ4o<?VMMVZ%áѣGKtkժUJNNVZZ}]j}۷ON>|x𕗗s=Wk׮i۷ݫ+Vk׮8p`e233l$OW_wѐ!C.kȑZju)J+WTuuu=.:6/ZN?tu]O?Ǝ:h*..< `
   $*    !5ݾ)mU60qڷo_дݻwG<;Nyyy>


|uYQAAA
e6nܨ5khȐ!:4uTzwtAeee?.Id7Zl/^jwq8qbPص^7xC%%%ڵM~t:5m4-[LoTPP+/n˵zjo<?O4fIj#GԺuk.
<XSLђ%KO+))I:uҍ7ި+W믿E]r_zV\z O2ůxb-YDiii6lN?Fj-vҒ%KNjiW\\_^:t!Ch̘1JNNn LS$5J_+Ga5vXeee(==]}Ѹq㔕%IGEa[/W_i:34tP}4 Z    <VnnUSSjgnNԇO2V    6K_OYf:*&Wr}Ԯ];%%%t0[$O\.]ϺߒuRW|/lUd%$om`"ma+i@dUTTh۶m1Y
/jΜ9T={Tvvv J_}Uhvޭ~ApOСC>}:Ztpݒ8^ڵSrrNs3   @-     JqСCg}#$oY$P   mzggiРAr8O駟ꗿe    D[    Xnߔ{N;t
#IN/N"-I   h"tMZz.\(ۭ.]hʔ):c5    IDAT$N    T    $ #īhSq555*..nV"Ç#~+NZ$Z~r9sΉu ߿0g   xP    #ڠZ۪@k
:t(bw8JvisrrH        1E[    @ZxLmmg5\UU;ت@k
D        o    0dF93@ă:$Z;NζUzpD, heee:Yb\.N;4u=TJJJC V͛%IGVR˙.555! -b
   $*    !5ݾ)"Ҭ$Z;hו[aɱUzK-O<1as=O>D??XHIIiUޖ-[twHnVT$:2    *    =Răzo%Z[aJviH6CG      NT    BoQ__o5|0eee٪@;L- )Vmiii#      Z'*    Hts\._DH&JKHt:#  ?N-  4SN    *    U4piYIv*Z#CVV
փ$Z @*ޖ8  ڐ1    xP    #QT\.oDr<ѡChIIO  o[*      A[    @ZxF,k',I+婠$Z @C-      ]T    $ÐضrϩցlUNm߾
$ `SVV$,Ƒ  ?   HT    $ Cj!4}DJSz]ZZ$Z;h}h#~  pU񶼼<Ƒ  ֆ       {	uuu^x!(]ozzzq.]Dt  e[ۭro\       A[     ,Q5MS*Zn$ڦ*ZÅJIIV XM---%      0*    Htv9=p@׾}-վ}{rN-((Pjjj
  KffuYYY#  )r]    o    	*ʴ{n_"TYm̩X{\3--/AGaaw @t:b	  hm    <x    {vzeeea+І޿PnIwlWJJJP٦v          񃊷    S^^(i*//Wii߯hoJ
9}B$:Df         $*    *M-ϛ\a,\Cj߾|3[/ˉ      hLI   x    hJ}]WWf&Snܡ@|Wu8!e\.USSj%     F    A[    h***lWkkk[޴h=
U}U{MzqԮ];%%%t00
          ʨx    @ee
ÑHMIIQ^^^i#Q=          A[    3UUUg}kjjZ^өf%v![r)     @h$N    T   ]zD"0egg7+6''GF[N     BϳF   G[    СC+Z#f%pDd =R             ڤ7+YwZZZhd֚Egj<         @T   jjjo>[hCEd)))kV"mzzzD(gr)     @h    @m3I%>  Fjkkh$F*t*77YI:tȺ8Cj!4(      B   Ad%&ݒ RB%ܒ 񩤤D'|JJJ3{l͞=;hqlٲh'ISqq
몪0egg7+6''=   -҄	g!?s4iR ~otqNS6m     m1M/; \dF4M  Gu]׬effj޼y^_]]DfD/;  UW]zJN7|pnąK-֭[o[    @LQ6&ٺn[ -e5ɷ &M'|R7ox@:uݻmU+**"wZZZhd,w  @"?N;4ؚ?55UϏrT `&1{CE1* 1%q   mM]V|SI5Mncz<xMX݆|
=ZnC\n65!}'xgWjMدGyzmz}7&j9Q}>Ol>>)wY0`G>5z!9m/>Er:$@{'4tP\&MNNֽޫn-bOIIQ^^^i#~
FW   G3fh-3fP>} 7|p]yZx}QG9* p   mv[__%k2d%2B)qG#gy~aLa
Ɂ
>6yd{SKx4coo۟
OO\>zoRϱEsgsGs_M|Ά^omdrɔ[˖qbg}  ݻw<[WW'IzTRRҬJuuu*QSNNNiYYY-NH9  	O鮻:FQ}>VZÇkҤI&(     Ac%޺\.]nIv)'Qdet7{*UJjHғ'g>UqV
6a~;2!P2aa}q?Ɍ=^$/hǛT07oL\or]_!C
Z	~~a!g;s
L
9_;rYnwzޤZO89V/ @\.DPK.DC[o   RSS5w\]|ō+55E hyRSS5c     Q6Vu\rnI?1Yd:< yJȐrr)))ɛt ػwoi#D|ydꔟ髯ܹsC???_~!?ǈf2K9  HD#GԸq|ǍK/G M:U?m޼9iӦO>8* LA   Dۄxk=}@b4Tv=&@vmW-j
PNN7y76pnnzw?$"YU}y  ͛uT{ff͛ ө묳ΒVTT3g(2     <x@VpkALRPҭi8f%6'IM&7'h̟?_vjjjI&Em@  q~PQQQ oQ?̌QT     mL1M 0n sn[U.--H
D{43f#c a  H`SNՂuVIԩSc CW^QII$iܸqKc     x	%DR41MO[tUe7n"miinQ0eee٪@k
tFpc箻ҢEuVz8p`C"(%s
  u݈#$y~s 
zGuu)33S͋uH |W   Q6	q "Ǔϩ R[hGKh%yhHۖ/.jܹ/|0 ax
  @>|Zk H4&M//PEEE   TMdT̆VvhnJKK&&>p@`gff8*hh[.B[h51Bj\k# 8* :N|={$EӖ9~iuܙva   xȨx 
hقvH$iVZ$ږ^8<8dEӻwo]+d]Hjf3  kXqψ_K%r|O[֭$14.TO    񉊷 4x+N"Urh۷&&%*//OGD[__ߢ80pxǵ	ʮ +Q4Mna õ%4 8V[p8Ri<ʶ    TMdTd~N T^^dl`%ږ&oޯk+q6''G礤f]r\-N`%a<!  Mpt}cm	 VMNӯAW   *&2*S&
Јr[h}_46##Û8Hj@ArTVQsntz>U
;lȔ!Sdrjo0%<=ˑL93ò̆q>M-\G	gOwdeH!ͯ3F9̾'j|&bG}m:Rc>/Ð!S3OR<TG
 Xrz#ב;PǬA\v[cM!9^{|fx5~i~-/ngM7CO7{?&Cxd_>%ΟHO޷Ֆjݿr}N[[^zky־[
<Osϣ?(ƀY
د6c>}ϧ,L>瑘	6B۔}C_ϣ)j|vvc߭GC#a(鞫{P    ̴
 r7[8x
UWWעufdd48;\PPmŮz}sGrh6$a]>2ݺv7n~Gw71Hvƶo8h!5o-6;boY?r163G=0鳝ְvɐn0l{+8N!8 ˪JY__ںK>/q|W6:=3~yǧ/J79r8}C|M>q60/b6:*=p߃g3ְx>c<vؖ9`KQ6E~I	lA|?,kk=}pӭ
9m570'x_؍;g{ 9(kȷ|F
vMo؟޸\Ow|^O;ks

e6L7MO;0L;՞V?	    ̰4oY'H0*46==VZk0IG#j$0tѠd[EC~+6aM~{\!$ʇzvaoAfA~3x?ﯣ[:'~ӎbg4gW&6_Dav|/N[	^ݛeYڶqA)(mb `C`rK28ƞ.tED5}VSǁMyFCRN\?kOa;01/TFW?޹f\zk9lK<7**ps'FTaM7>	kkyC'!>kྼ_vcNop>L}cل|OLY?FϦbjw;v{k#Ьf{MSxM<G|ϑ zL~   @EDf9Q -I	bVpmmm֙f5\XXmaUz.vSCԤtŹ=@[u2#歿*Z >ds'wuomЀVrrv{$~-9@KMU?Lґ6&))ɛn^GU   ̰ 3R+ZkjjZv٪@;-OE;J3n[Ctm| jS
LVyq)Te  HPJ7 o[KmyO[Qzxw   @Q6Q@p>UUUٮ@kDY֞D	E/5@R+ oWԚ+3  H:49H LlGCp@X365ݸ     Q6Q@&oۊCJn:SSSmW^gddDhIh*>Vm#I?܈  -<	1
hC|zN_Ֆx9iR Dđ8V(   xP6Q@x9u~f%>|EKII]n߾}G+tor4kIUÑ1v(  M;g x ZƺѦnJ1o    TtꩧF$V~I}mzSRRe$fffF`*	mh  134& "'3    hP6񊷋/֣>4J;st-ĤҥK?Qߔ}_aÆ;mܸQ+V8Ey睧1chڴi%q7[{L***"Yq\~fC%&VUUxɶ+Zh6~
HTmuV  B  "hL DNKg    @KP6QV4m4x+++e-YDwܹsc]|8pz0$5߻w~_h͚5+.8p dliiݫ}y_,ԩ7az.((Pnn4tP++++E`	xnkbq)  ai Ͽ 28L3R   /*&6^r9{~~ӟp7TIIc\yc'yN֬Y_ڻwo⊴jUݿ#ڦcQmɡP̀*^ 3 _ h#3p~   TMdTmTnn$v{ٳGO<6nܨ|ɚ:uN;4<Z`~mH&Mȑ#|G?>s%%%iȐ!TXX￯gyF}v믿^]t<˗/_W}w֨Q_J)))Kʕ+յkW.XGmݦo[.M0A7|.b
6Lw}$T=On[]vO?뫯i8pn֠覜wy3fMzj͜9StR͟?_zWIIIZpuWw߭9sȌ*..n4q60:"n߾}h"n R	mVz3նv'  GuT    IDAT@DИ #3    آm"$L%%%J{ZdN?wqQU_wE4EsI-PLT,L--탊c傊Jh~ɴ.ci)1e,pg|<XfvwΜsϹ/
MKKÐ!C  ǏGժUk.cƍh޼9DQ?cšCVN:!))	#GDӦMpBdeeaeQ)͛0bϞ=5k*U_~ e]ݻwqu]7neˤ?~6mDQ
gy[FbblѣGct,rrr0bܻwcǎE*U_ŋJxQL<ڵÜ9sClڴ	C֭[SkÇѣG#===\(9!f~
}s}NBdddeە+Wi l :QY%2-Qo
V\9wm"&Dd?DDDDDDŋo2F WBt&M۶mRRR_ A!**
8wΞ=KU۴id9s:uի>  ">>^#FҶh@LL:v숹s ڵk5j`ʔ)8<Zj ŋQfM9s͛@ׄ4kbCʕ+BPPPii\j7nUV/r 

B=a̟?j0p{Qr GݶmF͚MKKy HEox x`B4MDt390mYƈ <3qaL8zwi4l
4@NN~edee!))	 бcGٲ GŋxhTZ͛7ɓ'eoCBBdԩ֭[?йsgYzڵkF'OJo===tkH%K0ܿ'Nĉ-yJn
N8 ]hԩ7n`ܸqҠ[ Bv
X&Ml_9PB{'|9r$mVz}Y$''%M^^^BQZ5x{{KH)F%*[34 (+Wl6م`gPqaMDDDDǈe# 
̙ŋbŊڵ4_zz:n߾-hj,--
pss"ٚ> `ǎرcZjIk4xzzʦ{yy o Onq[wޕ81777t	 ;w8FFVj񶔤ѐ'}3兿дUm_9P gg Νￏ]z,
h4XQhV*MD'0-Q\ߏ,J.XX """""r4F-֢SٳXx1Zj%
Njqjժ?Fffl+W___ @޽oCJɓ'pqq3d􄻻; `hԨٺT"taHH݋+W !!/_OOOoH# Ei4Dw<x`u^[(9(/_-۳gܹx=;vĉei-
&GUl826.XX """""r49h)}֢J*aʔ)xVX!WgAӦMCa۶mh4hժ ȑ#u._k֬;7n˗/OZ/bbb-${}q4ihٲ%4
^*KOʕrJQEf͚صk.\nYYY}/鵒4z{{nݺHLLhTNԩSi*U[n;sMF9@0:r~:M&
.H <tKT	Ǚ)_gYFمh.vq"""""=F-֪: ((ɓ'A!!!ÇQzu;v>|8T*ڶm ,^_>>3g 22 0f;ƍCϞ=Vc9s}cҥXp!jԨx\pk֬ TZƦM`ܿ7nģGдiS[tqqq@+sň#PfMرRZi3fL"Ǐi&jٴ۷Ǘ_~h4n?#.\`s^X `~TV
K,ԩS'`ڵV#''';6DdG"zDed;\JDDd.DDO'?o"""""=oy`È2e
O?Ɩ-[+W"++>>>>}:z
@?p522}>s<x Ǌ+/ gaÆ
={64
|}}fiFھV?̘1w?իWm۶<^:v؁]v9r$ݻwGll,:wVku>JUVaظq#ЩS'			6^Cdd$bbb0sL"00˗/MǃNW^yèQƔ/gxKTvX#*S3Ë)N"""۱@Dv'?x	38t:t:rrrLL\Z?%VfL~"w"zzb#|EdE{...h4PT,LMMի jԨD(E999Fff&D rveסBI'xo>|u9~wF
*TV-}_uF!s?kT9G
h4P6(͕flaA-q)+""rnkwe5ZKtBbK+{O SK`Te)]ʒˁ$
:E',K)Dhg,7Vhݓ2 uz%\Ԇ+Z-j5󜈈+6V0-9@jժaܹ~:"""鉴4$1oܹH/tqܹsvލ@?ŠW^;wnI')JL:pHz[n=:t3fXpBbݺuO3- @ :8BpWpN(iݺ5:t耰0;v1&2r3+8,)>իWI'Cr-hӦ
ڴi~%baz-k׮㏋daJ#.vq"""""=9X?lPyfl޼/_mC "2J*X`&Oe˖=mD(ݫzgϞԩS ݺus=$$$`ለ@=Q?<vލCBQRdȻ!ԱmSU"""8+E۷Z֭[1qDlڴ	-Zp\>}'N(d8	},)puu-dH*WO?nnnʂ(]6ZmI'DAEZv۶mxg
T\8bHOy/0,}ʈw}]t)tjժCj0"ħ.Upl6--
ӧO3<u֡jG4Gƒ%K5koD%x1O09r\ HJk֬7|7|=z~rD
%cРA%wwwt2J.߮];ׯL=3o2F2%RHlAdDѾكt,[L6 Z-&M8^x7oƥKPjU?۷o#::NBZZ<<<I&Iۉ'O["555knܸhܾ}ǌ3ЬY3iwΝ;q5t:ԭ[<reDFFŋĨQ?33111pmYf3f6mj5ߔ.w_/_(ѣQ^=~|Q=%ύ۷Dn󋢈{p
cǎ9rd@={p}Y(?~YYYhҤ	ƌ-[Z]wAv
;wt[~_;Ȳ<\J N'
6 11)))*ݻw	&_~2x7cȑ 
Θ1999ľ}Pn]l߾*,nݺ5kA&M0vX-am{]tA^px1cEueNM6aϞ=HMME-Я_?L4	[l8ڽ{7֬YKbٲe~:jԨp4h ~)~xyyaذa޽%ڵ+z;wxZlɓ'aÆغu+VZ ҥ}]L6*L&iy+Kyf\xFn0|pj ^r%ڵKZ_~?lc̙ݻ#"""B
:ٳga\t	

¸q
@5Ǌ+pIdddvٳڂѭ[7ܺu׿hK/aҤIޮ]}9s:u]* """"b򶆍҇oD9_MǏZj8.D&MdGDD 88-/h߿bСCq%L0WF?`ʕ;vGŊ+qF_5jbbb0k,@E v؁m۶Xl,X www̞= ͛Ç1o<6k֬)9ssNWĉq
L>VMrGСCj1gL2;7ox\/J4_lقI&Xr%J=SV¼yKbطoFl}'ؼy3BCCtRTR+V͓!Cܹs?~<,Ywwwŋ%7nA oΞ=k׮ټ	&c(甈
~?y)))Orr20uT7xCQĤI}vƂ/[#<ZnDٶ=Ǐ[n }?+W`ڴi۷Łriiip%L4	K,(9rTV8`ʔ)xו
yۭ[7|'[>*ikpB?UΝɓ'ömЪU+,X@jRߴiA
~zܽ{3f  ̓111PF4m_J@紼%+F,\˗/G۶myfݻW6oAk֭[V8̝;{ｇk׮aڵXx1%-:{,F){ʔ)8<ƎNzQQ̞=?&O5k 88+V} ڂ-#..UVž}eo9r$rrr
<&{sصk}\? r竽.vq"""""=F-@?_!rF]zwA:ul^nرٳ' W^ٳgqiիVf͚ƍ ڶmHJJ';;7֭[駟J}̝;)))իW;`̘1z6l޽{Sn
J(TR~e.@uHNNFڵ]rVBƍj*)pPPz
6`V(d{J%##111ر#Ν@5jHfZ799۷oG~0qD K/zaؿ,AJJ
k<Ç HOOǏ?(ͷm6//  88
BTT%|
ܤܮ]"22;wɓmZW&\JDDd~=zG5{N:Xd'Nɓ2e
@_?tXnBCCqߐ̙37oބ  !!͚5CzlfeeaŲ'/#66VjKh@RRAmz={aq͚5֕SRRc2#F w?~			Һ3f  ӧ*ձG}Muz
8.!r!%,sZ^ʒK.yXt)Z- 9IIIϋ%uŤI1w\aÆxO?IiVRv_>>>XjTFUV
lE׋z=%))	{ʡ@TXQQk)S@xxx࣏>pȑBs9={ϗȶi8s:uꤨjoT\sDDDDD|-,}@, U=Z]`dWk` hPV-ddd  4i8 7o+WEQQƃA
}1m4 Ⱥ7n!uyH ???ԭ[Wz]B_ ?ׯ_|Zdܸqƍ: ڵùsmQ)ɗBΝeYڵkF'Ou\p:NC@ߙ_J;wbG "^{5;w
=}46l
Ծ}{lٲYYYP-޽{ѡCGIܻw/F
WWWER9#:f\IDDd;~` ?7nD͚5rJxyyI>} ꕯ*mڴoǎd$$$ ,,ǉ'}===(ۍ7ݻwKAmqҀ6@Y]ܹst Э[7[%m-㧢X:^*U ߊi?ǏP)DiYb紼%=z@=ׯ?LϢ@XʕQNY[RJWu\O0`
7|#.z\OiӦ
ܼyh׮åE`x饗dCJpܹBێ;ޏWRN|"""""ňe#w}"g!9>se4jHqbD5PT#66)))pww4#*Vhq...VO?!"ԩ#u֟a@dp)Z
jѰaCxzzZݶ߿ B///[EKzz: `u]m_r1RD-Siiiv\?~)))8p 8`6=11Νa5V""920j(JJJGЩS'$&&",,lF%u_:%xgGiWniii ݦe`ԎNo 6Ngq٢GH	&%J>,ʕ+w^dff-Zx]ϋaLv3kae
N'
EOs=e#G  7oYfQFE`T{xx(*VJi{ߟADDDDDT,c["r Qd["c߈ڵéS/+W`<x0Fhǲe0p@[4|;vҫ0f`ڵhѢ\]]Di>OOOܻwltԪU>̈́	Z×    IDAT۷Ah4طoN<i5
J3DձK^[(ݞ|1D={65jdu[*W,mFfo֬tu= C'0uT)c؞={PF
,ZlZDDvi灷  YQ	6lQFa刊ɓp111PTfEaK};$${ŕ+W^zInKWPP;{,V
V
d{mVW6SSSeٌӪUTӛ*j{~;(mTJkY'1cڷo/m"7+RR%T*ʖEGEfp̙B=+"<<HNNƏ?
6`֬YرcG![iu:RRRn|?Fffl+W崽W{Ϡ°-DDDDDzW'acÈD 3!rZx[o/6 ĢEhУGLJJZѣNl$%%qE{ƍ޽;Zn-uDckѺuk$%%!%%EZڵkv_~'O0dBe-JFݺu(~SN!  )ɗ-[BիhڴSre\RdcǎƋ/h1PfD4z*yY:m۶IǠ08v:w\t	)㜡YX;W٠/~~~رcrrr.ݺuk׮Ç=[ہY&vڅ. $$DVoA믿{>ɓq"A
ܢEhZe
QmW@GH	Y*K95VZ˒$hBf 7oĭ[XJ.Vf͚e?&O~M^OIKKC.] PfM{x7p- E/l9GANNСCɱeXVu[|9֬YcS9]-1ǉ,c["r Cvx[J̝;ӦMûﾋԩS݋;w`Q͛c݈oTlݺ7o,qyJx{{Fؿ?6mU̙3 <~ 1b
NuJXjc߾}uRܘ1c0e7={Ǐi&j=U>Xd{Jjժ<x06mڄlظq#=zMmС}vt:kׯ_ǆ
'=Д'>lٲ/"N8a4h $$$`<x0Wcǎ!>>ÇA͒}!''oݻwǦMsN|G֩s}cEJDDTXRaԩtRĠ}x?f͚IJi}[tqqq@iEo߾سgFCbŊ`޽{#33Hm(+{{{O> hN·~+ҶVQ٫NB͛ѱcG=BJoab,Ti,K5k~|
5jE?E:1fL0={ăn:#00ɊzJժU5k ;;{J Zr<1vXoƺuкukm۶E@@ /^Tԯ_ƙ3giS9]-؟ADDDDD%E[F-}LEŏClAdH_~9mۆÇ#%%UTA&MtR4oܦo_zFhh(>#\|~~~EJ X|9/_3f74hi&X,@Ŋѯ_?[իEaÆ
9r$*W͛cӦM6lΟ?oJ{̜9mȬ) Gձcڵȑ#e56i$<صkv܉jժ{
5e;v >>/OsJx{{c˖-ʕ+L>{VG{s=gSZlDL8Qz}!DDD%^xݻw޽{o>tVBtt4Kܻwի
۳ݽ{wƢsjiEZ͛7cժUXx1A/ףf͚ P6HaTRW=z4Z-vލXj
cƌAdd$*VUT@6mC```#T/L,%*eɓ!"VZ'Ovӧ޽+PjK觥:HPP֬YkbҤIpwwGΝ1j(h4׋z=eTx{{wxB ""nnn

ȑ#H|gԯ_+V/ 6uڂDDDDDTR9!::999Bff&&aQ-q~CՒLStl&jb#
F{ts.\9s еkWo3g,xwh" W^hѢlP
Fx*oA :...h4PTMTFQldffνL4Q >U(T- '	ĝ
*@J(d'r=#
h4P6(͕flaA-U-ls3\Ζ+}
|AؿJI'JأGpAK`֭Xv-9O'qߊ@6-{KKe"xE-e	)O?aԨQàA]vE0mڴNJu}ƒynnnp'O~L}^	
VZ<'""""e#ޒ>}'N
Hz$O#@aO<DVs,ΕDDD6`TPQQQ1p@xxx_ѳgOF
㣏>̙3h󓔨Ϡ򛈈HO[>![`AmQQQ%}g#yDBQ"u/+;l6QXv->3,^>DZ0tP0GͥK0l0G+$Q)ߟADDDDDT,c[ڹs'+Vw0h4۷vZ={hܸ1` wy/Ʒ~$h4t'O;-ZÇ#!!AZ/ lܸHLL;Ǐ#++M41cвeK kлwo̞=111HKKÌ3Э[7lܸGrr2U:`ѨX8uၠ L4	UV֭[j* @.]bڴiڵ+ڷo3g*@^zΝ;8|0=z-[bhذccE7 \|x"<==1jԨz2!B,ȈDesF5pXqJDDT8DFrʒN9,L6͛7K:%%R/?xFKÈvqF,YXb?\p|-8F?;v,<([x̞= ==N-W_}HKKÐ!Cp9?K,;qEr˖-;＃aÆ!   qqqCvZ2{e  :t(.]	&`߿?~i_~mikLL˖شiA
~zܽ{3f( ܼyaaax!͛aÆa͚5?j'uB|lqΈ  Ap
.DDDOGEb'""""c۲o"33

Ŕ)S  AAAx!=lٲ7 W__]Z[o} |||pa㏘>}:DK []	&  mۆ| cРABtt_~_>}] /777<x  pUTV
fBƍ m۶?$%% T"̖W% ͛PIn
J(TR ى~0?#9F%*[&(ΕDDD6`B0MDt3&""""c۲oFVV:v({?,,[nFs(
2֭qMMǏKu#G 33QA^^^

 >}
6D
ʒդIٶZnK.a˗"
nҤ	иqc$''ٳرc\ly4QZ5 剭Ο? i- nݺE^'`~"#0-Q\ SDDD%_Dd,L~؟ADDDDD%o2Ft B-ȰރPR% lAd			
p1t}tZ-@\SiiiիWMׯ*Uo}PfM7o  >>HII;hlz0 oM
7[9QlQyk`YF"gQIQ>𖍖҇o *{޽{_ѪU+T\3[6%% 8blڵ믿Э[7Yz0uTWV
n?@=zpIl޼hժN>e˖aݻ7j׮
 ?>;( #yzzZ~zz:jժm;x, OT&cK,sJDDd
Ddo"ÀO^"""""2R<'{KFM&MBnn.pYi`)o8p jB͚5mfqq۷?<7n,MիW3ϠiӦϡCm6h4ˇ㣏> _Ǉ~\ܽ{IIIP=z46;;III*UEV[FRRl׮]õk]g!8`"g$GT&`?Gp\%""Ddo"Dŏ9NDDDD|-#ޖ>xk4hvލ+V㈋͛ѿcȐ!j6lۇ#G`	1vXCE۷!!!i
B
0|p|8y$-[Xԯ_Aڵ'O"!!֭s=___4o/cǎaѸy&233 o޼gϞ5ێV|0b|wHHHqm;I93zDes$bʹvl3]0!"ap""""""*)Cgb҇o&<<ꫯcԬYÇǀ  kƖ-[O>Ú5kЮ];W_}D׮]eӼm\YYYѻw;h T*ٳ۷o+0vXh4o_zFhh(>#\|~~~hӦ
_޽{ma+ooolڴ	+VPbE'Ot y7['r"#1}Ê+V""±@Dv'?x)xFKÈvշo_zaٲeVשSbtcf-vXxqi-A0p@8r `Ĉ1bٴnݺIbղ0KCAai h߾ŴR>sXj>e(*,#-  7"Y6مhgPqa"""""=Ϭ7҇ogClqЬP,Q+Wl6م`08Qc1mYƈTƽ˅ӼysDGGCj@'r6#Qb˘삅	3(x0h#RcǎBqqq)1Ax#و*~_;26.X?J
#ޖexKe\ZJ:	dA <DNC'*SƱ%9%"""7a@'yHS)#N?)_ X+Wl6م`08Qc)xˈ#N:6U=2%&F;r$""RLl3XǗ%,LȎ򓈈J/F- }ȸWd[2&&gڙ:*Ax}EyQa{IDDDDDFV0-9(0#K>POi#Fe ^C6]e/oM[N,g=A4Jo˩lWO|9!o{e9deE6ϏJZ{ {{Qz@Qai?zn?;B~3e'5'dn{}lOP7.\-
^XiXl;0J@^lmk[jyf+,% pR6V3oLzy˘䯭oz19n~m[wi|}85NMna>B
^*=זsd>FeQ9mSe۵毡?CTNx0[DDDDDM[6RJ~]itBT^.>T*wE\Kŵ:T%X~m ":ƝdRC|(]BA
1zׅlF#E XKy]!y t.^i^Z<`]NSyWGz-)#6Nޱdhst+"""=:J\ ߏf[i;uU&m W;ԯ\[J"-G-oZ:My`LV]P:ɂδid`ZooT[XoㅜWJ_HJ+˃K޴,1V,1i[
fyjhK	-a--N79fmIc"B[P`.K6.Pt
eK`h
fKk6 _5-Cyk|L֧*?;ÂpL
o2<q\=}_Q49E?_UBe鼐_a糠_J*CɱDDDDDzx[	?lҝDT 1>gƀr˅.zi4MY7Loؖ7*o~A߮djdd@̣eXKg.[țĐE1~O_Wx7n7vVRuXh+Fc1wK+|^p,-E1F[E;;lV	PՅZu,zSl?:r\t\i7Ҹ__M;(}Q#~[9B P!_RKZG/0ң=sm麟BN;ZժtYo(/zy=Z~vXK_mcl۾za./r-FlVWAբY0.K^kCUruu%#$ dY+
XZΨm,_N[Um[_6Oӭ-n/gbWVh>X`ϛ7q	 BzϱA9XXZYZͶZ4}䏟PNytQyf< oH}WG6DDDDDT}p&    IDAT0mYf` '"zZ 7[On+j2\Dvv.rrDBItY_*m>>0S;CaJNhW4R ՀFV+gDDD VhUlrrtIml7S  .ZhQ)"5
juߛ%"ɓ'6%5Zʓ}n໽ KLG	J^ty加VCj1FBDDDDDhx[	?l@FwQc<ЩRhEAբbŊ%yy2ʩJ'WWWlNRqИJ(P β
RB777cdPG1M?9 """""F-Hw^:!*L:ݲë|0t0h4Y;Miܱdc(L#$""ʯ{T* *
:NJk...lBJeo~,K0ZVՕS6R2쏹JDDDDǈe#`[J}TN.C'*jZNeigY:^*߬#""*2C](t r5J!e	يYc\>M򳼕DDDDDT:1mYƈD  lr<23UwwXQfAoܡ,KK/3qзIg{*^_^,K(jVe9F9CJDDDDD#ޖexKD xKTwzR*_L#8
ApΔDDD1gT({e	00Зi,K9ö1mYƈD tBTY(͎僳G(,YCd1T8qaYBJ(9y"""""=F-@Rȉuaq{De[DDD뙥QYsL#"""""NU,yب-5xKDDDDؼ"""""""""""""0m%~p,a/G4zȓ)6D:q(i+bai-6jXh}e/c%?t/#?BzuY^X6l?ϊ
-RX3!|hKDDDcۦY&z3Q>𖽏%Q*Jwz8o𠨓^ 0N6] +:GD-LJ Q_'ϟZZ @MMumG>=i8]e#*ɯk9]痵Ew!)O.XPR	yi8|Y,bq<$]?e?s!y.MRe
"""*9o9%"""""""=FDDDDDz*s2m3tRyDX74l}5G?oО>AhaYS y9_+ϰ\`X`ףA)Rha|
?8]@rF%W~ovW+*//ye4ݐ凔|Y:~y뷚.Qkqe ot>veEo|eυ\zE]say	U*Ax˨DDDT"eU`20VVcbOuFNvrrrFzdmYxc V%}d'N/Ν;  F7|
wJ?}'E_|Ns6_:vJ4Y4[S,
痵g<+KMMmߎGJ۩SЬiSh_>FuV/,$}AF>PJJDDDDDDDDDDDDDDD(xˈ%8FAgExrs:PgϞżyGz[n1cԩS)*C⣏>©SkPH꫘={6N/jZF6o	8tDDDDDDDDd'#ޖ! Hpu:4V,7̛7{Xx1K0eTo1|8z(~G{9s&j֬Yɴ;C"j8-QI?
;5EDDDDDDDd%"""""c2B(
5g+bp .. 
`޼y

-Qy[o!$$qqqXhܹ/;?~
l↘dǥM픖Z.uYGS:jnYiW4MsXi
j➥i`
Npxaf`F?f>|F@c^wEi  <p         LQᒥ~MfٳuIR5/jȐ!*K6GV.]Bր4sL͞=[^u-ZHƍStt͎yK  ZK+          o+ߗފ&Jrҭj5i$:uJTR%1BƍS*ULNX1eddwիu}HJ``^~e
>\'N￯ӧOkz5e=fǼ.-R  s?      8fHW'    o+KpR^xAַo_M:Uu51YOP?MI&B
		т4j(=sZn>G}Tmڴܹsվ}{c^W  ,9     p}q   (.4UUX,x۳gnv^ԩRRR^zgo-҆
쯛iӦioM4QBB6lؠf͚Ivڥ:W^:p  @y)>          J[
XΎ={L[͛%I7֚5k-[5f̘bjȑ&%r-]t޽{h"TիWiӦ:t233MN  z25.          x2/5jK0ժUKRSSe?^?eg7!X,5eURE?5h@/.\`vL   `pr3sN     1    0e&//OӧOW
o(//O~~~zua
6Lft;w{1BYYYeȵjر:|~iyyy);;[&MRxxϟ/jvL  
"]<!ԹkS      8Fc    a-0}jذ^x={V8p<
0;>|xE^&L(D!((Hsվ}ԣGIɓ'5d5mTW69!  @d8@     p    `[8͛պukO}$K.ڳgbccu75jǎܹsQOXXm6mV={/virB  3p 	     1   
oW=Թsg޽[t뭷O?Ն
ԬY3ӧO+նVUÆ
sr"־}{رCK.Uhh$iԻwo=z܀   W9         P
Luui
>\M6՚5k$Iu{nu䄮o:}tꫯ@$G5kjԨ!IZ|6l#F\s  Μ25.          x"''G'OVhh}](00P8\lذA-3fQFȑ#=z|||9sA:urrr̎	  P~Y,2܌S      h    6L51C--ܢ+++K^^^6l:n#22Ra\|r6OLܽTRE3gԁcb7nnƪ   ExBsצ@     p    `[\7y4h~IR=wyG&'ʷu?Trr:u$I㏫UVLN  P~"         P0W,==]TIR۶mm6ǫaÆ&'*-[*11QWVƍ%I{U݋;  @         LE:uJO=nV}駒P-]T;vPMNTl>RSSn'KGEE79!  @yܵ)     8Fc    a-ԅ4i$ޓjU5+##C}1;"2<==5tP:tH&LŋհaC=:1  ʜ5g      c4    &j
/.G=96;&+z'ᡜ͘1C={͎	  Pf"         R`-JHHP'ObӁ4cUR숸J-W(7pbbbݻKΜ9QFQFZtN   ni{%           oQLjj"##u})--MԩS'%''?TݺuMNcob\[N6lPf$IGc=֭[k&'  ('7c9O
     1   
o!I:q-ZhƍlE5k(11Q-[49!Evv$C>>>&ҥݫEًwVΝh&'  ptPM9        n.++KƍSxxTXXnA7|x숸AAA&'`Xkʔ)R$4ih:u   +R          oTAAyiԩ'СC2d<==͎뤨x[TЄkرcua=3jՂ'f  Xh         (oիլY3=̔C_V@@q/Vjr8CPP̙t=Cl0*((09%  ܵ)     8Fc    aٽ{:w={*##Ctoтt
7[O>D۶mS۶m%INլY3Ǜ  Y\s      8Fc    *|mNN̎Q.!7{lEEv-Z8]EVV~'OHӞoQ!!!Nyl\kǎZ|ƎC)##CzR5w\{1 p}|ᇒl|׻jڴ1P8}Eʑ#          [7`XqٛSwgy.y7PPP$i#СC&' 8SY]	p-6.          J8 T89r>^+V(""B#FӧMN	  PJ'7caW     \1    0 @*U4m4߿_bQ~~̙
hʔ)1;&  HOuڔH          lx nnݺZdթS'I/*<<\
MN	  p9V          &jٲvZEDDH?'xB-Z_|arB p',         [VR]^Yڴi[~~~~I&LPttڴicr+diԩ񒒒p3=zX,QHH.k~;Ｃ#G_.܁ﱧ*WpuM7|u\EɓUfx^uM.ĉuIk׮:tfϞ-___c@q1%$$_
{[}3ghɒ%RjLLbbbwW^1;
psצs
     !_    WR GVbbbk.5lP]v;%$$(99YFRʕ͎Zl޼YuuqթSvm۶Uhh$۔<ܹS1112C۷/.も9sF;wTJJ[op%zꩧԷo_͘1C3gԅ4o<}Ox@)9rDfR``:t*UܹsJJJݻ[n$۷Oiii&'.nI*U2;:]VSN     Nh    rok.W]t)v_۶m[oiׯI	˧YӰahƍ۷m#""Թsbu]?~֯_O:p={5m4jL!uI&驧R޽e8p@mڴѿo3F
r a`{ѫ5kh&&:ݺu3; 
          (x/B7t+IM6Un.u9͟?_P-ԧO۷ILLƍuIZj{j׮+WjȐ!ZlN:իTHH-[GjժաCc߿_֭ӑ#GU}z)I˕B~2,ٲe*Uo^6mC=TrׯCj{\jժW^QJJ5tiYFʒ4i޽{+00PmtBB6oެl5iD}ӧO+>>^_Un]w}j֬}]viݺu:y*U[nEzRHHH|#tuѦMk饗^R~~^x}3g V@@@}HIRz衳gJ>s}'^xAz4fqڷo=;_~iii7߬^z)<<9J?|5lPtM7駟f>}Z!!!۷}~LL;+wq~(77Waaaݻwk.]V?ԫW/}G;գG=pyN[\         ޲L=r~7ny衇tmŊ?;S۷oWZx"""4l0=O?ٷߴxb=Ú0ay)22R/gcǎiғO>aÆ)""B֭֭[%I={[=C8p>lJs^P[nU֭:(''G۷o/jԩSYf?Wy撤Jrss5sL;vL?k׮JNN.^tԩS'
2DlSLNz9sh׮]CijԨ_~:~ΝCƍSRR4h I;w{=@վ}{:uJͳdtپڱcGS4f{>3O>jժ4}t߿_-???͞=[TIJMM՞={4|p=s:w|M]Vט1cdƟ I=zF_~$''k]աC(++À$ES      Sp4   qgΜ$_ǵnZ$jJ?gɓCo5i$8p@jՒd+KM4$uUSǎնm[IR=m6=zTjұc!CtzJMMՁԹsg9r4i:JR:s:u$6~N?,I2C6lؠLӧv\___ܹsly*Uԯ_?իWOR    IDAT?l7mڤݻd{eggk޽O'jժ-Z^ӊ+ԦM:tHE$IUVUjjjr\GVclR0yfGrcǎڵk{nyxxnݺjܸ:vڵkK*WlY[fMu6~zrJ;wN/֭+WNx5TE


4x`nM[nEtw+66VgϞUj~kVs=Zx233իW+<<\ђl'hɒ%M[HOuڔH          P6J_ ,

W:y3""k?c<:uJ?PPPPcof I$$[qRMǕl:w<yR:v}AUT^$hBiiiW6oެ իWO999mjŊ:tmj*Zmҥ"##\,|;v$۟u	8q0lٲcvmŊWF,ڷoe˖駟~r^}UiFM6UxxԯQԡCegggϞڱc6lhv4 (w"##uرcPFFK_^}qxRխ[׾O+IӍ7ިbs͛7׺u딗W"իWn%E':}^IٳguNj׮[\"         \jm5$>Ց3gӳX[b~ff-[4Zj٧]ǒddH^^VX[*//OUVU
..\P Q_Õ,={@#G7^V,VVW:u
8ϯU^~ۗ_~O?TΝիwGeK_?.\P*U.E(44T>֯_
6?"##5tui֬>cw}:ac@RTrRhhBCCս{weeeҥKլY3c\:a6;;[OO?plըQO8W-|%_tRPaa{K@F         @	\jmݻw4?X>}zPs̑jȑ#ՠAUTIO֎;9ҥK}y\$_oSre?ξIII*((аa쟻?ڵK<HDݺu/*Iɳ۶mӲet=;Ppp$iѢE:w$ٟ+#&9z]85RFTPPjÆ
ZnթSz~(giԩ׿7j޽j޼ٱ \8q^z%
0@;w.v_``u릴48qUJ=,@Y**gee=??Wkܵi8     $~u   H޲}w߭oV_e'''kݺ_<N:/jܸ*U$g%ɸB;ڋ:}7n|޽qV^¼7oVղeK{TAAnzM_#lYFUV8 ^)((ЁS6l(
ؿ=I2oFFFaھ}j֬5jh͚58qVԸqc_vz^x5lP4e @QV-U^]}òk~[ڵ%	?nذ~GU^]׷<==K?PTN%''=%%̳X\s)     9c    (.5Vu릃>Prr6m*<xPɪ[z]ǫZW۷~\222vZIRnn5_yftM:q0c7o\ኍՃ>5jhÆ
:{59=ǏvQFQkW&==]999lřY)))O?-IRhh6m(++K233ʕ+[nO驆
*--mݕYfoG*::ZԤI[NϷOꫯвdCѣ|r͚5I  	`ӻﾫ^zIZ
7ܠl9rDwm/֭[QF[nڱcf͚ݻZjo_GZϞ=o+&&FڵөSr#G          J
0V3hӦMھ}֭[|gϞ뮻ҰX,6l/_K!!!<x֮][nWO>2C|


TfMy_m6YVyzzgʕ+vZuֺ뮻t97o,Ţna6o^֭ӷ~:qevܩ;wJU-Z.VrԩN>[ꫯRժUլY3uI;zgϞ
І
_A۷bcc^xAVҥKUXXziĈjڴ$)<<\Æ
SBB{=~zgV'Ըq㔛3f70; zƍ>LJJJn&
4H_6nXM6զMt?,VZU?b
)88X}U.]$~,5o\O>֮]]vVZׯ,X __2㴕q%          8`1?ʶP*((Pnnrrr4
FoTff-QNN̎<==ղeKc{YYYڿ1ZHHnFcDEEiөShv$ 0UJJ
͎Qn$%%)$$DuֵvQM:U#GTVԬY3"1W9se
-󓯯)"K)O5CVwB[<w  gRRRԺukIҎ;Զm[էOIٳgUjU:w8Y$&͖o:<==Q    Gd' pQ%Ik  ʛd[JLLTFFnݪ{OuUÆ
͎
"I!'μ[     ?Bc    * 6Ǐ71	 <0`VZ:բE=*=V          ʃf- y'N Pf 
_          %(L \oQ[  P֜6S      h    6/r ;7D  
k$      h    6L \0Iҏ?hr  "         R*|⭯7onv84i=:uّvʋʕ+_kx͚5$?^<V*e9a.???IRNNI |͚53;e:t#G駟ք	̎SN{\         /VfGp qZbbbb4uTZݙb絰Pcƌљ3gTN
6ʄGHAAI |gst|UXd8K/     1C    @<J%GM%I:{I\\9"IzWkr")V$  X':wmZO9     0   
0֕{ｪV$[(2i$IRӦMOn  ,"         P0O]vΞ=kr";Ikfr&  D         @	x[of;v&O,Iڵ~0  ùkS9     p    `
M6$řf=zrssyn  ,Y\s      8Fc    am3p@IRRR9br%11Q+V$1Baaa&';b-  (KN_r         @)0߿,VUђ`K&'b-  0V%           o+:u讻$yq;sUzz$i̙
49o @Xd89      qd   am%I:~6nhrLM0AԮ];k0[  P,B6      c4    &V@{$)..4(KcǎUVV,ϟov9OOOIj59	  pH         L|}}#H/_,ٳG.$=jѢɉ&R  ./         xzK&ޖ+QQQZxrJHph@M>8pSFR~~


fGUAAeoӧOW֭ML  \sצs
     !_    WRcrwN::~(޺X%%%I&OիdÆ
;KfٲeֵkWJ  ັ8r
        ƣ[2\X,߿$i49%++K?$)""BÇ79MddxE驷zI  ;r#G          J[&ޖ;EE8ժE2i${z49ѬYT'&  i+SK          pXDDڴi#IZpiқo)Iݻ:wlr" ͜9TW_ur"  ,Nnr)     c4    &VpQQQt޽4ކ**fǁ4h"##tW^yE  ܊ExBsצ@     p    `
.**J8z%IǏWHHɉ i޼y۵kz  w         @y
Zj{%IK,j59\9RT^=3DMF3gd   
/         0DEEI233gôit1I[oUQ;V5>}]v&$  ŹkS9     p    `[УGUVMgr\cǎiʔ)]G&'Ѽyӧ  k$      h    6Luӧ$i69ѣ+ooʍ@y7nիgb"  Ꜿ"         R`⭋$hҥ&JLLԊ+$I#GTXXɉ?6k,^z?iv  &25.          x":vPIR\\ip5V%I8qɉ?fjԨ3f7PJ̎  ܁"X9     p    `[2h IҦMtqs͝;W钤3g*00D(6p@ѣm   `.ܵ){3          lxB|IJeffj	v)**D@q/߬Vk)  ga         @y[RN~풤Xs;VYYYX,?q JVUVUtL
o @n         0MJ=r䈶lbrƞ={pBIբE9*k+[x%+R  }9     p#?   
o]̣>*___IR\\iP2C6mq l$ߗn^Ked昽ˣ|  3        .rѣ$iٲe79Jh"%%%I&Oի)*^ZӺ;2CYdHnmY[  <Nߣ         R`$={VW69
HVVƌ#IMNؔT]NC
-DWH MoQҒ4)??-  p
LK.         &޺nݺ)88XgrI&)33S4|yzz(t0-Y)+ʐz[m={֮z(qM6ڭ||ʷ  Xd89      q   aT%I			:{ɉpC7ߔ$[;w69'n%+2dAڊO~^$j>z
il|qV|[PP@  \	]        .j$ժŋ:tVomv}rTa斵Tmjz꣞ݸdH_L֮ҔG  \A          (xZjIR\\i{Z~$iر
		19]I^,bvTmjzjiO8HgP  )          J[Kvܩt@rss5rHIRz4fݕTϴ\I7A+ϯ/ڍ$43Yɔo u}9     p#;   
o]ؠAd1|6m;&Iz뭷cr"Kk10Te/۟nUՓK
k0mKR  3w        .,88X_%I/fQSL$uU=z09YI5wkdP4<"~|҇TqMɐgR
[  p
#          [%I:~KӸ#F(77Wޚ7oqJ*ݮG;&ݶ_q鶈_5_=ɷX]B  \LK.         &޺\$)..4+11Q+V$9Raaa&'펕dRL\.A˷3wR  Wbf,     8Ƒ   .W?$?VNNɉ܏jUtt$)88X/ɉJ*O߫KЖu(oVͰahڽʷ  X':wm     c4    &޺(IRNN/_nro+==]4k,K$],.纕nUՠU3dH[fP  W=          o@ddԩ#I39{%IڵӀLNwTRvՌھ{IB[kJE4py{vC  7          (o݀b%I_|?nr"1vXeeebhfǁ*tr7ھɐB[kKEkH3g^ʷ  
8wsN     
   `[71x`Iޒ%KLN٣J}[har"ҕn
g#2䧨fxd6=I{) ?aqp      p    `[7vI-Zdr-0iӦn'3RmlJEEIMN  {9         P
Lu#QQQtڵ4mѢEJJJ$M2EիW79ɟnW CQ&nGm[C>}.C  i+SK          pn_~$řueeei̘1
6Dp'%nWHU%C
kQ]M+W?{P-  #'7c9     1    6Lu#ժU}'VZ&'rM&MRff$i49EI3Ҵu2C
Zitݦn'ʷ2c6ʷ  2	]        n&**JtY%$$:tHo$O>ܹɉ.J,V[KZst[?_}WAA2$혾UwS  v)    IDAT          (xf~UVMm-Cj_g6;DIۏg~-'ݎܕnO&( n         0x{{o߾իWٳ&'rZ~$iܸq
		19nOHM~-WOFxЮi[F  } 9     p#3   
oPTT$)??_˖-39kȑ#%Is=gr"Jfks	2TIu=-"AzteRS횶EiS( ,9{          lxڷoPIR\\i\u1IҜ9scr"ҔneHM_t[/_?5eHJER 9'>G          oԓO>)Iڲe9brɓ%I]vՃ>hr"JKgSb2CJ~&':~Ar|kHɯmѷqo pwN[\         LuS
b:660܈#+ooo͛78pq%n?ONHB#_AKEHQVRm| ;Xd89      q$   a⭛St"I19Mŕ+VH}YOK?ʐTI5{K/ëT㖚2C%*=.-  n"]<!ԹkS&      1    0֍EEEI?M6Z$kҤIK+tm?)ÐBT׋.T-䯿x|+~-            &޺GyDŋy.I5kMNWUҭMkw\鶈_Z5VD|  7v#          nrի$飏>R~~ɉ*L?^Ԯ];
0DpU%n?__ǟۅl鶈_z5eО6i_.ʷ  S      8   0EEEIj*TƍSVV,ϟovJK^߯W!A;J>T aa:#F1/
e7Ea_D1
*(3E6	YGNӁt:~uJTԩSOK tk[Iwdѿ&·999o ,      H    6x{ر$I.Mpسg/^,IzuWDnѮ51R+o/^2[JFh'_v!| @=:g          o/qQo7oެ ݻ1Q&N}e7ڹ2ƨ5EVV5=UY/&KI 
oG7          xc=&IӲe\mҥO$IGV5\"T4ŅnwCWVȗdCvѱu皞4Nїwi PQY\s
     gZ    FZlZҔ_'O%ٶY߾}\"T4BSi#Qnc+εF5F{>$| @cIؔ     g$    F${>L{
piʧQF)++K`DHnNݧkMQ*nEVV5F8HC 
=8         o!IzA%K4Ϸ~ӧKv oc]$Ė4n[YwU0-[  ph&          o!I7,Iz	ӧTR%M6-A-to#2(eu!t[ʺ}m/U<N2F_O}O_ >kN     <
   `Èp޽$)++K[n
piʏ5kh۶m!C^z.*
}md+kKɄn}d>j׶o@  gyh      xFb    a[8tEUT$eff4Cvv/Ijذ^x iY2q	ݖTTleݶqUkV[S  }͙#          >`[8DEEk׮իWԩS.QM4I$͚5Kqn_^wTQӖmX`b+um[c߾O  #S          <`[޽$ٳZjUKXҸq$Iiii;\"TCB(YU[F	^ʺe]oUd!| @,?'c     3Τ    6xڵS%I.M`_
׼y]T BmJFJ&D趴DV֟E1MjI2f.·  !K* ԿǦ      <#1    0-
yG%I;vO?{ｧ^{M4` %&&DvCm1IR1zqqkTdq+ӛ}Ӹ$iߔG          @y(gϞlAK4e///O{$iȑ-u15nIn&vn^6򭱇o#|  \          #ޢƍm۶E4eoڻw$iԩTRK`-tpm]wLQf1:B~];FߴoMߩo	 dS      8s   0-<޽$'|Ҕ,
6LԺuk=C.Y7Hj,F	ݖ1	4d]};]·  s?     g$    FGݺuSx-Ҕ!Cɓ,K,tqļnL?E2RfU(mO(q 3G          |z;%I˖-SNNNK{ŋ%I? kv-tkQfU4mDՎMTLZwo (vdj~         x"u]tqmذ!޽{5jhĉ.e/4EC6jTI-O߮"| @yeY2~Nr)     g)   lEUzuIRfffK_K.'|"I3fjԨ!yΛ񃶼&ͪhڢk	ݖQctㆧ$NH߮	 PXR=6eo        oQP=Ò.<yR$lR}	p|	HͪhBBMT41ҁ a         <`[xս{wIRNN/_ǨQ%IZ`BCC\"o۹3~7cv5n˩1j)UItp;?w'[  .5         x*))I-[$+.Mo5}tIR׮]!UQb*-עjW
oet0-  \s
     gF    FE~aIG}>)]}Q^^*UiӦ82BsfMHjҬf
QƧm[cC:@ <     <#1    0-ս{wY^z))=k֬Ѷm$ICUz\"o3Ҧ71RbʚjBA&vUҤ~M | @ }˙#          >`[~С$iɒ%"dK6lD&ņn&cU֬tjWU'#o [  oG7          xI%I?v\I&on3fme,ZUĸQ*u Un'#'o#| @ Y\s
     gB    FOEEEI233\s!7NN:Dn*k? "kWUgTImcav·  1K* ԿǦ     <#1    0-|RJ{ｒ+Wٳ.х߿y8Bf҆'dD趢SU)Q&eӤmo (ca         xu]t).ͅykIy%&&DB3g҆
'dd9U	VDu*eӳhI[·  T8         xYZZ$I.MwޒziĈ.A'dQBB%[H趢SUUڒ1:4-8·  )c     3|    6xY={Jnݪ dfϞ{J&MJ*D(％ng:O)q%_xjpQ"TUT`C P,{o      H    6xѣ$4mVV
&Ijݺz ]q7ן8Z\IYlz^Ԗ$~"| _}ʙ#          >`[H˖-uJ/^nȐ!:y,҂]sBgWon8%ɨqBdE֛֩:F=<i~6[  oG7          x(ݻKݫ={4۳g#$ܻwo]}.3oiuN{
B:UuݦX[2F}q~&| X\s
     g:    FE=


$effOnݺ:sLYͣ޽{5jh	.1ی#n8!Zݢ@dJ*%֑_L  ?B{l     3   MsB8zZ~^yM4Ijڴ[IRUR TZt>IҘ1cTF 啷Ԍ#Z,IMGkni~_yq,{"e. (%GUFFi$ȑ#MU#R   W۶m{WÇ;^`֯__hTz ҪU_z'*22<wqZ>     {t]ׯWVV
ZjR:y(Ijٲ*6t$	Qzi~Kը{ՉKGDjJ>e;#/nTI· VZ裏e˖"yz~ɒ%,H  Ѽys}:yd,\s111zY4 IBBu림"8qbsh     xx~xQ%6ChhhK[vJFl8-#	ZBňSMn~AH(M:<{rrr<Ś1cǑ_IJJR=S   ,5znъC dԫWn̙C 3   [>^}QUVMeiƍ:rrr̳oV3gΔ$uM-'o,xZ2RFzy~BIDjv_XGQ֋uxV· y4h󇆆jܹ~,3  &O=Tnzʏ%;vjժ;wV.]X" ސ    l^;wN?,Y'Nn%O>QJ4uԀQxmEDԩkRt:/n	y>ۯ_19s  PI/;w.wPԪUK'Oiޘ͚5%    xx"""pB-\P>YfTKV5kh۶mC^z+'oɳꍍg$c$!JDԩVo
|kNHDFFt=>>^cƌ)#S   H$%%G)vGy K=zPoъ/    #'zΝ;}
jժJYvv/Ijذ|=76d.w9[\:tjTKѱtd[oEԵkW̜9S111eT",KX9  (==kժ2, ܹsY͛멧*3   
#gڽ{ItAIRFFV?BfHj(J.WMB(uo
QT8BM<`mΝեK2.Pz,P7  [O<k0 y4hPΝ2, OH    6xWvܩ^z9Oq\9tƍ'IJKKSNROCKFJlW5#tRYE%闉EkхԬYP"  [wA=z(@	
<XG<o     
#ޢ"""pB-\P.BBBԺu뀔Vxx͛2|}q/Zwc$!RoJ~aUTm_'WV· JSO=$
 
  ~H͝;7% EFFj̙.ժUK*     1-.X^sNիW\fTR2/{ｧ^{M3(11ˀ[vbAV2JLҲyMU:[ODꭡl'#([ ,44͛7\*4w5   5o\p<0`7o@tE;wv<<yjժpƙ   oqQ{n%''KZjUeS޽%Iӈ#ʼ(n՛Hj R%E_SWmFe$OR`ey `7tP+>>^C
tq f͚%%%G. '$    Sf.ZE
Pխ[W;vГO>2_όݻW4i$EGG
o	s~ge)A[5uaDMxSQ~b>z]0˳ѣG+44T۷gus)  %BRf̘UqE{T4hcǪm۶l2F    =iƁq( ,,Lϗd:,
6Ltu//-:2ܸpBMْ1JЊMKetGtb$%^_W6R U\Y&M
ʶQyf1˖߶q
  <NIeW\'D=VV    a[?rqA2dN:%I3g\܉aq~+.tjYY(!>Rۘ-*~M7'm8I"|K$O5R3˒s2%  E\<	/<\J;q    @b[38pK_|%KH}QhBΝpJι3#$$<7Vmʖ R+&EQZlF#:9a,cT[]#|Ĺ-Frn+p6'ˎ%\L
 g /8xPR^/vi    lO;d~8nc|#ceId'ed1cY=?2i|+"Wx>=v[gfPjW_-+m<|/%\yy,YRhtBCC':55t;7n BE9QoKJ"|
Nę|<ȡ(msN+zyux}/sRm<Hev1|*<b^5^YmRՉH#R  9h|9[ro;߬    IDATW|cɵ廷e.{kW6N]\ֹvSzKي]~l/{|y&b_,qFA?n1ryt[{ŲK߅xGsڧ?CӋl3{Vp]~.,Hy"7[7e9Y~{bmP[I    #s̿hY(2jIV~qHP8	e*2N8q׳nv?6jkeUZ!J`yN]Bv	QcﴞoB^Vdb:5-t;5j B4"tr)~M]mIsSʒT-*J~Ȳ;mm9:SoKrr]M/|$t=u=[Sr.G>^֧ulGϷUmӋY_ۅd}-[[#͖
i\aaa,~ H P${Knn.љMA;̩sؽ}ݝ%^ƒ/|;^U*w],{zޒ|S=.U=>8r_w!Uv{Pl߈bqzH2a
}9|s9x]t8a^o~_zrwx+~n*rl*l_rX^/y~a4^E    #9
g}(w&Zr\9*Io.Cu{y-z;<`}Umo8cm>:8qy\[yB,Iqw,77WyyyܪGC'r9cԘ-=|٨NMX_gmTNNrrr
q;;;ʘ|IqmLK
	QAt{uzI$ަ1ӍS:?rLT`o=rn9u=_/	q[.>Uqa<
-'tSL9P^G!Ns.!?xC<zeɿۛs  xB+hI}l{eIrzּ3m!,ﯷ_oy~rK
owۖk/qB>UOx8__"t]+}ﲞwz"/j-4]^rxr?>pݾ*xKs~!N}Ҷs_0{߅|#INP[^:1[)<o~{ϧ2r];ܿ__gKrZ'XnqNI%OS}TE{?k9?,
>_eB_    l֏G͓dIFzYuw:uIڡ
)Z|<S49
	"(ׯfoԾF#:=6mnso
_dzEfLS'/  <!4ir*z,\~N?3GFF.(?.lKûWҨ]9I~;P,>
   
#yo9Aakm1O#ZZ'M927ndǪۣ'#8#ߢp:x1LU9T #s?`Ȓ/x@s]!@̸w0-    x{h8r
-5nEPoG+21:3
6k[=WO.no"c8)(~;25n ^8}kl{w>wEwa8@e9w8;S7   gxgL锁BW3oQsOjcԸAޘڄnǪۣP[HgE>#$	`eĲS  ɷi%akn۷rp߅TpP!O   `Èeѓbz-t;r)؜ݮ@kE&o%>
-*[ڙ"?{˖%	o oў.HeOoTyG   l֏\hXrM27ZB`ǪqAV2}<[?*[oQ)  (\x\Sx 	]G    xǈecUx`dd+y6I2j \4P횡-0cX'Ԗ1Fgǿnۼ<·RG
  X*聊ܴhv%C    (F-kV(͹22j \f't
-~36Ύ[M'DL?P  8i%Q0-GAɢCE|'   a۲b~NZym-ߒ'&õ-.chxȷǭəo*''Go"0LX  ",KgpCe	   l؏B0KtF˶I}[\RǪoetnj"|A`[C5  J'p1-QA;    DFF1oh|H
´av=B$ՏU	
O#c΍]E" p~ܥ ą}k,=Ap(
o   dq
,Y
x^ݜ/#´1-.macՠ |+I&ik"HB`*[r=  >2%gknE
o+>!   
#ޖFOFZL!t%_QúaڔQ- mmH9^יol"0LXR@n{  .(P塂b[O   `Èer
8DGgʖ|H
ksF]]GXZlD֫!o	ߢs 0 <b[bZTy    JoǫȺcŇndF´%.c[]XZlǋ
WS2FVoEd=#T|TG  RFT4E3(<T\w    @0mYxX. b$5ͳjO;^Thݚ!|r" Sw_ P2F;NE@IؚdQ⢿>   0mY1n'Fżn/V[ۺa2u>|[C2RU:KޥDc< ()E@Y-D
ʢ>   0mY`.Vsn-t֬8B@	7LuwLRh2(ok:;M·("0L}s @.4b8De    a۲F	Yw[vЂsZҨ^Bkz올%˕MEaۖ.%  KBK	}c۲ߞd8    Jo˚W7oެ$W^yEIII.?[M7ݤ諯r}<xe߿_)))zᇕqѣGg}vq+V`̘1sM7oY/bbY._B2F	´mf20*99Y~ƌGiypoٳg=iӦVJJԧOm޼?VRRmVh9wVjj?;>NԩSuw:+-"e>Iqe$Xߢ2*FW_}U>Ԯ];C7o.
6Lw_=SfW$F	2%%t=  H}ݾ}3g˻[5~xI̢흕vg;wNz]
4DۂU]9_y+~gcվ}{j.]III:sL-o+>!   MsrIk׮UӦMk߾}jڴ}QU^]-믿jڵݻ/_
^			z'4}t+ѣ>H֭Su5\Ilbbƍo>=ӎ"##Kʚbp[r-K2Jgl*Uwގyyy:p|M}ZlRKŋR*/5` eggnSfti6ll٢'[޽[W||̙5j(//O=ݫ޽{+11Q?4k,ĉKe|"^q;&h4b~wbR}>w;vI[jذa2[o{b3E @iϾoTV<Nꪫ|^NRR4iRUT$GՊ+Q2~ÑҪ.<XBiiijӦZjuA@a[O   `{.?t?^VҠA<۩S'ǻ<סCCW3<{>ھ},X+!!Ati;VM6U߾}/jiFmڴq<ꫯ~=b*V|B/,ҷl7XKwfXV=~4h}j׮] Jp	=sVfϞu:=#Zj&N3gjE.D͚5KUV$}ڽ{Ν;Kڶm:uw%݄W:9#2bIR;]o8ҵiF]tqyWΝl2(9F	8  .$u3f̘{@} ?Vw!u^9q$Sf$]~(P    J&9	?[NQQQjӦn6mܸDꪫ~ׄhĈ,Kcƌqf:k,=zTcǎu
矫o߾Сڷo^w,s=6le*Ν;	&}j߾_~q?_}<x9R2TV+77W999zaa^~+DHi{C\wu<XԸq㔒nݺ)??_fϞKm۶=ܣe˖9#vVR׮];CSnncÇ5l0x㍺իW/ٳe۶mӃ>믿^7xy8p1~ӈ#?Im۶սޫ˗,СC1bniFiii6l~W<z^yM8Q:tPjj^x?~\-ܢvg-Zvvdr-9sΝ;>l0=sTN]jǎyRSSuaJJJ%_xzj;vLFr	{رVZUh]-ZhَЭ$UTI>\^sKR$l)
]VxU2ܹsU^^Sl+W֕W^Q/]V:uRjj6l ɷzٳ>}nv]֭6o2Oqu1F,P.]nM&Mr3%i͚5z衇79eժU馛o}JKK+e$iնm[uUc[oU-Ҹq㔖W~ǲInϱ-}F`*>v  RF_iӦ)))I};v())߇V~nPmof͟?_zR۶m5a)(;;[fwܡd{Zvkk=䓎ۓ?c׬YTm޼YwuRRRԵkW[.O[_W_};!gС\X(S۷OIIIzw]^7~b/ezy;.7,APЗ:ϽgW\u1Fox[nѤIt)߫~yǏ׀$.;$~%%%i֭zFRg*##Cwuծ];W_}U_*    =xKtx5??_ׯM7ݤhuIgΜѦM|^ơCtY]ve%z
'Ԟ={vZ}Zzx	5mTsN=
׈#4p@}wٳ#(o[5JO?}]?SG999;vZzrX
ts677Wh[d_kЭ$}=o>ut.W+W=ܣɓ'm۶6m[p&N$M:U>.]iӦI~WSwր4qDURE}ї_~)I׿+))I3fА!Co>͇߱={׬YS:egϞ?{g̙3vnܹ
WffF۷5{lM0A~222Ydƌ-[jڴiѣ^{5
2e|vڥqiŊנA%IZljժ\pN:^o֩S'+4mٲ222TJW^yyU\ܹsknݺF/Ka-UsU2U^W(x=Y~.ϧ뮻R޽uTc4` ^ZMVZiذaz%Vfff*33S>fϞ={jڵ}/uʕ+5vXiF3fTÇ~pӧh"OݺuSF
m#_K<yȑ#_PoŲ,K,u
<S~?ASLQDDOۨT0L9m_ 8K|	%IO<4~x={VƎdE.{̙SL;C/ٳ'33S
4աC"s',K=/_.]hJIIј1cb
It'˲4~x+::ZpiW={V3fЈ#;讻Ґ!Cm6IRnnO}R5gIҀ}Ckg1mk鸨mKgÑKΓﳖ$iƌ5jZz衇aW999>~8B9uT͛76vXhŊ>|mҧ>bZJ>fΜg}VԠA_wq    6a>ǋc~?Xv<11QW\qVZUfI:rBCmsZ`BBBW߯wyGUVC9Ϙ1C͛7׌3&''K.Z`F}!]*jԨEEEIj֬^vRv4sLժUKsqsתsZbzU*0ZCrҖqPm^]
I6??_?ӧ[[ڴi㘖	&8FNݼyKM2E7p$UaaazWխ[7_VΝ5p@IӧsNW_ѣGl2H)))޽2224o<ٳGew?{̙3\>SJ*Zjla5kjСj޼$mٿ}.ۥaÆz$Iԁ4rHEEE)11Q:tp{	-ZH7xF)Ij۶ԩ>5\#KOOW%I׎;K.jԨI^OCfӝ?-t~z={1AqN:^|222ZīΩ:~ó?BRw)$$D!!!ZE>kǏw|hw    IDATu\R?KKKӣ>xO[޽[?5zhvm֭[?뮻Χ>Sƍ?Y6ю}|{u]zꩧ되{W}#o?!WztMeedd8F顇ҧ~
F~5vX.:x|IlRSLQddd(;;іh 0 7ϟ?_8m۶m^"##5zhS-rJ:rHǳ>|$[̙3~X5k8
>ѧZ~>@}踍|rr5w\uYׯnݺ)%%EԢEK.wɐgyFZ$uMϟ4m۶>x}Ew\\bE_5_?,vFGG;j*EeڏmY2<G.:/::>k;ouÇ|r=zg%I_4` mܸQ;w.<;_H:uH
OSN֭$Aھ}vڥA);;[ǏO?񚼼<M0A.t!yi    6؏BbZvի-Z8n?IӦMӿ/t/KeTRECqJ²,9RݺuӡC4m4S>z<tƪm۶ڽ{w߯4x.!v),,L_SXXK5jUW]>Ԃme}}~~^{ouza>Z	Jұcs֠A;3SzuGǢd*EGG;NpqzWAlx.O&MdeggkdwQm۶UVtW;oݺ-[Q)))j۶޲eKeffJvw}}9FkѢU*>>e{T\Y'Od1;;[7|:mVaaa裏.={<SlqQWZn/I&oe
<XӼy
m@	kus2YT9*+[o322\F
l{rkٲo_E
u%,.o^ɺK׿U<x~Gtu[Ĕ$'N|O
}xɓ۷;%K8BoۨT0L}W8  ~g.]qf
S/1FSLQZ.~a]ZZVX?P׮y%H>I*t<p
7hŊ/?Q:t:vdi$sv׻<NJJһﾫǏ'_l_'%9ְw/۶u֒]1`1tp`r)y[V}-2OjjUݻwseV畄{Gll#22>~~8p@v*/    JoZ)?;w*''Gڵ+4}ժU
rtƄzj֬Kp4hxEFF.s<oIuu%..qHHj֬'N8ʾrJ\kb[%x3ƨKE_oU@Un]5n*s<qϻ}'O:FJ-jD>t萒=N_uWjΜ9Z|V\LUREw+˲4vXeffj֭ڱc$骫СCլY3IҊ+/ѣRZhBL(!μbݑ#GGDDLJ-/[իW:h	
w߭_][.kG~M.u\!
M70-ʘF}ܲ,ĨiӦZjy3ǏWtttZ>\֭[9s8FY߿:vSO?idQ||D{TnoeWR%BB~]s5:uf̘_|1͗mT*&x  *$K~Yfj߾OqZhbbbcyxx9rDQQQZx^~eڵKk֬Qhh:t蠡C*&&F89qO}R|+rWc
;m]1`i(Πdr@r)yo/uTw꼒܏?X3f)<<\.V#   @0mY+M6)''vnݪg}eZ6mWi߮رceee9UT~{(ɲ#;;~j֬Ծ{=~^ŒcRH'1<W]F	K/V
"q=Sj"?m g_~qرcu5(&&Fz<=$?k^zI_~TR%G}Çk.-X@Cʕ+qF<2ou,ݡPatFgǅAPoE,8lEDEQqAYAf.bK4IiM&Ir}:̘ 5Uw}x
K*;"NbuX4n["9M;v~UY{Niii:s+gϞ}1cӔ)SԹsO?T|x)-z]?il9E^͔djO6v&''G%%%*--R-..ց,o
P߾}շo_z뭷xbOW~~~1bnΝSO=U^xerp/yꢏ'͞=[k֬ꫯVz}ZG]v
V:jTzJ^= "SIt`2eZlCiڴi4iR	$UU윜v-\[nB?zc)///XyL?sp!U,IIq(j75fX+6bu(*<+!+<mѢEoչsgۼkҥ.]N8Av]=z뭘>7oaU쾻   H.}<:1zjuIݻwo~J
kڵuQ^x~`h#p޽{'DI4atg*;;['|vޭ;SNԩ:t蠅_mU10Z0!ͦ1||d{tm~ŻG3PII^{J_~}N:tjӦMfժU;v<vO?T͛7:uW^yEO<vz!]vex<r8:3uKk袋j*I+t諯*4tMmyymVeY~_nO?z'DxiiimK$]vZh+B^Z֭_^tzzi	GڴiST$tq$^pZ6	~>x9ۙO?]USfΜٳg[p
;%N\ѣy<}75n߯?\\r<`X65Vdi>^UPPΝ;{
nu
0qcH#]b  ^XB
5j(mذA/r	ܲeVv*ۭx૯ܹsu!޽#0ԡCtMj۶JK//_|Q;wVNN9)+sE\`Q۱F¡s4eeeڱcQh\S	e8Sage;P67l66lP>o<hy'UwhڵKeee<x:t,xoa   YU\\ѣGGk׮jٲV\?uQ1bn5J]vJJJh"뮓$uMv]w}*<xP>hκ>͟?_g}I&k׮:쳃m9rdiiiZbnݪ+VLC?|BCiii:[Ǘh}PsmmCK.՝wީ믿^ڵozJ1#I4h.\LuMZx?);;[
҆
4tP]}j֬x
-[LCfYgŋnS߾}%&_N?|C={նm[}'Znz)Z>̙.@q}5~xMtWkѢE*//g~I?~u)֭[b
]r%-dggѣտ]|:餓TRRzwt9hԨQ5SN5|=7n\_{5[N7|ڶmBÕeyLSvfE$f+ۙҥN^ڵӦMuV͚5ٳռysuU?~aiF:tPyyy|hBׯWN[j岪.xl6&Nj֬Y*,,vxgUBa bS;j@&MtE/ٳu%[n
6hԩ:ӫs.[L;vԙg-['W_f=\q*,,5\:?C=Ν;UVUzzn6
<X5қoO>DW]uUǻu!zggiܹI4Wu4M]tEkXSlR۷עEr~Z^9
+6ZkabHI14mTv(m^ DtRy^uYڳg,X;/\_|qίDcǎlzG瞋S    c=xKnxuƍ2C^xam6zŋ+hNfu+==]]v̙3պukIRӦM5m4͟?_wyZj#F{y?%\"˥.@#GVv֭͛;nN_0R:)xt:uRkSOrHtɭMt^ov͛s'O?֭[kر߿n5nXO?VX-[jС|~~y͙3G<>֭[k*(((;sL-ZH'NQN4o<I&i޼yzG+??_СC%I}_kjj֬>lGwygsmp
j֬VX+W*''G]vՍ7ިMFX^{&O|PzmKU:uꤥKjٲeڴi֭[ttI4izi9:x`Zl<L۾KkZX(Y~rl^SUX9͗8"xK/_O[+04k,͛7OK,?v9#ڶpРAlZz.]tuM#Gn͟9sfΜ	&t]v2e~am߾]
VˊС'xB]tQ𵉴ZlyDԗx#  UW+D-_JE	
տM<Y3gΌxnI=
լY3
>\e|>z!-_\W~~.r
2D/5w\͝;Ww:6mڨP_|qǻ뮻C髯'sk׮I4WZ˖-ӿo]tEkX2ef̘3g*''G^zw'|mf)A3)1
6mTv(m$;VsV\"5iD\rn9N>\+j۶&OoTnn~_iѢE2do߮Ν;ə    fx^y^n>|XwoNLylk0M3UZZ=?!SO4	ǤŻH ެWUSz|q3M3x<r*++SYY>{5hF~8haZ?~+RBڷex=._Ous\.9N·7}Qyy>voӄr]V	T_6yrQ9*JPzzzuouEc	zdC]0   _ZZtS%efސ12̔jҤIڸqcLT~<<Wr9tE~ሺ_WEvѦ;f"3\U~92|fAVmt<ZUڇz   hH$3'TXCNS.K8%j$]:{mq8έ_ڷ]=2<^ymҧѪN'[$sH"T#¥X` @Q3<<(X;   5:*Qa&D`LoGI9%jUY>oZn'Int9ZS	a"#.|  j>Z2SCb(e2    Qm}#L
"Xƚ·Z9^.xwoZ(Y-,<>9Z6-[I	HTy j0'[߾})1$%`=`T   P1^E
3f5|R5\K/k7&Il)[$:St4 _ Ȕ8i2
NJ<,**!   oՓP
S
ŬozjrS}}K,yl=y3[$ރH"TC	g @48z81&)w   CbBjx·vRc-sl7zcGi[$_־}HT(BH
k$Ga xԊٰ
16yHQT   P1^E~#÷mZ|kgyu-]Jdc~-	D  `zF_wӠۙL6yH]w    @Tx["C]t[gyUV.]>-U=6O'FE`=`@l=H  ,2q/n&X;   m}1~!L5ߦE.L:\nq
n"DL.C6  EaȤ癜!Ew"!   oK`B	b54|VE֥o+WlSen߸j[4`lܡm\y	"i5} `&k]$  Qc	Ԓٰ1$5HQ&    *7̈IN÷n+W,Ko@zys<Wzr$[$1I
0q5Ϸ  C
Dr6|OOR2
"eQ    Cx2dEn5֖%qn9PS_WxrZE3E'	I
0U_.  L&dCʢ-   PP=	0W=KQlʥ+~׶E;N}{$w t{\nx"P&n$0!  $:V2<(**!   oap÷^5o߭_鵭Ĺ@zy>3Ir{e6ϕ-R@$*
k DD[VL
1$-6yHQT   P1^ELqX
ΟUlnOEj:{gT<GiOu8n8X$B  kK5z ΤdCb    Bx2dr6;    IDATvlϷ|̈́oB>ML=2!tp8"qI
0	 ](  8u7MFI`|,   P񶾘a?jX
߶six)7oEJ86)&y2čnx"P&nb!  Ѣ_D0dLNl;`   %0
!Uh%4w$	rr|[Ź@x~>7=u>1-RL$ەm  KBǝ>Z2+
10d@2C*޲]   Q6*MB.`FfDF
$Yvhl_vи/:[$ʡ-RJ_O$Rmo|l-%  Xfq}jb7YTN&g eQ    cFk%p0>81cH+_;
~2#ެ\׭^
yh/a_T1~}s[%ߎ#30ߺo#N3T#:/|،:̬zn-P;ߦO'㕚C@2	
.lzcPZO!)l?]OQG.d/*{|-U_WuHOUsU^_Q.ZH}ݣk̟'~[ jVj[w
~}E?L
I:_umGT_|vmVѶhZΚr/j9Coyj_XۘN\wFŻjGq幋jǦ"U5ov ǮqL"~cXzΰA
eX[屰[R^׊|ws)w   MVTB%6Mh҄zd3$Maz]ez&3MfE^ўdx-\7L^uyJ3L4j_qm׬zRrq?^yuCIJogO()^<d誱_h"ذ]!,Gߠv-jݲ@	l6SϿS
o4P_ȷWo`a}S6CR*oH?}@.ozy}53ryTq{+ؗv{oXu_'u}]}Hzi}GvNlc  $NS+^=J'?4`.l(r~Bc}(
\竴%=]fǤ]Cq+߬:Vs
[^38~
,o
Eno8N(cLB.Ϻ7˴+5
>!)dj
W6}<ExꗵyoaWv#6EX._5eglOuy;\u;*>''0lSq
x7    >cB'epbTQq8rݨB~	o׍
^q:lFUu롫!?lt5]WlƑ_z0]u#^.Ex&5nҔ&.!)˥m푮^zG
q+5Q[}fSZZZ]o_w};@'P=>7vRZ}ʷa!+v]}#v/B	=5*+P`bOZqnx,hl߮J]	4+p{)/GV<nWV>!P)  	d}EwW
?2jz`;-Jk
}8"iVZqAx\uxڐ~
wWK5+XiѬ]!Q+8<UCd+M&B~V~_VhB!K>>oo3!y]
͈E|U͋<<6~B)'t|T>B9tx<f>88></Ry_JAr&U-_3Zհ|ZV^kiT''*-_GuOU;td5    oc(tRwNLn[Gi4/8g,N)sZ`q~7
$Ok!iJGv/XQ)FլV}R<ŭ?<vFP	&5<^sBHY[ĉw*//4j7'# X}/B\sƌSE{tD~yU`l}DGzzc
 @-0gQʫKGSM~}U*2>H$-[LկZBBoDxG
]ښPCSNRqEb]lSs
x}<k6lиq$Iorrr~nV>XBKv    TzNČaHN!.+zlb묆og^S:4x=2x?Z 6lWq2<^Y-RZta7vDGvGs8h$ﷱ=o>r Y\iH7x'tyMeYDx304S}FdOۼzJwcYٙlb(|Gj@@   @E
lJOKKeba
h&6B;^T:km"~ܰCWO
J@HG/ЗȈsk_U}6.[  fdv{O@\.WˌC*O;6m^=q:lbcTu    oc(tb&tʤBoÿZI
koOj'=0Ԙɾʷ׎Lf%|q犙2^y\G)/	J''G^`[aە$оYh-`,b'[v  T)tzQh?>|
:N	$t<>`.8qX`[[v,۝Hۥ?    2*HL$
2coXug:	ߢa}2<<[9nˁ8pUBq+^u}6'fk	  Α'"Q2>`.8q1w?v{Kv,ƪ&}   ȨxC! &f*$c5|;s4nrlzn-6п? 㕚e+gɵnѠCG{<}G!3X^N  "0יBXoaC`.890w_;--X1߁hK    1WՄ4UDnX
Θ(2l1EaWj%(-7}	
ާaHBc9 @'-&9͋uv~FMx    >TgXa5|{_t:4=-b
;,<GL}^¿&HvH H<3Sx1^'nY?l     )j$QvN\.Nj
]62㝃qn9Rv$)Y?J[  	_          հ-$d%|۾]+LWn)1E~N}t2=^Ͳ5hל-  ۱)_     H    >Tof('[rFEuR0t;-  `D@     #   o4÷w+za;r$n?Mǔ,[M	 Pk1         `o4·zGrM=&[wkJSF,5}jB  ԁ)Ͱ          o4(÷ɖnS7|-v6s<6[n !3Xv          |x>|+
oE|v>8_הYLB  5C}&      "H   C[ 
25,d!۟r$onKmG)-[  #R           ,K25lrMt3[Dz|c,KH dD         @5xAtGr%ԈEBC- C{         C[ 
=w·4z-$}nv5ek-  1`D@     #   o@·'w*+Kr	BڷnvCY:-  1)g          P j
ߦv0GYYmjԨ6PGnYm  b'5~         @TV·g;re1u]zrԧ}vhTZ,O"t @'c]     DFb    - )|rԾ}#WY<i]zmu;mþJY:v#t @=0$	ݧr 	      2t    >Tߺ\m#eeI7ۆvjUn[/&t @}aD
          P `5|[xGcefI1#I6EwNwmL^4-  /         jP a9|{g2y<ƎP[!-G]zNRxB  QlǦ     "#1    P jU6Ӑ-_m·u;Ջ|,?[  p)8     G>    *V·'Ŀ*JFP6}}mz*Y,"t @|D         T ot{0|kꖑ]·Iu@fYj
B  $iͰ          o 
V÷҄mmz{b6Sm^lB  ğaȌq29     @d$    *@o23
yܦn}8V|6scWÄn H?!4\      DƑ    P÷w+F6}vsc2L_n H H         $*@-Y	ߞ>KݕL15~NG6!}v=1IҚeDB  4L$|         T po[з}@7D3֐eRZL-  	+cSv          |x GԨQmY<F2Jqp·	UЭ|ۓ\N dD@     ##   oT4iyI)h)3ːc뽷ǳ
v럐$3Ձ-  	+#Rv          ,- ԑ#<x@t)詧I'7Ҹ6o'޴]ŞU;!OȐTgD $=          "- ԡ@(%Iw֭[Mr]l2lMw퓒)fx5G49ڶm[  aȌq2=     @d$    *@۾}


d5j_|Q{\./|{R÷n֓=vhː'eHr4TpﶡC꧟~"t @2$	's 	      2    >T:w^KJOO/:(--Mv=-[m!}=mdJLu{_A,$}7:t([  R,         C[ #P=o>l6\R]taJKKm{bE6u	'˷+d2u(m\..B5J/jڴin H0FK$     8b   P @YYzݻwKϟ^zU
oVmsbL:ꞛio8)N:N9M<Yݺu$qڲe[  HG         X@[ 8Ji+͛%IvjI*#m]x6c2Ͳ>i۴R6Z<3jҤLTAA 01a?          *Q[j*IRu7÷&۫I#|{WlӖE!?Fݦfe˖***fӾ}ԯ_?yx/  01Nr)     @d$    *QX`f̘!I:WV÷#'RFV<SGw	J2Hi<S{oV
>t]wI6m  ː'vl$     H    >TZZj
&Iر֮]+Q},o'VvQb<xv1W,S>[mj~{I&iӦMZ  ǈ         @"- [o+R^WZƍk5ol4)#	Z۵yJ)g,%QnԪU+~i޽Z$  PH         o Jիʔ7UVQ=Fu[өt.[#&\<ܪV?+Q+ݞQn6mիWnkKv{  b;6S     H    >T(|wѣ~9]V;vcY	߶n[++.$|[ءۦڇn8M>]uV?^  Ɉp)8         `QIIz={HqwyG*ߞᓏSVn<n0	:dpԡۀѣGwޒ3gj1]  YG9         `oǣm۶M4uT߿Nq'÷F^o<;U2MS&ͼfu
Xtڴi#I8p>X,
   f#S3'          D@[ k%ICoMi\<n|Gx_Oԫ
nOAVf\.<xP}Uyyy,	  T0d89          |x 5<y,Y"IիϟaJe5
on=SF5l&tpiiْ;wjԨQu,  f?!4cS      DFb    - Tc*,,$uEEEE٬o:e=|6o[
.|wQBMu܋nzHϟ+V   k         HT*lܸQ$o^/222bV·O)m7wQ%ӔiY/ۀ%KSN$
<Xu   A         P
*@|rkƍϯ2]Xzkc<~}|)g1BcV233feff_~Q>}TZZZg  j۱)     DFb    - ٻw.:tHzԦMzo퉹~	~}m_IιC۷ג%K$IvСC9  @eFK$     H    >TP=o>l6K.qkuSOPV#_Ў~z52MufC%I=/^            x ~ݻv-I?zVY
6ҵʷnWߴ%e·=^yLӔigvnf͚N;M4|pڵ+	 @C=          "- H2MS͛%I~VUzr򸽚ux8z8m	JК5O    IDATkԸqcO>:x`<7  
aȌq2sN     "#1    P $?^˗/$_'Osd%|Fu÷;4|rۜ
i&).. h(Bhl@         C[ 
ނ4}tIy睧<-{++.۫&WvWzawBn.Bz뭒իWkΜ9qi  )         D@[ 
5l0IҩkpĹUճޓ|[Wz҄oY6~N=k$C'OYg%I3fn  Z"         T`[*((UVK/)777Ͳj{;(3!۫I
ݞ=jrBӄJnתUԴiSK/Տ?f b;6Mn     @B"1    P@T\\^zDڸqZhfEjvPhvf8<>󣟓ir5qg.iB-ZPQQl6ݫĻI  #¥X      @dsD   /*hp;C?֮];ƻYb9|;2s򸽚>cC$a6{뮻$I6l   RDG׭          xA)))QϞ=g\w^uTokഓ(}-a·S</k$]{҆n
ս{wIĉe˖6           "-@۶m$M6Msꆕ'6i!۫y_q~PO=ݦ7I׹;?C}EEEjժn.r߿?  'c     7$    *h0
K[n%-[V÷Q퍯-|ݚ\M\:oi
n6mիWnk߾}ׯLNb Bhl     "K#4   @Q@0uT-X@ԫW/͟??-
÷oܤ^^]Z7vLTzOmgӧK6mڤqn  ɋ)         D@[ )o%IݺuSQQl6뛿dc5|;`)h>t&}XOW1mܔ=Z{$}ڴiS[  E         @5x m޼Y$o^ׯWFFF[{÷*·b}.L<x6`ҥjӦLT~o߾x7	 $۱iw;      b    C[ )>P޽U^^|mܸQyyynV\<>았owܥ5m~jzBJRvv֬Y#˥/w  H*FK$     Ȓ
   P7x %ݻW\p8jӦMUﬄo9W۫^ևv\֌}14mi9sHl٢'ƹE  $HS          x 8p@=zо}"u%͊uVF#<nS{EΕiempۀ뮻NӧkÆ
qn  'f=3'          D@[ )\{ݻ%I-R^ܪJ=zxGݱ#=;%yMSy.߬U~
,YDr$iڻwo[ @11NƦp7     ਐ    |x 8P7o$ꪫsmOSfSWmu652\1LYFu饗<  8     Yj   -1~x-_\tUW{sOxnmަsjѰڵgZ5n^SM\`YnCo^K,$mݺUcƌs  H|H         $*H	,дi$I=zТEܢrlUoe6oonQi*K>Ѝm%Isի"   /         jQ@[~
&I:S*---έJl·@l÷-÷۟٭gƽ,4ROB՚5kN;4IU\\ b;6m         |x m۶Mzjժ^z%eeeŻYI!<|vDYF*xte9q{
/*·۞ی<.zහnkp8f5nXT>}TZZf bH      5#:   @eTճgO(//O7nT-ݬb=|EՄo=/L<.ҭemڴ%Iv"  SGtK          X@[ IS=wtjرco/{2·}Am#}z+JM\UF/ԭ*IZx{8           "-SRR={jϞ=2C˖-Snݬf5|wo۠_ӊq4s3$t[KSNYg%I:tv CftS      "#1    P@Rz*((жm$I3fХ^V+'ό.s4MG<z؄m-l6ZJM6Uii_~%  a%8     Gx    *H*Æ
%I#GԘ1cܢb5|3)Sy.qo	ց-ZH6M<xp @`D
          P@Ҹ{`Iҥ^YfŹEm xge<]6lhT镂nk{_*IZbϟ          P
*H
˗/ׄ	$IݺuӲerPnpuIMſWK6nĉս{wIҨQs6 ۱)     H    >T6oެJڷotƹUT6Pt#aHZRyyƻY  ĕR,p 	      2    >Tvޭ޽{\-Zƍf55U
In5mTWng} P|DJ     <jgm,e*

hl^PAZDAAYl
"ׅPEPQ^( \Y&"4!I6-IyIfɜ3g    @~%''ɓҪUTN`Uuk4kL'N$}G<yr#  va=         dP"<yRڿ,Ըq`Uj9u~΀[<x:u$I6l6n  "Ð      xƈ    JsΩSNھ}$iܹJNNrT2}0.ngSյkW;v,! P)op	     3   6dPG_}$iԨQ۷o#'oX;2          @I@[ %3<J>%W_3fH;6 pb/         |@1{l?^s9"d0`z-Iz_9"  !s
     #    2(/_J7n4Y, G<sQeZuw*===! P,      <c    `C[ Ai&CVUuѪU찀)22Rʗ/cǎ{Z )W           jϞ=j׮Μ9+jժVZJ+R׿$I_} G @	ؙ          @=zT:z"""|r]y	=z#<"I?~> G @10=      1b    !-8sڵk]v0-X@-ZvX@HyWtWK.A 1B{n$      1    ؐ@Zѣ6m$I2ev䨀SL-[L:q:wSN;,  3R          %oj咤'xB>h#BWڵpBIҮ]tw9"  B#|         䃌 Մ	4{lIR׮]5iҤ GmjСKjڴiA @
)     xƈ    5l0IR-`-_7Nח$=  ex/     W    2(_}#4uUWi劈vXE#,,L8q"a 7?#          @m߾]:uҹsTZ5^Z+VvXE+%IWϞ=er "3S          < -JOOWrrN<(ZJj
vXESNz$I+Wԋ/  #Ðs
     #    2'OneXƍ;,7i$5kL4j(}
  ?0B{n$      1    ؐ@@;wN:uҖ-[$IsUrrrJp}GjU=            (	x  飯J4zh7KZpBcǎk׮Z           A[ ~j}rD@Զm[1BjA  )     xƈ    _^|EIRrrΝ䈀m̘1[$I&LЪU  Ecx/     #    2˗M*--M%QX`U&I߿N>  (r         x/~Gu]999˴b
EEE;, 4gI޽{5| G @t{          }@H;r si֬Yرʗ/~Z7/ Ζ$]wu7n6mڤjÆ
JHHغ+UD;bqi:u*aHvZ]y:|p)*V2e;aX9     ?   HxG ۷OV5`߿L8p@[8p@YYYm۶U۶muGGG3ĉ:x`(YCYDD+!Đro
)     xƈ   &)x    H         %-    b_           -     ܔ{N     <c    `C[    DW ex/؃      <c    `\.
/_]vӊRzԾ}{;;w٣ѣG1Z jԩ駟O(111&LbѓO>xmҥZrΞ=0{G7xcql߾}3fL-t嗫K.QFsiź+լY`pfұc4b9~}]{ｊ
`tr         |xK[ ޽['OVLLZlK.D6lؠ͛7k[$vڊr ȑ#Y]w7o.IVĆЪU+]uUڷoOFr1¢?f]veھ}m0Pvfj=         dJիW+22R>mVcƌzٮ]`	ʖ-cǎ?w]ժU+ S<׬YSl} !0dxd,     xf
   $2ʩS˻~%(%%E'Np6w\ٳGG$
:Tz=7*;;[
6T޽f[NYYYWQ*UT^=YFM6uɺuvZ:tHijժj߾ˀcǎ)--M;vӧ:QFbbb$IӍd}x۶m:{ԩ]+tLkߔ6l(]K/T_=zK/u,'++K~;?~\+W֍7ިd~O5j(eeeiڴi;2e(!!A]vUBBBevZ}:r#wܡpV>{NZfvܩHp
~P2etuשG
s׻wo}VZ;bu+==]j޼:w2ehʕ%َYZn%!sSn9        MSy͛7Wzzf͚hdw
7cǎ+<<\ÇW~yf:t{1
0@;wԒ%K) 
K.Z̙3^/;~8p>+WNÇ%IGոqguUPr4}t}wŵI@gΜщ'GѦMpBEEE~K&L/ݻPr+_$effjڴi2C3f8$Oڹsq)66V&MѣG%IzW_覛nC=
jѢEZpOY,Iѣ~aI[ok*99Y
ҝwީtZN|ϟD=JNN֊+h"IsUf4rHjJ}^xU^]ÇWvk.-\P_&O{Wk֬5O?TԩGyD۷ڵk5gI_.]H;%g          J2_gjٲeڼyJ_WUVw+WԡCԯ_?EDDVZjҤ (H{ｚ<y>Ctҍ7ިnݺ9^YyܹSUVg}gjȑP$kK/EYfŲM%K#,,L_~zK.Dj*1b%I
6㕖'xB_[nő5>>^~]C+W$s=矵rJ}ڴivޭk$5nXEV-ܢӧO绮I*T8={VNRntM79uq<Ξ=>LZR^$I
4Pff~egg7o\7p$CZbj֬Zzu}-[:kٲc
;Ї~o].1gddhٲejҤ*VYfiΝ[#*UB
>#|         d.
[֍7ި];vЎ;f^Z={7u^͖˫jժpVl|iu[nMAy뮻$祧ڹs$9/JLLtr$0Լys-\PvdS6mԨQ#Zr7o{G{o߮5kF.hj}:{j֬K.DsQRR4h;n@UcЭd䞐7"##nZhUV_~u]ӺEDD'd{$r{n;wNM4qyCС#]:u\=<<1ӱAƍ]׫W_u9osٮ
b觟~RݺuVF=7S      LIt    dJ p]veԾ}{    IDAT_z7`5je <)S&1𯔔mݺUoF#GhڶmLTժUpdufԨQÑ1qƊo01ݩSt1=#s)UTICъ+?jݺu
S&MԻwo/_^g(ٳGbzEDD.w?/^{*<<\5kTtt$@Yo&cLveJ|l<r$>}k̳g'Nx]OQ%@S      Q   lxШQԧOO;Ĩ]vڶm8u-{W&M|jӕ{L_~"""t1mܸ1]TTN<g$9֪U+@ƍ;Ζ/_^\rzq>ЪUO>2MS_\R111Оꭾ/r^{Muճ>5j(<<\~~'ebӟ{nݺ>k_!@rIڵky>h]Q%WHr         a>OIF( UZU+VԊ+v[JW^ܡ(fW^y7hO<thBW]u"""$I۷o$7ԭ[W;vpiKLUJUT_Ϟ=ٳzXVZ%Ţ-[h:tP||vիرc۷Or<?~vܩ;֕͛7ĵ~z=;={t9o^,jZ=GBBʔ)'ui̙):w߹<߸q,իg+BErʗ/EΗe/`g#          x@[=ܣ3gjԨQjҤUSNiڵknV;T ŠsxB
X֯_EGGkǎZl$)++KԾ}{mڴI'O߮riݺue{ o*U:hɒ%Z|tviƍ<yڷoXmٲEk֬QN+B={ڷohGfmۺcܹвe嘦Yfocǎ^~gYF[VʕU\eT4MթSGaaaZblҭ_^$ʕ+mjٲeT
~}JNNV勥oܸQ˗WFc]V;wvlo^˗/Wvv6l-[LSK-_\M6ե^Z2B	g2<2{N     <3ŏ   Rary73<+Vֆ
ڵk_~jѢECPL"""Էo_M8a8p>
W54` -[LvRvCjɒ%Z`V.R=jذa
̞yʕjٲU~ZiiiZhΞ=8}ݺ%q>cJKKjժO>jٲc5jM7XNգGH,4ZJwiu+WN۷ך5ko>M0A'|S|4dM<Yve]<:wh}/UR%uQv$Kѣl٢Z*Ur){o1WPA_~+/_^JIIQ
$IW]u6lɓ'XF~Cʽ!4r
     #    4ϧZZVVV233V_[F^a+3V /֟T.W4hPl֭[ѱ~3Wv<x0(;wۧQFezYfGW\qbcc|tʜD9uk*˗U\9-[VX,2C7szsu]uE?ɹ/  ]6m*kIIIA 
WϞ=%I'Npt ._$emxEe/e˪L2X,
o   ua>OA2    bG[          }G    @ܔ{N     <c    `\}   BNժU;($      1    ؐ    P+G          |[2    ,`g#          x@[    @h0=      1b    	yJ>!->>_^o$iĉypߛ QfMYBsq1B4tP%$$iE(J*y1rH9rDm۶U׮]NP{Ch`M     #    GƑiUT)<vҢEd}BJJ
=Oٲeh"IR~ *[ʖ-0JUVi׮]ˋt 4         (	|w@s1IAJh9h  F         ȇox:qqqA@qZ$A  O{nf      1b    !- xN+WD[ @bx/     #    2*33ST\ G81 P+G          |@[   ,`g#          x@[  L2g 0=      1b    !-    3B{n$      1    ؐ    PqF
         $ -     v         2    BH`M     3F    6d    xH      1b    	yJ2,[G֭[%I6lP6m>@W^m$I6m%ѣGիW/yoڰaC4hW_}513R jƌy^?uzH111yIMMU W^Ç;ر^;vZj     d.JС>?~\_~e_y!bXO8AJ*UQF:uiݫ{y}ȑ
n   %\ǎ{<޷;24 I=4j(_^Yn]ڴià[    @P<%oV~Ty4hР E8cFPg̘1/<}-tJÐs
  BEddMVM
 Jx=PDFFj̙@A1    >𖫏Em̙X,>MkX
5=k̙FJM0TI&0" 0)r	  .](%%SRRԥK F 3hРB%<x0b    !- I,>MZ JD
6̧iKJ^zvĉRJ#3R   ϦOӋ!" ]a}kĈ     #- _~J*3fL1E8>ܧOLd%uRRW<   SG. !))I(piӦt     F[ 1116mZL8-"S'C&PڞA}=7S  
$
4#;vl)))ҥK1FF    6dK.JII^6mȒ\aJLL^jjj⁒_ p	  ng XT'z|/&&FӧO/ x    >}z$Kp>}z} x3fL"'g\9  !.))I}z߾}	@HׯڴigyFA     x <?U=l0 \5zhLBL6mԳgOצMg`=vfj=  I&T{*U4iҤ F 3sL zǃ     yG?UÇ9" aРA#F9" E1qD@۔u%~b2<2{N @(s'.11Qv<w 1    ؐG?U=e:Rb8>2e`ӧ;/)r	  :OiFv8 Ph#FP||6m; N1    ؄<%oԺuk{j׮E
mu?%%zKMMUjTvm>± pqX50f̘!
zњ3g4iB    \rxSV5a;Jc'WyQo|C*9wrv -  (IpF;Xz$1     -Ĺ#0<./xC
u860in\)|<  E8/hh$    ijѹljaaa.sF۬_p^o,Ro|| (MkMtgx/h  ,9S"GPю_S    2ޢ;srr4,edZ%ӔiZ%im'`Nί){=k^7ZzM{<>NӲ<MiN9o|N](VngOeXVݷxwݷOi_T9r;ǇݶS9x_ Sa2dRa(,"'?dd~~'KOX%ֆ)V[9}.>=w|=Ӆtُr0Ӵ矻gN\.ןs̝y;6wy]N~
3I
3$#ʾ|c\o
ùn2K8
SuKSY˭YNrtcܞ{s:ܾ{roK)>u6iy/c2.RV>iݶ:̰}F<QeBA g|,  h-ԎsrIǕy{=z>~~:y'='ᾮ3-s'˥w{*oYuOQ<L泿Hr80$Kڊ|m8/=</|+SrkÜ/í^>{G}`^GO=~˞Εx?o[=&~v/an"EH.     ED[S);;[ZNMT!ɚh֙6]s;GsN޹`<|FdZmܗDlӾ9sGyr>g{9>.yzn-<_Nqr9xO3O˱^ywwu3w>kӔ5,/$!ŢI';;[_*x.*Ks[;yL9m:g2VYȭ5'u)>3)>oG>c|nupj:7Qn[M$4
sd(M&?fs=:.fr܆}pKyoMׁ뗣.{[0ty|/??_w;+*|0/zXaon>ke>~fM(!O9hVz#  _q}qq<f:}kǅ9]χoE~?uBv[5)rsyZzVǿ/k9j[NV6hl@G:KnK1_Xu~|~nz
__U4]{o~yǹ|ʯ0s_K{?a﷐LeXe͎>
1e    ;2ޢHخNQP0],)֮:=e#?OqD)N$_⑇;Yahf~e|say|sw*4v⹰5B<|B#2%egg;~\$pcT4UjU.}Cgw!ӣ󼞖c6Α;O<b-}~}w
˪0hH
3>6Yar?w^IJjqjj?w;žeuvz

Nu~h|(sw#C28By
GGsModVݒLnXsn;$.haT`MX  ,{_jJ2T!e-Yǁ~qZX4x7ǝz\g=xݧs.x+^.O咷\rK>ruȯ\m;f=2}VJ!lUِVv|?YAzXv[ŗ^`En7rھx+3+U)s^)#L'vE    oQ$䎁k2hrzW` g.֩ʐ"AxxVZpq~&>PB~y2͖{QXZꍯf^2\756ءΚU!IVNN,c-
~Q/	 xnK;4w^#Ӵ:8/]СE\$
Tw8]1#    Gpf~r ;Fbh~ٲ8N`2<s),/EѠT}:f @hs>;a
p_zp}ގy
     
d%9*}`i|϶ݥgQTܟg+ y/6;rR6#D1 P,c?Bs_ĉBC~
3    (2ޢ\Nȋ'_}|iXs~ f7qW?2Ιdh;!e=   d8(a\A8O~ўW)   
oqA\B+4Ҽ(
å .e!$J5@ xpc:w!!41^    P
EoQHJ5o\.h]^i?@  @G 5/(    ~p$ P[R;
x?XhP:kVLG   Ơ!    p$ 40T
7@d-<(Ȉw!3
   {xcr"~Gw/   `C[{		%(4jd'Cʽ!4
   <@   !- Btxc {Ph('   o:/    2?~%Vw
bis
py J'_B   <"-B)    o `w_(I)4(~	6,s
   xo>P~Gw/   `C[ (

ˠRKdx/   o:/\8{   2@)Dǈ2Ro\
xs  |@    !-H@(:1%opy J'_!`
	   /A"B)    o'H%@h`n.Ax[xP:Cf   D!^   + 4J!mQh(ȈO{Ch`>-   x=PGGw/   `C[ (9ǔAfPO4'   .2u_    /dE0<Pp1
Ƨ.tJ:,6h0P@*yB3	K)>6  J?xoJV(Ұ    P<xOڵKIIIyZhmꩧݻ͛7멧c    IDATkٳ4i>s/;&Ԍ7N;vʺKFWpIBԛB3][oSu0`֭[WekРA:vHI&uֺ'|LwK
!%1 p֭a|駟V޽ov7. *޽{իW;]ac,}JJJ;s+VyŇGon:u4K,ѫz뭚2eѴ4%%%ĉNWv_~Y-Z?Pಂ]F   	yJ>"HRRRtu9={V;wŋe-^XQQQ>//--M[ "-GՂԸqc/;lW0h.&Ph7V^ϭV8ŋ'ܹs=a}"e-X@j޼ڀLOO
 ͛+ТE\|;))I_~y
cAZn>}rʩER/>dEp,]Tjґ#Gl234s_XJv=X~'NҥKck)pY%hp#   l|xK[Iծ]<_~;v֭[} 1$_o_2Y 
zNvԥK-]4 7V'O$_u
r4ß^  pQJKKUW]Ν;k:rϘ1cn_3Ƭ,G-Zi*Uhƌ~[4M-]Tmڴh"oKɮԸqtM74}.#/    2OPAJ$ٲ:tH3f7|,կ__
r܅<x`OP'%%饗^RrrΜ9yi:tj֬nݺmVݻwƍm6uYה)S/^ӯ+[n߿cL͙3G<5lP
R
$IÇWvvbccl2]z饚?O?{$1Bs/ɖc̙ڶmղeK=ZrrrC{|ʕ+K&M>@oQqw^uU#FҥK}v*%%EbZÇꫯN<Dy_h>ݻW*URǎ5` X&vW֛o~Mjڴ
:uHvءiӦi۶mVbb-[:i&͛7O[nUffT;C>c[_-ժnݺv7o믿۷4M%%%)55U			˺P\ٳb
=zTkV>}"W޽յkW?^K.զM֭[멧Rtt$_v[fΜTM:U3gސPB}裏4|ٳG;C)""BN*Ij߾N
:TiO>ѿo-ܢ~Q?:tPݕ/BO5\zJW\q#4-ZHV.RO۷d߻;xf͚?PLLZh'|R+VtLW2n8-^Xt]wzOn?FȯNJҳ>3gk|#GN:8pZnn2enݪX=#bE@XB3  .:Zz飶mt;t}1M8Q_}ʗ/{_Ǝ+ɷsfw~nF=3.TQsZÆ
_-ŢoYO=bbb(s_~Yݻw׋/>}6lؠlկ__>c}Ypo/u
7̙3zǵi&5m1
7ܠL-^X/իb
1_:ڽ{wٳcӧOW˖-޿(I[nռy?{&Sv,PiǊrhh    _x?
G
^G:geeiǎzWTB5o\m`}'a^bE}z衇oQF>|&N_~EӦMS\\5p@޽[G8!C8onwܡ5kСC:}^~e=[-[Yf)!!AɒQFiJMMե^7аaôdoFstNw*]qzkjӦ$χ~X
4رc_]^xAs&MkƍZ`~a5lƓ'jСz״yf
>\'NСCtK.Qjjxb=裎/Iz7믫gϞzǵ{nM6MS>|n=:qf̘{LK,љ3gD7Naaazw5x`}ᇪ]vءUV;vК5k4o<ժUK)))r<v}QUPAnsSk׮SO=-[jԨQܹsu}wQڵWyA=74M=Կ5jH|ƌ3gΨW^~oƎ駟֎;4j(-[VÆ
K}9s(55U'NP:uސL:{Kv웦insoW_Uǎ5x`ٳG~wM4I;wVvv^}U͙3G񒤩SwU^#hz7e͛7Oeʔ}ߟ;w:uٳg+##C?aׄ	Էo_*##CsϩaÆ8<233u|z~IgVXXF-h3>ի^zI?]~Rmėvoџ_|Q\rf̘aÆiҥӾ}4` ]vezӧȔlo97!31 pXj233աCꦛnŋq>|O>i3{ӿu	&h׮]СC˹ݔ)Stkھ}͛'Ţ#G晶@S۷z-=zTV-uxoL<@B}GQ5kU\Y-rx{T&M:L<YYYYzkV}Y[{ʕ+5k,ըQv:+T]AXj.:L~   ؐ~d>}kaaa5dGw}WG{ｧzIz{ｚ1cf͚jժ)::Zeʔqd|ϴuVM<Y7|$[{q\\{9GGPZZVx	Gx@K,ڵk,8qB>u؆?^RZ$?^իWXA1qqqM*U^Sٲe%IM6UJJ,X(!!A<ynVM2EM4Q~$ƓN:9еhBԩSտǀS2}8կ_?M2E[oGS-k*;;ۧ2d~G8[NO֞={W^L}W]u͛gJ~g5jH/UV믵i&h͚5ڵkf̘Y-[dl$5uT]-ZP.]4{l::}Eǈ'/_ۯoV4dOŵhBVU3gTJJۯ{JSڵk/W_}aÆ|k]hûcǎ銯ސPhk׮ڵk^z1ɓ3gn=loj4d}jҤvڪ\:O<!ֶ'$$hZ|
'$$8HR>}4vX?{Du=Iv]YDxA(
^@VREE*Vֶj)
,>"("AA"~"Y^$ll6㱏l̙3眙sQڵӺu4h 
6ZSN2dVXa]rnݺu:csΒN;Mk֬n-WҢEq6m8&VϏ8&|Idnn`ϪYfO}-Z+B<F|IRaanᆨy\}DJ&CBhj[c  ǔ)SԫW/:.Ӽy[cynx$g#%W^?1B;vLhB?|w${Zf,YlUgn5S+B|M۷O&L[nƽk߾}u70|>]r%]vYcG}|>4iP;xB,핗$WnnnC۷-[%KNKոkHUXVVV$59   Wpx4kn|>
8Pcƌ$iɒ%ԩ9~~:K+Vp|n͵4BBΝ;F8[hCI
N}饗4x`޽[_~MHʬ5k,A%ꫯR߾}}o޼N<D}ֲ^{zG}TǘO$oW^2MS_|Zx._\zrD5C\rnݪQ_JJJty9mW_Uiii\y
puҥKեK}:t1ǨEz?I|^x+W\0_^.U\\l+V(''ǚt+I999۷|Νڰa."OGhB{cuq\"iPy:u}嗮OFӗliiokޘ2RٽKAC?y=:եK71JJJ"V޽H/B@@wާO;V^B7Bc=b^Zs[o%Yp'psںu-['ﾳ֕RsxHM"d6mIReK
{aM_i߾}BθD  n:}WuA<xPݻwI&x1o<⋺1DQU!$eŐ>Z{u]37SXB;wvLbnܸLK/4moQ}Ϸڱ~w߭OHĈ#d=3:#%|jӦMR۱dTՎ>Lbh     Yx0R;vGڵӓO>)ǣZnڲecrO?:hw^h"Ф}Yluݍ5xʹMV4rH^ZYYYԩcBH6gI|Ѐ|ruܹADMϛ6m<kݻ%UN	otU/^uM8QԸqc]}:trrr4~xM0A,Д)SzuS&MTRR#Fhڴi*..VAAu&g{F<ޡ4G:QDK纞۷+;;0_kvMͩ70ԢEnI(7tnM0t[<zbխvܶm/[ʾ[ݒ@  Iڴiy}'2MSGuu[`oh	ڹs7n?q.JE}9<tC'\"dUywވRêTьa ^MJ{ꩧSO9OqG\UV'P_6;HR^^㱮U5~f7HF*d>7lxhRs$Ԏ]}M<Y7tSj<!^'Oo{L'|T	0xXM]Cijr&1_    ,O%-b|
ˬI}~I&jѢ~_~.$ͦM(;vHR6lؠ_=z믿c9F>OӧO6S&MH.,,ݻwkԨQ*,,5e]qQ]ӼٹsyhR$ԪZWfͬ]v9)**ҷ~;NR|yҫW/Keee/[oW^Qaa.kN?LԚ5k4{l?QofΜG}Tgu'k֬YDZID{0\g_>Oƍs,O˴tn17	3ԩS'}z4j(
>\okOB_)**r,[]vW4l0~=ZݺuSNNnݪYfE,_6f̘g}V7xbEPy'pBIS_9W'bTvMf\ӹ{ZHmS  2շo_pg=<yV3ǲc:c^ۨN$UKfI&駟"^_l7oжjT"?0իWkժU#T/]T/>䓈_g<!K,7]}4hTWuڱdӎr׉5G`    ( >y衇gy^ziݺujժtb͛7O|<o>Sۘ1c~M\R/B+LM"d>4nX;w֪Ut[]XXq?>Eeeezt6oXw2>p<b~GZlcҮi9sڴi֭[K.և~;Ｃ|Pqɘ1c4x`+++Kr~Hl٢se
u=Cڲe<uM^z5 ?jV^r)*))G}dkѢEo^fr]v>~+YIhݻ͛5zh8p@R_zcPo2k'jՒg|Zn5mT#Fڵk%)b"gx;^_pWUTT
6h:ShT?\^WsuLUOksW1)?ܑ~A?Cnp/8j  d觟~ս{wgݻSIIv(M֮]>sqqx{.W/Ϥwoږ$8p@Ç̙3Ss"-jϻ+ϧ뮻.땓I&Y{ބ۱x~z=ѣx3KոkUXxhPs   ADEF:#tmiԨQ?~n￯;C7|Zl7wa
 7iD7ok>}.믿'xB~:v>LuUW	xx<0a55cM>]tСp;m4/XÆ
ӽޫOĉtR]{^ΝwjѢ|A-^X4f5k4i3<S˖-ӤItwZ旿Ν_W[uaiʔ)׿URp/~7Nyyy:wW^s5n8<ݻ^y=V߉'*;;[g}7o=/|-^Xk׮M7$)3UsԩSuqiڵ3fLӴm߾}ս{wСCպukM8Qvr|[}ذaz衇4:tHǏmݖP9
#6|zsk:,S?nט1cԵkWk;ۯxD^!mRy<׿-ܢ~ZƍSu7k*++g={hر:xt"+IQD    IDATS^tW_W P޽~z:u(:#4cuE͛7ҥK5n8I׭O<QSLѨQԯ_?ڵK~GkR9<^$v27tfΜCoW ?Oegg'r$Ss$  ꍩS*??_~ԟ'}0`@DOӓO>nIӄ	Ԓ>O>oFÇڵkf&M$_^U*Ouw=ܣo]yyy֗w֭[D[Ԏr:3vv9͚5K7oV6mԤI-]T'NjOV뮻N˖-sLm۶mFcw+((H    $KoxjRsM:U.Ro^׿4j(1B%%%j׮y
2ܕW^EiԨQ|k/jz״gkN>C_~Ywu6mO<QǏׯ~+X"<;t77իտ~z/뷿|>
/SOՎ;ONӥ^*)DÇ?듞7.\w}W[8nڶmkǿo*//^xA{;լY3[8qZn;C7p$U'R0s=Syyt_|Q۷$=ZG3<裏?H.45rHm۶k}vM>]~_>O#G?cǪDZG4s=W?4n87QNNz{Nڵăȝ6j%nȑ#5f***RAAJW>WAAA\t"j6q6tI8pMӧk;ղeKM8Q'OV&MԫW/u]jѢ$SOg~[EEEի|Ay䑚<y&M?Z_M'h{N=}Qeggcǎzꩧ4vXX"pc˵e{z7ղeKqOXS]_=Nƣ@ǏwT^^~8~LM5+0 ^(..'|+"/\pzg[oi~Z?Om۶6lf͚e#}>LFw'j	IWG<gSW^ȑ#Ea褓NK/dF*oN\0"#ׯמ={tEE]K/￯~[snVȑ#խ[7p	Uc'DemܸQ\tM6lXFcwK    $a~;%($SW/,uՊ3LӔi*//WYYu!pG2yN&lƍ4h׿.Hwrȷu(KߏWnnrrr%+0d/[_%%%:txЧ=~Uq:o#ce6S1SF}W5Ct(S,R>}|W3m?U2ddʾ(;;[>OAձQ*5EǶVGa|>_mq}ANh  B@ _'CWtzȎ@]T߹*?V@k-b{}G<Wt'^w|*wXXh:Htg372$,c:/1  $ɈDtC "VXdHQR۰p   { 5p/   Zn @00b1eTLE44hq   e=@   dŽ$oa[9ꨣlٲt'13bȔIIx &/   WDE4A   @Q?
 y
GԛamX)   prc   -w`(HA.2

"p/8j   pG[ 5p/   D[ h44hq)	   1@   d!-H@&%og8K*Y!   b/"CPN    Yx$	NG ar	Dęa""V7,\   Ƥ#A9E1   IE)2;ݐ#FA#"V2RBS۰p   { 5p/   D[ hqy2^=d4θDs  "-LG    B[$pAU?mP"0q~H6   "-2    HZW Pp8/TŤ$t< 
HmwN  #Sý   @ob(HA.2

"p/8j   pG[ 5p/   D[ h44hq)	   1@   d!-H@&%og8K*Y!   b/"CPN    Yx$	NG ar	Dęa""V7,\   Ƥ#A9E1   IE)2;ݐ#FA#"V2RBS۰p   { 5p/   D[Ԉa2
d{pC,[LbZhМGМ    x U_Q    @a@&	ֆ:@~*6o5&qU[d/e.  \#!TF9d
g9   Ž$o&4x|}Rm)
TS[%'af_tmaEmX˹}Id2e?b>4Wqm?6{#-F>#=5~11ݏ/#'}uW|
syޘb19c<W:K'vוv
|uřO鏵-8%"'v>~kMUyQٮ˺-~1sQm_">/1MeB~}sr11ϻah50oq+d:ηɐھ) s̓}_/uWu\uWABqtvu.zƳe^
˖G؟sYOcWTQN^,]pa4< #FTUԧxZy<:'vԭ='J;쟧p=q
st9vU[QvZO-V
oh/S   Hd-.'x<?گO*&Wy$X#S!f dSô߰
g
&?g1lσ
Yì`t%ܑz?)P+G	oe=REzksz,/#8ʫaHFjUU#Zy|Z+r|·/F
bMV9sT,|.3 d{<yp=q	Tzn2)*':qGyH*˵(G:]9tW7_%Ec55kaכ_&n)2䃎k6j+B{ookq[hsaw59G?I8mY90]u&<a<-W>GY4|	i<4̄٨Wq89TH^  Ry<~\#'o:Տs
tx?:2WUη_oFϿx:1~X9>5qeHFEEk7VEV+j>7ϫ|_T{?z;PF?Oo/p/牘1a
$   	1CfEYu̽^mS}vߤb}spqU
Mt]]3Fܨx|STuvQkT,oZwy"|?}ضy-:trsrֱ7B3]kt|7|LCvmvöQ9Iؙ_y{Ty{"fEZ̊u¶Qn_^̰RprN|>_D:6~u<\>Op[f 즊Q	n̔<2dTL*~S~ѐ!)ʣSc{HC<sjm)6Yd۶:,7WmZ᾽4%a铭>xzQx=`:f-'S^Ð4W^Qod[mZtl](-v}no?Frύ':)Ss}k-{tU~.tPy=O9WNuk=]7WL͚6UAˆ]r{n[L[8hmiWa6@WEIaǨݐuS0&'A{  R*Z}rm;7Cwa}ۮ#C_6+]~ry>޷-/tD^穸t3(`Ku'uk;1^wNwnb;n;U|D"\>ۗ]]HȌη_<dHF#c\7ڱcZFfb Jp	Uood[ި1
Os1ݳ-GBoW~5iW>v/v;Qv/zX>Vgo2^?hǎ<\^    jH} i֟*++SYY	Ij#jСC5w\uYwt'.ltdRVV^cԤ2}ݧ3gO'ɩ5c`EMУWFԭ_p-LܨnMwNN`=,~I`  )az]wMMk|-tG
}|'uvSU;f/>Oac    8"ޢZ>/ي	@@@E MFzcnnnS$

56*~s!_xtݧ$.t-`zU^^NJP|
.׶IvZIb	t   B;.
B>6}"2[0Xe    oQMNz}-J}]^^^Sd`pC
_AI}MjG($#t*[r
|z3/6   CM+.>6ކ\ Ai   xaE
M	
ۿRF95)DP?ڗ/{^~UOluz{

^Giuʦmu٣Dk;8Z  2_KQ"%[eP/Q۱1
8   zxjwCjBKv.e6۬45>hfd3|]Cn!}Mb7C7B5Uor]M
QD R)ܮÿdm9o/"SЎ   @> Rcto.pCB=Zuߩ!כxGn
DznBj  Gk|H/"ю&LI   !_'W(+ȋP&oze
Z  D\Îvv5E	   x^shH(㕨H&PPQߤGJ5  fh     h8<q/ɀ     R35         Eox    H'Ð♱|     3    "    <CBhj@     pǌ        :)              0         @D    dM)     ;f    AD    y
$      w    x    R#         8    1R35         o    0dxf,9     pǌ        :ϐ*ھ)7      1c    "-    ΣG
         . -     !         o    $}Ss
        @o    u_*p	     3    "    꼔Hs          D    dLͰG          pA[    @f0Ik}ɔ     c    D[    @gH_M~>H      B#(aD|   hH|q/I[    @GIdY}cȐdʔ!z"(~ihӹcX|pٴ}i1dVɑǶ}+Uk1:SE:\o:<+#-}?]S{d9k7SrV7tQzMʹ{=u^%umթW1w:9?m5.g58/GNMA_D{zUBJG5UR7zvի3߫y_;jGRWq{fc{Ğ ]f*rzUU9&P\HuzUnk{   4$Ob    POn!#Hv
oRTkv'~z4ĺY:Y7}ݾi8~]'XyY)1uܬo?s}a7#/rF~j=j>D;>UCBqS^/[rSOkuUEI{:RSh/\~F͇l7?|PőUo!!qۋD=?ݎZONI\nOp)ը'5i5?ퟋcU(w]_MWGCs뫢\U's}C]]ޟ]7U(Lulcs})M\n{㚜P7Q*Ka-   ."    2HDG{S@  0	YܢأDGqߐv
gZG
OQ"ڄ~syχsm,@H;+Jĵt7kۏ8YF\C>x:`úm+bmHQzls+oxPD)Ex:c+*o/q=,aki*v;WW|"|mo\UNR/I]wf{~ze|7~E+Q+/u^<TYDW5)'q}޵^Tݮǎ<]m/z/
kGs^^yv[UW:.&mR/j|:nVkb嗣U^~a姽o
o9aRa#hP9sv$z%Cțӈɷ   hЈx    jC^W>O^аKK-aU.q[     Dw)EV=w1_v^/o  `    P祢GjhGiZ      
}mh:&2   
	o    #=Ѝ #I֍$\4hL     
}R}$64   44D    dÐط-o%&     Hc(=-   P    PRB75Ci4Ms;&    >6|-nǉ    IDAT  P    P祢Gla$[     '   
o    
V"&     c-   D[    @ImߔH          bĽ$7    ib          -D    	=R          uo    )         t"-     3Lb         H#"    <CB(}S          C[    @G         @]@[                D    d          ҇    :p          jo    u=R          uo    )         t"-     3Lb         H#"    <CB(}S          C[    @G         @]@[  `T
            o Chm HsJ  pC         @  8x<& ?          mD  &~ @Y	         @]@[  @[ @]F         @:  80 PgLb         H#_KH@ t'#|nZ͚5SIIIUFҝ !u7mT[Vͩ@NFT-[WgQVVVaH_o
          }ӬeURRb=R@RN^xy:
;[nզMҝףG|9 dڸqcz$[fݛddlu-@(ʏkVnnrrrzeׄ          R              @     	}S          C[    @g              :)             A         @:Cvڥ;SÆ
ӡCҝ K,wܡgy&I/ÐI[          iD[Yx


d/^ %}~XhڶmN6mJwrzǐ*J         @#L'|ݻ[nZ`APaΝZj.25mTOwzt          j/%xԷ~;w[n*))ѣzjZlݺUt7jƌڷoz\Reee*,,ٳo>kN7po߮SHGyzuZ5|mݺUiUV߿N=TIO<m۶{U׮]̝;W۶mSƍui.SVV$i*))QN4|޽[Gq.ruZgQQNoFS^^t颫ZM4$=C۷VZ~A}rrr{@ZBNݟ7o{@jON8Av>c
<q~?}]
4H'OCvܩKk׮4o<-\P%%%*,,ԍ7ިMJJJJ4c}***RVV:tAC˥6m.]={e˖ׯc-o]^zfΜu֩T:t饗Fg5ԩSSpDP.         @m-oZhZhB[B&NP+WW_}C鮻Ryy^z%9RM6
7ܠl7n?K>C袋4h :tH+:UV뮻TZZjmX/5kc=V4sLM2E{֐!Cm6M2E۷oСC~:pnVvazw/멧RfTRRg}V9992d7nkڴi2CrYfW^:zSuXWggg 		ZxzFwޚ3g>3}َe5}t
4HW֭%ISNU߾}裏jƍ;v{wqk.?^n&I҄	7hРAjժ4m4;VO>^ou4Mիu%cǎꫯꫯTw٪
4bx≺[%I+V̙3UPPjϚ5k)         @pAXBa|:5w\ݻ׊lҳgO]r%~n6+2)ٳg;q'I:5a޽[͚5֭[uYgizڴiZfZjeMr=Zt]wQF:pOO>Y7|$k׮j޼ƌ5kX:t7n,I+_諯R>}uV5mT?վ}{IR.]?j͚5m֬nFy^|7e@]Bݧ~ok.y晒m۪CZ`Ar]~ݻVZꫯ={nݪoYj۶N>d}R߿_V߾}׵k.lٲʺW_iʕkI]tizwugQF6lPǎuwX[nꫯfP{zT=S          D[XdԣGK
NH={-Z/ر|hb]ͭwtaI:(\IquI
NٶmonMrۘ4iVZ_-Z$]Veee:Sҥ^V\iMkѢ5YGP$>Z>ܹS7o͛#sQGOG\ݾ}{K&MN:9wUV999:t$);;[>$i߾}ڱcmۦ˫VLڵku	'H.G}֭[cmذAq .!ط          ҈@h"I,X.Hzgsrr\+";o믿ijժUԉ0׼yt
7X$i_~swrgT+@zm޼yzg}ij}>2߾}"ޟ?~[r*k^w­\Ro6n(ϧ6mXck]H].--դIxb*??_suIcH_o
          }xƍa
8Њ(j*{խ[74/\w9eggHK.u,779眣:^(7ިvEl'}3~|M]x۷Zl)I={$@FݯDG&[d~+IsuUW9"S'.o۶M/;8=:#xb\ұl'׫Ç;&ĝ7xCK,_N:ʏ{,bdz          ȻpsHEӱ;󕝝'}{նmt㏷~:fd[_VaaꪈtI^W[nU<M4I[l;Mk֬W\aMZf#2&PP+Q-Z:{usΑŋ׫LQGeEPݩ.\p墢"M2E;Mk֬QǎugXnwء"m           H#߯%Kk׮!sssս{w-]T;wLռys}gС7noVӧO$СC=z$ի


Ժuk_3f̐W׮]uM>]:NSǎpBM2E={Ծ}4{lرÚ}'>2զMi&
2Ν;ׂԯ_n}x<5k>ӧ~*)|I'PǏ_:J6m{ｧ:XѡC}Zhڵk͛7ޓi*))IM         Oox$ݺutr)Qݻ,Y?X{Nڶ
СC[oiر|:#umiԵkWm߾]/F㢋.ue)??_},X<uY_~Nәg"-^X~u'3Կ/mذA۷OZ ?PmT_|ÈZ=N;4͜9S+WL[n[oUӦMȑ#;ꡇs=NYYYqaÆiԩw^o߾8p`Bikd&O,߯{駟駟<)p          ja~5(Dzी^ZrtwnݪM6;G2r 2۵qt'#3I@fݻ7h֭[Q*~F=\0	         '%	    H3z          )q    }!SM         o    u!U|!)         !-׮];|z״cǎt' @\         . -e֍7ިVZ餓N<3gN ٱc&LJgNwr           @-Ž$zzNFFzG4w\-[L@@_~K1Bݻ~W^x
}\Kwr\)/!L5}tM>]˖-"ݞtIڷoPVV(	          Ht3 H-[e˖NFի$iϞ=hΜ9UZZkzլY3wyׯ.{iN=;1]xᅚ3g
~;j5k,M>]3fжm{<z2C:ӔRa1\         F[ F~~J]y啒
6h֬Y3g͛"޽[o5C$.@~x:w36m*)8hVZeE]p7o\]tK.H         DPoo^~nvXBsќ9sh"~رc5vXy<|ɺԯ_?G5Jn i[wɶk׮XOԀ4` qziH)pL         o4G={TϞ=#X,М9s|r-_\O?rssէOO~3|	
D~~$i޽iN	<6mҴi4c͝;Wp;Oe]mۦ) 2ľ         FD /ԅ^(I***ٳhΜ9}x\u7$i@@)"܀R(JBKHQ]UaQT
(.Tp.- 
iwP3HdGi$M3iz]W9{93ss'_o+&Ɏ;c=6


2eJvmjlT*޲9(o[jW=ܳ\~J06      G[$o}>`OS9	w޼yyW_$y[ޒ466c[o]]UV-_|1fJsssfϞ^xqd}ݷJ)      0xЇ;{w>O={oZZZ2gΜ}Yre{<c~ڼoOccc3iҤU~fرI˗g媀2gs7N{{{ƍԩSԔS+:       +o֢6&MʤIy2o޼rE=w}w|_V[m>:ihh~W݀uۖ?~|^̙3lOX_(rھoO`3      oѣs	'NH,Y$rK"%Klٲ4779I.!


2eJƍW]n%2/͙?~/_c[orN;TH=      -?~|>яhNKKKZZZr^SO='O~$Аs15jT5wz^^b$lV\;\GfδiԔ:*Æ
B`qE
      *?=ܬ\2wuW~?3fdذa4iRؘC=4
pW榛nJsssZZZ+X?bĈ}ijjʉ'	&T)R\      դ-F4lذ}9o|#/rΝ9s椥%-ʕ+soϗly׻ޕ444dnRP*.innߟj9wurUFaKW(-      PE*1cSN)$y'3{촴dܹyK/n
7ܐ$yӛTNmllرcl!f
J\y啹馛K/_,=ɏ~j&W^ɯ477g֬YYti5559ɶx`"BPצ      @JʊŴeimmy?,ۆ7m  R)>`ZZZҒ;3=
tA$ɓ'J9mokNg0aFrU7ikk~ԩSԔ?>-i
ikϿ4#GL}}}R[[B       CDP>8_җښ;#---3gNz衔J<yo}+<yr"A$u?_O?};3%ү˗g޼ydWijjJSSS?T!R       uSy¸ 4661Iϗp[ZZxⴶfΜ93gNdvȱL:5[5wM>̞=;?*j___.`#GŦk~_9zk^Gc=6ӦMˉ']wݵJ>צ      @x~siNK,\0---iiiɼy/~r^{핆rEܭ޺vWoO?ֶN;
BTeb1wuW^m&LPjw+#FB=      -&j^{O}Sioo}W6+Wp\q͡Z;iҤ6ڻvkbo1cƨv{2k֬477gy{ɓɶ*E
l\      C va9/9Zϟ9s椥%<Hs={7=:G}t_ݠʎ;|_ȥ^o??cƌĨz\{镘=nܸL6-ӦM˔)S6T)R`K      BmXLXL[[[/_֜bmX|smvՌt׿.W}{yАL:5ƍBTۊ+r衇Cu;SxW!2k9s椹97|s׿X_(r!z)0}^~c'OoeȑO]]]jkkS(      N[-q|$G$<HZZZҒn-Z~k_5I~!9c2zjdL4)Zu_W%nWJsssn,_m&ijj	'wܱJ[BJQ  Փ    IDAT    &op+Wor5/=6,vXؘR+2guV	pB kmm(+Wߞ477f}ISSSM#<2Æ
8 Ų^ߐvIKU      ۉuyV3V 9sdΜ9iii{3fLw1


y[RHئL[n%IrWcXu´eor%lp<L9Ѷ%j#F1tIyӛ޴c$      P- kO׿uZZZ2w<s$l5b:O?C9$;C|Anه>\wu9CR){on477H}Iv-ӦMKSSS2jԨ
`J9%      [`nx>T*塇JKKKZZZ&YxqfΜ3gP(HcccsG~@c'?joWO:dƏ:zjjj
.`~${W2{477g֬Yyg{aL6-p@}T[{       [6 [B:(tP/f;2gΜ,'>Cq劸|U;s8I2s̵,zDҵkhhHQeuT*=p%K/ݚ,X innΝwޙǎS)|0 6Mfm      `(P6bĈ444!\rI^xrnKKK?5sܹs$o}=444dʔ)c=iٳg'I~gme]oۮR:ؘ'ڮlWW^.O>97xcd;wnn477'mo{[ԔI&suh̕)      PM*0`ƎSO=5zjdѢE$y套^?Ͽ'I&N466c͘1c8Ɵ3fdĈKzJ-)Jn%2nBjjjʷwO~͛+"͹[oX?z{ijjʉ'wy@
)}      T l4'NĉsYgX,KKKK̙YbE-ZE+Lmmm94661~x
1._ju]	_ڲerBUJjz=BgO奎iԵM6)uNvkmwPJgyJy6F=5>]q)P|ݏ{__әt[[SFfXIRNrM7hU^y|Sl=sgʔ)}n9:y      T ;\xy3̙3'---yޞ{7{o.=:GuTА/Ͼ>~U	]nV׶RjJ۔R(w[LMBe]{yۻM5bnsR;]{Ļw~{߽k?Ŏ}mZXꈿR
o)5\mWwyߟ>455)φ%69H     @[ bԨQ6mZM$Yti~_g޼y3^ˬY2k֬$Q!tu\pAs9甗rm{{{yy)IM:~SQiy[*u&FSHW)ێDrBbVUTBgEBBRVa[RJt-R*;nw;V _*uƑRj1^K-̤on3:+W0^v8Oǿ4/t^TV!wR1mmm)
);b[`A?79zZ       x0nܸ|#G>$ɂҒvmYlYBh=l69{U-Ij2vBIVGս;ͷ]a
[{5KnMm	Gߛq?z[Zú*ߏ/6ߐB
ikkKmmmJR;w\5+jsm
      T Iow|sKq9ꨣֺ'?ɔJ|cK^5[#ՌOKŤX*OOٳx*	0      0*<R*+jW,O~2/zTk6Z
)X,_~x<.,SLI}}}}L:u#Z      P- Wnذa9#t$)'ߖ*g>9sښn-gٳ裏͛7oP\      Ty⭄% h;vl?tI:ujz봷wc#AT~-	>SLɔ)Sre'LsssfϞ[ouc0:~       P-*0-oɉ'N:)GqDjkkLp41JҚ_mrg3L[[[.]qmHBP9      P=*0͞=;9#rI'=yO&N~Ψ $IXp      `(P!.qn;3Q5:       @[ |י錪(
H[ 9      PM5T̀jQ`      0*OUٌ̀jQ`Ø     @[ - qe
      T lYLg       @uxt +o%lBP9      P=*e1Q%*lS8      0xtFU        oزΨ d      T lQLgT =      - [բ-1      CA]-*g;$y2syYtiF}'zjwc/~ٳg'HP;.3jԨr?9=?RXm{O:W^ye=Ѝ}hkkacYPȘ1crΞ{9q
 ĕ)      PM'ުx`e˖oo/fԩc=k;s9?\nK/Ο}ijjJW\_W1cFvmw}/}:w;Ir<쳙5kV8?Ϙ1cӑ VR`       .oزt6{<SxgqF{ތ92Ir'W\ѣBi~8g}v?\s5[5oVwI&e]w^{}C=y?sSNRd_|+Q`C6      *9_N^jkjjrgSNowߝO|=n9裏oRSS.(~\xᅙ:uj?~뮻-ZC=4wqGo_dvJ5_~yO;,GuT:,X/?'?ɉ';,2fƌijjGN;-g./Jկ~}C<yrNo}[Ylzڨxa\      CA剷*9~w~5kV^|:(w^Ǝ$;$


wǧ.v[ǏϹ瞛??)Ƨz*G`}7:g3gΜu?zz<Sy'CK.;r|+/~wyYxq?u]s??>ls9'/~0]vY<\xᅙ;wnnΥ^innYg+W~_       lޤ ly:0aBv/'Iv}r!:ujʶ_S(뮻ѣ;䩧OΜ9srgɽꫯNkkkI>:2cƌ5&W9=vj$K/峟lN9r?c,YR>6lI}s?~Μ|ɹ.]tQM$y;ޑ%K~k6Їry%I89s2k֬tI߫T0M     <V[ 6՘9\Yxq<?~n455+_Jjj:֦ kkk]w@կG?QE9CIIR(2mڴ|ΓO>YQ?krGdIb_|1---9=SN͈#0IK//K?oOUhwermr$<pw3fH̞=;b1SN~3fLxN =      - [JRV\Çg={}ikkUW]3gϔ)S.-K,oygr~9so|#]w]&N_ylw-[lY*З]v%sLe'|ro&	sO˰a7GmÇxܕ\,t$92}+$IꫯV@[
      
j*n- pws-I	袋zm[WW3<3555yG$G}t1o喴JbOΤI /^~l6y{-$nm9Ge˖fĉYtiVXŋsرcs;O[o7x\ˢEdmI>g3wT L     j<V[ 68=;hѢ<Gѣ$x;2w]wݕb	&$Ioy䑙9sf^}?s{uQk/̰aY~|~WNM:*Κ5+KƏ_ޟzfŊy衇xgvi><,Ȋ+r-oyKޛdU5JtAIX|'s&g7M^}#A-@(!      P]hot6y_b%{r|3yO|"GuTgeѢE;gԩ>sg>s19CR[[?[뮻K/-'gvyg՝~;wn8|ѣs7G%\$?~|&N3gfĈj<bkp\{ǯZZZZO.H>5\ڔJ|
oZw3|p1/B&Lyˌ32~z꩹kS,3iҤΏ~>9*kmJ[b t Ե)      P='ުx` v!3f_:Fi>fwu]k&wygn'?>|xn*7xcsWX,fwYgSO=5#G(N:)s͝w޹vk\~ַ>I&}??;NzL>=sLm<C=5*o~}-MMMI=3_|q~STf9sf8<o*B3f?AYlY&Lɓ$;痿e~_dر9ww=-qE
      RiUFmXLXL[[[/_֜bmXXm5cJ-+VHkkkm
óB-Ȳ%^Ʀ9rdFaÆ6B [e<߿!{fȑO]])      0hj*n- UQR`     <V  63$Q`      0T`b6ZT0p      `(P `+x0@\      դ- [#A-@(!      P]*e11J[b t d      T lYLgT       *e1Q5:       @[ ,3-1      գ- [բ-)q      `xlFxa      P- FWP`2      I[ ,3YGXI[PC      T`b:cʷ 6D!A      oزΨo6)      
T`b:*kt       ́ lYLgTEI[c2      G[ (3E[
S      `SV,[RH!ª? ֍9      
*n)AMHWbꉎ+V&ܷU\3$ǥ
]>p-
̠zSW^Ǻc}Mx;o+8}Bۭ%޾0Rs}%qz,GI;,q&      [o
Ԕ_yi_z)RR
nIRH15BJ)x~GqKl߫}?q)$ɪZ_klָ{>Zxw;u9}ſ.}-BVUXOBJj      UTSqK! lbkjjRS1ILZqIlsEGbϪێ
;o@-uP^YYa1~״Q8RjGRm35_w$kGθW+rw궯˽wƿ mZGAk?㷮jgC/Z\"3 kj&      P=*Yt[[[3WmeR,Rt[ޮ+KrioUO۲Bc)T(iVO*~uUX}A}Dc;w'I>ӦM(VcbVLkػU)VWaFfX]]jkk%W      PPy 61]uuu~L)یJ
ioMXtK^i{!I2|*GiJM]]][       M ln'
եX,vTM$߮ÇgȑcнrWۮۚw @?      @xfP(T*Ԕ+vn
jI^ն+ٶk +q      `xf{mmmmJRW[[ÇW;MFWbmD[	 
      *Z=뱤W[[?>С{n[ ֝3(      PM*Yؕp+q
T;M*RR      "obHzpBq*
IBC      @T^N[   )      0Tx          [0o  ؄6      G[   B          yH     @[   6L     jR  MCڷ      @x  WH:      o  \      C          Po  ؄6      G[   B          yH     @[   6L  z    IDAT   jR  MCڷ      @x  WH:      o  \      C   lR
O     *7*  Puצ]׬p     TB%o$sXZUɸUg-qK+JT]J)`=+t5xƫ\}8~QQ
OU=_ջ]ʪ*<j1O8췢zzC9 [<
9dΡj;ϯՅu:<`[Bsqۯf#}q+sf=u2Uy9W6~߇}f\x~Sy6|ql@Օ뿿_-/~
      0z$v}yWSSBKz-_x9RR3Bt<N!$>ۯ}5VomVq+T~-ǽ
ؾ{P+ukw]Akʯk5}>xn?`[Gھsh^k{c#AoUۯWݟUvn癁oQ >z7py}>Vo{^\zQ6|u|yqo;?^PH      kaБt[efҎ"Fݾ)NRWU_Uۗo߭}/nۯq3^]
x{]ǧk?{_5ުvUIk߾[Bv}Oqoq{UǥgEO~w{K?u{9^*wMt^U~/zRyod՘}gU=^99s۾>ڭaU3ު՟UI!}=WZ>.}jzs5ƻ9+{/:7lx~[I?8>#:-=4~n<oy
>dxxkv_{{|~z\>vu.>=kT4l΋ڧqc9{uxk9g}[(q|d
9iM<ykuPHmmmo      llRWf:,JiooO[[[VX%ϯ/L[[[R,m5w/7Decx]v-6x*ߊwd[WmBy99n6,yϬZ1uJ
{IW{dǭ4'kC}H_ҸZmg
縕ׁ}ҕ`{6gx9ap']LdpOC뇡Fe؛gᩫKmmj?      xZf]]]v[VuJ 6/[:;yjmWm_      JRP[ e6lXFY0 ؂tF^      `H-
)J/5uUJx [aÆa J|z[ɷ      `m
B]In`VWWÇW; 0lW      Loɷݓn-[W| +J      [3ݿ,J zTjq}
      TKE%|	 $o       آ)Y          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          x          (JR j*y/       D[          [          [          [          [ dR!l4       [ /|!?\3}K_Oӊ}//r믻|SʢEҥKsg{xim!n֜yimmM̜930?i.A        j.RqG}4<H-[+}{3qĵ5bĈ3fLoLkڷne2        t' X_˗/'>p3fL>
)ST;        Po`=}K_[|N5kV,YÇg3~r-/Yc?,_<fߟ^x!o}<444P($Iꪴgwߝq3W|;$s=n!ޞ7M9S{&IJR~[o3<#G栃{5\|yn<y3lذ瞙>}zs~}̜93_3nܸ$o~vmYdIJRƍSku3g̟\tE2aI{,f?+Vd̘1y;ߙO<1IW_}5?X,#LTsM7e)J{s'gw       yx ݬ\2/B孭krUWc,[,7pC.|_xw1mmmON`?N;?w߽j.SO[oٳggƌ/{,Y$7tS|_L]]3nܸ<馛rUW墋.s*5o޼\2eJO7x#zk~g=,'gX֕\w+Ix\ve<If֬Ya2ys+SNѣ3gΜ<3fLz(W^yewod֬Yַw
       I- t`\pP(Nȑ#$cƌ?lVv!cƌɽޛ<guV<$[֖dOW\O~;vldҥ=Ɵ7o^^|K_*'N0!7pdܹ9csꩧ?~|.}ݙ<yrZbE-[SN9%GuTyy{{{ڼq{[,Y#<2rJy.쒯~YpZoG=أOSnwqy;ߙ#v	93o}[g<yr|>I}7^xa?#{>ϔ+򗿜_W9c*w        6=o	&dڴi/_</v{W_z9~8qb&N6=XFQNra%=X9t*'e}{T5jTo$Iż[֌=:=XÇ?$Uu}<3$ikk7J|Lґ3dҥYpzt?̾ӧO<\vɒ%ygxX<ƢE2|rm1"p@y$/gy&}{IIG{l         6lmkn	9swVusHTI#=6 Vx骫2+bmtFQMY&*%*xmF3&LfLPCs;sl.>:m?}w/ˏ;w_0 'NGQԬXlYb.Ƿr$˫z"t2˖-Kn4hP\WM7ݔ)o3p$K/ySEzzsEe7g>444TϽC7ȠA;zͲe˲w/]4!        o`#5jTF,X w_㎌1"{W7l,YW_}5I֤k]ϟ??fm$YdIιjvan}sgwg.MMMy衇_j5Jcér9^xarI'ewLx<#k\~YdIN?mo9g޼y'?=أ\f>JضrMY       / zs뭷欳J[[[뮻cI,^8ɚl.쒕+W'kܹip\I{K.ɼyw+


7o^?3zsw˪UrgĈijj7;|oIܜEՌ7%K/fرu]ӿe9[w9&#G>S
ǾKYxqu]w5Vymmmyꩧ
6lGy%Kg;\W        ]:Fn;_}7I,{$vb۳{f=ܓ:'Oζngy&{o&N!C=I2gΜL>='O__Nccc&L!Cdĉ{REvm⋹۲ۧq~444dihh:s?$Yre6jԨ~[o5#Fdձ
*s;쐁f5kVksА~&nev?9sdy$EQTc=N;{^?<8w_,YRp.\xᅙ0aBV\o=


9C~^        M N2eJn\y)ar'gmIUu/~%KdԨQ9s7?i-[aÆD&MNoҗo1^{mJRvq}5O|"/~b-2nܸvaׯ_ng?n-ӧO92zj=,X #G?,_<{o{;.ӧOOwʔ)\qijjvm?>fʂ~p3$I̙9st9樣JQښCfҤIyW-:ujn̚5+Vʞ{8K{L:5fʕW^g]vɔ)S2lذuzf        = L<=:͛        $
           o                   P[          -          A          P*E ںKxK<xpϱyjllLTe        &i [AS?^Kek       _M]                     P[          -          A           x          u         :         @o                   P[          - $YhQbJ.?'pB?MX9        i ICk_:%ӦM{*       RQŦ. xkhkkرc裏u}ccc~ᴴɕ       - PؘK.?x[        bx tqqzСC3dС        ` ;Ns9G       ( @C9I&        o(M] ִ{G9ؘ~:FDU       - УK.$5ǦN*t       _$o:3}$Ɉ#Og7U       - VZF?q<M]        l @|{˝w޹K       MF
@U*       `M]  }S%dw .u       - -[[TJTJCCCu .       _:[ Ym\ΪrXն:[>|[$)ڱzkջuջZׯR)
CMiihhp       XCuR	Vmmm9qƊ\5-)%)H(in(Rʚt\C5ERHX3F5uaü봟Ww[=OOUjoԡ^רzYikVs~hmvꮯHέޞ֬}gig#՗~MMijjJT~p       5l {:vmmmM(>SJGjKپ `QT~I%W*:7/ryQ0,V];חJ}R*VRos}YC}׬(:u5P{JswF]i5YNks}I3fWZ*\Q[_7v}ko<}GJ\wRߚuY]zWJښ;W       uV	U:ޖIJ~|S+W I%q{}=_}kKv0fVwM;}.Ve޵aX3V}u.c3ѵ[ﵷu7(z9_Xlލ<7;Eڃ)iho        :`orԐnԥX<+;H[[[T
W:       V	JwO-=U7-mE
       DuT	R;on       j	ުj6OHV       g lD:B_Ux       @o؈tɄ       	J]6>F[       	.@-       @op6%2       w lJBLt       - eSJ:       A
Wt B[       :	}        `#/*o       z'x+u o       z'x+l }        `Ud˄J[       	*m22       w lREzxOFI[       :.Ł>n/fڴiYxFoNKKK^}YpaZZZ2{}'s)l5.Zhם>;---K=f>%/iF&OU-       @6u 92wyvaݞz7|7o^zM2w0 cǎСC7ߜ{n̿6dر߿F+V?ivi|9TW?3xB[       	m~#F'?ɍ>n_6t̘1c?nܸ7Msi}ݗ:M7oUx       лM]  J]6砃Jkkk+"ǏҥK$sgs痿GC	R  IDATe%?Os'f}ĉ|:5\~I>8ַ$˗/E]7n\>яkMQ2>iii5\==Sg>qCɕW^YRٳ$EQ/ϑGcCɷIO>9v[~ߥ%w}w5e]?>ƍ˿˿oNKKK-ZTGfy5뙫oΘ1c2f̘뮹j<5Ξ=;---YpasLw>9sw,:oe~;gL:5'Nرc3y\|ikk^+3'.H\2O>)SdҤI8qbN9唍ֽ#o       z- 貱ѬX"/BzsfgW^ɧ?$Aԭ*7xc>+Ȼ>L2%_җ2|_NsssN;~immE]+2#FHkkkL9;y睗^x!zjdРA3bĈ^31c9&wuW.lv9C\?sI'ew̳>??+VYgO?=sN+\pA
Vw͕CG}{_>\2\pAN<̜93r<9묳$vX9<sagPGO}S:uj-[933z^g}rO~믿>GuTd2eJƏ>;R){oꪼGQ]ŋO̠Ar橧СCc9S2nܸ|_βe~7s5du{ot       - &e>9û=o~3tPƌÇg<s$9sf-Zk6K3fK/{a裏N><?<vZ
T
F><Cɝwޙz*{n$ɾ̜93G}tF#GsϭO<|#IL0!>h͛m'ȑ#<I^{e.lM~Uë֜$Æ
˙g$`;2|L>z}->l,XP\zkI}C9s
7SNInA~pMV=w+O|3jԨc=n!{l>%Iy晼η/I2~̙3'?x8{Y`Af̘c&Iƍ#8fӧgԨQ>}zJ_cǎ͑G/<_x       ;[ 6\Mfeԧ>ѣGW9̜93+VHsss2j7o^wewLkkks_\zlvgȐ!Y|y5>c0`@5TZ1y̜93?:ueMn755o{,Y{w;wq8qbƎC=КGU
v֖_9cjiiiɭޚ$X\mmm2qE_=MMM?~|nL:5kY?cN?|.\<Ijժuk9S3vL:z#̑Gw3X:O<$͙0aBz$ɢE礓NyCɸqc"@[       	J]66aÆeĉ^w衇/<8 wuW>jW_;zW9W*R%TdɒnVkfmVc
'f[o_3fdmI'T!56:_{<k̢Erw;rٳt]Ws9'>`Ȉ#Igk/~<xp>444Tϭ\2w^nX"CK,V[meʚ$$v^UJ:       A
Wt{;ޑ1c䮻ʖ[n^z)rHo!CK_R<xp^|{-ŋ饗$[nz[RTt<ùꪫrg}oMsc׼f!/r(rguu-dm׿.מq-Jikk9tv\δiښ.({>gϮ~5vZ/^8p`o۹;rg_ڷr.k+
$=}
o       % PM/sy3k֬N5jT\KKK~f뭷nV{3s45oQ:v7M+˗/_so3}Yg$8p`:|3I[[[?Tkucܯ_=:?S._SN5/x 2f̘.?zhyWOgmY^xᅚc<Hu{y3yinnN̛7/IoG7͌1<{;j8/T{ｳrw}ϵfΜ9Cfٳkj{3wu[/o       z- p\wu='>Q
tA9s2k֬L6c=6wyg>˰a>n=|͓$W]uU8tArYgNȑ#3w??lvIg}6\pA8L4i]Gƍ˅^:---yWsW|gvej/BfΜ}ݷ}.ӦM|#ҥKs%d̘1iiiI^kښ~1y|
7ܐ:3hii~K3jԨ?ϓO>YcСfmrgvV[mGy$W^yed7XАz&;v،=:sOnygs饗(&LȘ1c|%SLɶnGyk:N6-zjN:|#~79~F       w lR7M_Gyd5x;p}溡CꫯΌ3ryeʕ>|xN;|c[e}M7ݔŋ%_|q.̜933|?C:,Yx`w=cА[n%]w]3v؜xյG?9sdƌijjG]W;vl.\ve9ӳ[d	Pn喼̮#F{̞=;'|r|.]믿>r9&LW|_HJ{9ss駧9rdo+O<c=v:wjrKs)(2}y;ޑ:*2k֬)ӧO\+"+Ẃ>:wyguI&ϕW^JsssZZZrfz-       @JE2 $))immʕ+bŊe\wSclM]"ϸ9˦]1o<wu/)J)r       '<`Y:       N
W靮:Y*       =[ 6\Чt       - )        u`Ud˄J[       	*m22       w lR
O)x       P[ 6\eS
o        xF_&U:       NHLt       - ect       - 1:       N
WiY/*o       z'x,˄J[       	J]6>-       @opE
O)t       - ~Wx       ;[ 6"2t-J)Dp       #xz=a=t       ]Ӧ. Y{b4RJ)NHC$)R*ڏw/%sƮx}HzR4OzTOw6t\ncm{
Mw5t]zEsuM*׮Y:=X.Zِwz~G{뽮N{
       :^**RE="`Hr~aRbVJQ.cHhQ\yYu/Ey+v~M=k/:t/ws=q5^ۡƢ5ծQj,5EWToøT_:[\^]=r9馾/yt;OU)u/~R/>k'JI[        jxznڲۈUikkKQnKyu[-|>I[gKEcIگz|ݏ>=Բ5T8+/(U~V{wUy};S{ѡh8]kZ:cuk{{w{o}z
|R	ЗؘүCV[       Z^
 PY.ښ֬Z*VJkkkڃE[S%@_	ׯT='x       N[ Yfccc5\[mllLSSS;u       `
[ ITJQհ^SSSucVJt       +[ K%W	UBIno;p+q[       5Jt sV![[       xz.'o]k
       tO[          Cæ.           [          -          A           x          u         :         @o                   P[          -          A          .,y?    IENDB`

==========================================
Conteúdo de 2- DFD com foco no youtube.md (caminho: linha_de_raciocinio\2- DFD com foco no youtube.md):
==========================================
graph TD
    %% Nível 0: Visão Geral
    subgraph Sistema_de_Chat_com_IA
        A[Usuário] -->|Mensagem ou Comando| B[Interface do Chat Frontend]
        B -->|Input| C[Processamento no Frontend]
        C -->|Requisição com conversation_id| D[Backend do Sistema]
        D -->|Resposta com conversation_id| C
        C -->|Exibição| B
        D -->|Armazenamento| E[Armazenamento JSON ou Banco]
        D -->|Chamada API| F[API Externa como YouTube]
        F -->|Dados| D
    end

    %% Nível 1: Frontend - Foco no Indicador de Carregamento
    subgraph Processamento_no_Frontend
        C --> C1[enviarMensagem]
        C1 --> C2{mensagem vazia?}
        C2 -->|Sim| C3[Retorna sem ação]
        C2 -->|Não| C4{mensagem é /youtube ou /youtube_resumo?}

        %% Fluxo Comando /youtube ou /youtube_resumo
        C4 -->|Sim| C5[Extrair videoUrl]
        C5 --> C6{videoUrl válido?}
        C6 -->|Não| C7[Erro: URL inválida]
        C6 -->|Sim| C8{Conversa existe?}
        C8 -->|Não| C9[criarNovaConversa]
        C8 -->|Sim| C10[Adicionar mensagem com conversation_id]
        C9 --> C10
        C10 --> C11[Atualizar histórico]
        C11 --> C12[Mostrar carregamento]
        C12 --> C13[Requisição /process_youtube ou /process_youtube_resumo com conversation_id]
        C13 --> D1[Backend: Processar YouTube]
        D1 -->|Resposta ou Erro com conversation_id| C14[Remover carregamento]
        C14 --> C15[Exibir resposta ou erro]
        C15 --> C16[Atualizar histórico]

        %% Fluxo Mensagem Normal
        C4 -->|Não| C17{Conversa existe?}
        C17 -->|Não| C18[criarNovaConversa]
        C17 -->|Sim| C19[Adicionar mensagem com conversation_id]
        C18 --> C19
        C19 --> C20[Atualizar histórico]
        C20 --> C21[Mostrar animação de carregamento]
        C21 --> C22[Requisição /send_message com conversation_id]
        C22 --> D2[Backend: Processar Mensagem]
        D2 -->|Chunks com conversation_id| C23[Criar responseDiv]
        C23 --> C24[Atualizar em tempo real]
        C24 -->|Fim streaming| C25[Remover animação]
        C25 --> C26[Exibir resposta final]
        C26 --> C27[Atualizar histórico]
    end

    %% Nível 1: Backend
    subgraph Backend_do_Sistema
        D1 --> D3[Receber video_url e conversation_id]
        D3 -->|Chamada API| F1[API YouTube]
        F1 -->|Dados| D3
        D3 --> D4{Processamento OK?}
        D4 -->|Sim| D5[Retornar texto processado com conversation_id]
        D4 -->|Não| D6[Retornar erro com conversation_id]
        D5 -->|Armazenar| E1[JSON ou Banco]
        D6 -->|Armazenar| E1

        D2 --> D7[Receber message e conversation_id]
        D7 --> D8[Chamada ao modelo de IA]
        D8 -->|Streaming| D9[Processar chunks]
        D9 -->|Chunks com conversation_id| D10[Enviar ao frontend via Socket.IO]
        D10 -->|Resposta completa| D11[Retornar ao frontend]
        D11 -->|Armazenar| E1
    end

    %% Eventos
    E1 -->|Histórico atualizado| C28[Evento: historicoAtualizado]

==========================================
Conteúdo de 3-implementacao-streaming-mensagens.md (caminho: linha_de_raciocinio\3-implementacao-streaming-mensagens.md):
==========================================
**Documentação do Projeto - Sistema de Chat com Streaming**  
**Última Atualização:** 25/04/2024  
**Status Atual:** Resolução de duplicação de mensagens pós-reinicialização  

---

### **Contexto do Problema**  
**Problema:** Duplicação de containers de mensagem após reiniciar servidor/página, com dois sistemas concorrentes:  
1. Streaming em tempo real (`message_chunk`)  
2. Renderização pós-completo (`response_complete`)  

**Evidência no HTML:**  
```html
<!-- Container de streaming (vazio) -->
<div id="message-bc061d98-..." class="message assistant">
    <div class="message-content"></div> 
</div>

<!-- Mensagem final duplicada -->
<div class="message assistant">
    <div class="message-content">...</div> 
</div>
```

---

### **Solução Implementada**  
#### Passo 1: Unificação de Containers  
**Arquivo:** `static/js/messageRenderer.js`  
```javascript
// Controle de estado global
let activeStreams = new Map();

export const renderMessageChunk = (messageId, chunk) => {
    if (!activeStreams.has(messageId)) {
        const container = document.createElement('div');
        container.className = 'message assistant streaming';
        container.dataset.messageId = messageId;
        document.querySelector('.chat-container').appendChild(container);
        activeStreams.set(messageId, {
            container,
            content: ''
        });
    }
    
    const stream = activeStreams.get(messageId);
    stream.content += chunk;
    stream.container.innerHTML = DOMPurify.sanitize(marked.parse(stream.content + '<span class="cursor">█</span>'));
};
```

#### Passo 2: Desativação da Renderização Final  
**Arquivo:** `static/js/chat/chatActions.js`  
```javascript
// Comentar/remover esta seção:
// socket.on('response_complete', ({ messageId }) => {
//     // Código que causa duplicação
// });
```

---

### **Checklist de Verificação**  
1. [ ] Backend está usando **mesmo messageId** para chunks e conclusão  
2. [ ] Evento `response_complete` está **comentado/removido**  
3. [ ] Sistema de cache (`activeStreams`) está sendo **limpo após erro/reinício**  
4. [ ] Containers vazios são **removidos automaticamente** (código abaixo)  

---

### **Código de Limpeza Automática**  
**Adicionar em `messageRenderer.js`:**  
```javascript
// Limpeza de containers órfãos a cada 5s
setInterval(() => {
    document.querySelectorAll('.message.assistant').forEach(container => {
        if (!container.querySelector('.message-content').innerHTML.trim()) {
            container.remove();
        }
    });
}, 5000);
```

---

### **Próximos Passos**  
1. **Teste de Reinicialização Forçada**  
   ```bash
   while true; do curl http://localhost:5000/restart-server; sleep 5; done
   ```
2. **Monitoramento de Estado**  
   ```javascript
   // Debug no console
   setInterval(() => {
       console.log('Active Streams:', Array.from(activeStreams.keys()));
   }, 3000);
   ```

---

### **Notas Técnicas**  
- **Critical Path:** Garantir que o `messageId` seja **imutável** durante todo o ciclo da mensagem  
- **Armadilha Comum:** Containers fantasmas de sessões anteriores não limpos  
- **Solução Alternativa:** Usar `sessionStorage` para persistir estado entre recarregamentos  

[Relatar problema ou continuar diagnóstico ▶](https://github.com/seu-usuario/chat-system/issues)


-------------

Vou documentar o que foi feito até agora em português:

1. **Análise Inicial do Problema**:
   - Identificamos um problema de duplicação de mensagens no sistema de chat
   - O problema ocorre mesmo após reiniciar o servidor e a página
   - Há containers vazios e duplicados no HTML

2. **Implementações Realizadas**:

   a) **Em `messageRenderer.js`**:
   - Adicionamos um sistema de cache para chunks de mensagem
   - Implementamos limpeza de containers vazios
   - Adicionamos um sistema de backup para limpeza periódica
   - Melhoramos o scroll automático
   - Adicionamos estilos para o cursor piscante

   b) **Em `chatActions.js`**:
   - Adicionamos monitoramento de streams ativos
   - Removemos a duplicação no evento `response_complete`
   - Implementamos um log periódico para debug

3. **Estrutura Atual do Sistema**:

   ```javascript
   // messageRenderer.js
   const messageCache = new Map();
   let activeStreams = new Set();

   export const renderMessageChunk = (messageId, chunk, isComplete = false) => {
       // Lógica de renderização de chunks
   };

   export const completeMessage = (messageId) => {
       // Lógica de conclusão de mensagem
   };

   // Sistema de backup para limpeza
   const backupContainerCheck = setInterval(() => {
       // Limpeza de containers vazios
   }, 5000);
   ```

   ```javascript
   // chatActions.js
   const streamingMessages = new Set();
   let activeStreams = new Set();

   export const handleSocketMessages = (socket) => {
       socket.on('message_chunk', ({ messageId, content }) => {
           // Lógica de streaming
       });

       socket.on('response_complete', ({ messageId }) => {
           // Lógica de conclusão
       });

       socket.on('stream_error', ({ messageId }) => {
           // Tratamento de erros
       });
   };
   ```

4. **Problemas Identificados**:
   - Possível conflito entre eventos de streaming e renderização final
   - Inconsistência nos `messageId`s
   - Containers vazios não sendo limpos adequadamente
   - Possível vazamento de memória com referências a elementos DOM

5. **Próximos Passos Sugeridos**:
   - Verificar e desativar o evento `response_complete`
   - Garantir consistência nos `messageId`s
   - Refinar a lógica de limpeza
   - Implementar verificações periódicas
   - Testar com diferentes cenários

6. **Melhorias Implementadas**:
   - Unificação do sistema de renderização
   - Melhor gerenciamento de estado
   - Limpeza automática de recursos
   - Tratamento de erros mais robusto

7. **Pontos de Atenção**:
   - Necessidade de sincronização entre frontend e backend
   - Importância da consistência dos IDs de mensagem
   - Gerenciamento adequado do ciclo de vida dos containers
   - Monitoramento e limpeza de recursos

Você gostaria que eu detalhasse algum aspecto específico ou que prosseguíssemos com alguma das melhorias sugeridas?



==========================================
Conteúdo de 4-resolucao-problemas-duplicacao-mensagens.md (caminho: linha_de_raciocinio\4-resolucao-problemas-duplicacao-mensagens.md):
==========================================
# Resolução de Problemas: Sistema de Chat com IA

## Análise do Problema

Durante o desenvolvimento do projeto, identificamos e corrigimos vários problemas relacionados à duplicação de mensagens e gestão de estado durante o streaming. A análise do arquivo de log `app_20250425.log` mostra que as correções que implementamos foram bem-sucedidas, com o sistema funcionando corretamente.

## Principais Problemas Resolvidos

1. **Erro na função `completeMessage`**:
   - Identificamos que havia uma incompatibilidade entre a chamada ao método `messageRegistry.completeMessage()` e sua implementação.
   - O método estava sendo chamado com dois parâmetros (`messageId` e `conversationId`), mas a implementação aceitava apenas um parâmetro (`messageId`).
   - Corrigimos as chamadas nos arquivos `messageRenderer.js` e `streamingManager.js` para passar apenas o parâmetro `messageId`.

2. **Problema com a renderização de conteúdo**:
   - Modificamos a função `renderContent` para atualizar apenas o conteúdo dentro da div `message-content`, em vez de substituir toda a estrutura do container de mensagem.
   - Isso garantiu que os botões de ação e outras estruturas permanecessem intactos durante a atualização do conteúdo.

3. **Função `createContainer`**:
   - Implementamos a função `createContainer` que estava faltando, permitindo a criação adequada de containers para novas mensagens.
   - A função verifica a existência de containers existentes e cria novos quando necessário.

4. **Função `cleanupOrphan`**:
   - Corrigimos a função para usar os métodos corretos do `messageRegistry`: `getMessage` em vez de `get` e `removeMessage` em vez de `delete`.
   - Isso garantiu a correta limpeza de mensagens órfãs no DOM.

## Arquitetura do Sistema

O sistema utiliza uma arquitetura baseada em:

1. **Backend (Flask/Python)**:
   - Gerencia conversas e histórico
   - Integra com modelos de IA
   - Fornece endpoints para envio e recebimento de mensagens via Socket.IO

2. **Frontend (JavaScript)**:
   - Utiliza módulos organizados para gerenciar diferentes aspectos do chat
   - `messageRegistry.js`: Sistema centralizado para controle do ciclo de vida das mensagens
   - `streamingManager.js`: Gerencia o streaming em tempo real
   - `messageRenderer.js`: Responsável pela renderização das mensagens
   - `chatActions.js`: Controla as ações do usuário no chat
   - `chatUI.js`: Gerencia a interface de usuário do chat

3. **Sistema de Comunicação**:
   - Unificado em Socket.IO, eliminando o uso de Server-Sent Events (SSE)
   - Eventos como `message_chunk` e `response_complete` coordenam o ciclo de vida das mensagens

## Lições Aprendidas

1. **Importância da centralização do registro de mensagens**:
   - O `messageRegistry` centralizado evita duplicação de mensagens
   - Mantém a consistência do estado entre diferentes componentes

2. **Consistência nos métodos de API**:
   - É crucial que a chamada de métodos corresponda à sua implementação
   - Documentar adequadamente a assinatura dos métodos

3. **Depuração eficiente**:
   - O sistema de logging detalhado permite identificar rapidamente problemas
   - Manter consistência na nomenclatura e nos identificadores facilita o diagnóstico

4. **Gerenciamento de estado**:
   - Utilizar uma fonte única de verdade para o estado das mensagens
   - Implementar mecanismos de limpeza para evitar vazamentos de memória

## Mudanças Implementadas

1. **Fase 1 - Centralização do `messageRegistry`**:
   - Criação de um registro centralizado para todas as mensagens
   - Garantia de acesso consistente ao registry em todos os módulos

2. **Fase 2 - Correção de erros críticos**:
   - Implementação da função `createContainer` ausente
   - Correção no `cleanupOrphan` para usar os métodos corretos

3. **Fase 3 - Refinamento da renderização**:
   - Melhoria na função `renderContent` para preservar a estrutura DOM
   - Correção nas chamadas a `completeMessage` para usar a assinatura correta

4. **Fase 4 - Validação final**:
   - Verificação do log para confirmar operação correta
   - Teste de integração com processamento de mensagens em tempo real

## Estado Atual

O arquivo de log `app_20250425.log` demonstra que o sistema está funcionando corretamente:
- As conexões Socket.IO são estabelecidas com sucesso
- As mensagens são enviadas e recebidas corretamente
- O streaming de chunks funciona adequadamente
- As mensagens são completadas sem erros fatais

Há apenas um erro não crítico relacionado à função `marked.parse()` com parâmetros nulos, que pode ser investigado em uma próxima iteração, mas não impede o funcionamento principal do sistema.

## Próximos Passos Recomendados

1. **Resolver o erro com `marked.parse()`**:
   - Investigar por que está recebendo parâmetros nulos
   - Implementar validação adequada antes da chamada

2. **Melhorar o tratamento de erros**:
   - Implementar recuperação mais robusta de falhas
   - Adicionar notificações visuais de erros para o usuário

3. **Otimizações de desempenho**:
   - Implementar renderização virtual para grandes históricos
   - Otimizar a limpeza de containers órfãos

4. **Expansão de funcionalidades**:
   - Implementar as melhorias sugeridas na documentação
   - Desenvolver recursos de exportação e compartilhamento 


==========================================
Conteúdo de 5-problemas-interacao-eventos.md (caminho: linha_de_raciocinio\5-problemas-interacao-eventos.md):
==========================================
# Problemas de Interação com Eventos no Sistema de Chat

## Resumo do Problema

Durante o desenvolvimento e manutenção do sistema de chat, encontramos diversos problemas relacionados ao tratamento de eventos JavaScript, especialmente na interação entre diferentes componentes do sistema. Os problemas principais estavam relacionados a:

1. **Inconsistência no tratamento de eventos de formulário** - Problemas com `preventDefault()` e com objetos de evento personalizados
2. **Gestão do cursor de digitação** - Falhas ao criar e remover o cursor de digitação durante o ciclo de mensagens
3. **Elementos DOM não encontrados** - Tentativas de manipular elementos antes de estarem disponíveis no DOM
4. **Problemas de sincronização entre eventos** - Desafios na coordenação entre eventos de envio, recebimento e renderização de mensagens
5. **Problemas na gestão de estado** - Dificuldades em manter o estado consistente entre diferentes componentes

## Problemas Específicos e Soluções Tentadas

### 1. Problema com o método `preventDefault()`

**Problema**: Ao enviar mensagens usando a tecla Enter no textarea, ocorria um erro do tipo "TypeError" indicando que `e.preventDefault is not a function`. Este erro ocorria quando eventos de submit eram criados manualmente sem implementar completamente a interface de eventos.

**Análise**: No arquivo `textarea.js`, identificamos que estava sendo criado um evento de submit personalizado usando `new Event('submit')` que não tinha o método `preventDefault()` implementado.

**Solução tentada**: 
- Modificamos o código para usar `SubmitEvent` quando disponível
- Implementamos um fallback para criar um `Event` regular com uma implementação manual de `preventDefault()`
- Adicionamos verificação de tipo antes de chamar `preventDefault()` na função `enviarMensagem`

```javascript
try {
    const event = new SubmitEvent('submit', {
        bubbles: true,
        cancelable: true
    });
    form.dispatchEvent(event);
} catch (error) {
    console.debug("[TEXTAREA] Fallback para Event padrão:", error);
    let event = new Event('submit', {
        bubbles: true,
        cancelable: true
    });
    
    if (typeof event.preventDefault !== 'function') {
        event.preventDefault = function() {
            console.debug("[TEXTAREA] preventDefault chamado no evento personalizado");
        };
    }
    
    form.dispatchEvent(event);
}
```

**Resultado**: Mesmo com esta correção, ainda ocorreram problemas em alguns navegadores ou condições específicas, sugerindo que a disparidade entre os diferentes tipos de eventos é mais complexa do que o esperado.

### 2. Problema com Tratamento de Parâmetros em `enviarMensagem`

**Problema**: A função `enviarMensagem` não estava preparada para lidar com diferentes tipos de parâmetros (eventos vs. string de mensagem).

**Análise**: A função estava assumindo que o primeiro parâmetro era sempre um evento, mas em alguns casos era chamada diretamente com uma string. Além disso, havia inconsistências entre as chamadas de diferentes partes do código.

**Solução tentada**: 
- Refatoramos a função para aceitar tanto um objeto de evento quanto uma string diretamente
- Adicionamos verificações de tipo robustas para determinar como tratar o parâmetro
- Implementamos código defensivo para lidar com erros de `preventDefault()`

```javascript
function enviarMensagem(eventOrMessage, conversationId) {
    console.debug("[CHAT ACTIONS] Tentativa de enviar mensagem, parâmetro:", eventOrMessage);
    
    // Verificar se o primeiro parâmetro é um evento e prevenir comportamento padrão
    let mensagem = '';
    if (eventOrMessage && typeof eventOrMessage === 'object' && eventOrMessage.preventDefault && typeof eventOrMessage.preventDefault === 'function') {
        try {
            eventOrMessage.preventDefault();
            console.debug("[CHAT ACTIONS] Evento de formulário interceptado e prevenido");
        } catch (err) {
            console.warn("[CHAT ACTIONS] Erro ao prevenir evento:", err);
        }
        // Obter mensagem do campo de entrada
        const messageInput = document.getElementById('message-input');
        mensagem = messageInput ? messageInput.value.trim() : '';
    } else if (typeof eventOrMessage === 'string') {
        // O primeiro parâmetro já é a mensagem
        mensagem = eventOrMessage.trim();
    } else {
        console.error("[CHAT ACTIONS] Parâmetro inválido para enviarMensagem:", eventOrMessage);
        return Promise.resolve(false);
    }
    
    // [resto da função...]
}
```

**Resultado**: A função ficou mais robusta, mas introduziu complexidade adicional. O ideal seria padronizar todas as chamadas para usar um formato consistente em todo o código.

### 3. Problema com Elementos DOM não Encontrados

**Problema**: Ocorreram erros indicando que elementos como `.chat-container` não foram encontrados, causando erros de `appendChild is not a function`.

**Análise**: Identificamos que algumas funções estavam tentando manipular elementos DOM antes que estivessem disponíveis ou em condições onde não existiam. Isso ocorria especialmente durante a inicialização da aplicação ou durante mudanças de conversas.

**Solução tentada**:
- Adicionamos verificações mais robustas de existência de elementos antes de operações DOM
- Verificamos se elementos são instâncias válidas de `Element` antes de chamar métodos DOM
- Adicionamos tratamento de erros para falhas de manipulação DOM

```javascript
// Verificar se o contêiner de chat existe
const chatContainer = document.querySelector('.chat-container');
if (!chatContainer || !(chatContainer instanceof Element)) {
    console.error("[CHAT ACTIONS] Contêiner de chat não encontrado ou inválido");
    alert("Erro ao enviar mensagem: contêiner de chat não encontrado. Tente recarregar a página.");
    return Promise.resolve(false);
}
```

**Resultado**: Reduziu os erros não tratados, mas ainda havia ocasiões onde os elementos não eram encontrados devido à ordem de carregamento ou a problemas de timing.

### 4. Problema com Gerenciamento de Cursores de Digitação

**Problema**: O sistema de criação e remoção de cursores de digitação estava falhando, especialmente em casos de erro durante o envio de mensagens.

**Análise**: O código para gerenciar cursores não estava verificando adequadamente a existência dos elementos DOM necessários e não tinha um ciclo de vida claro, resultando em cursores órfãos ou duplicados.

**Solução tentada**:
- Verificação robusta da existência do `chatContainer` antes de criar cursores
- Tratamento adequado de erros durante a criação do cursor
- Implementação correta de limpeza em caso de falha de envio

```javascript
// Criar cursor de digitação
let cursorContainer = null;
try {
    cursorContainer = cursorManager.createCursor(activeConversationId);
    console.debug("[CHAT ACTIONS] Cursor de digitação criado para conversa:", activeConversationId);
} catch (err) {
    console.warn("[CHAT ACTIONS] Erro ao criar cursor de digitação:", err);
    // Continuar mesmo sem o cursor
}
```

**Resultado**: O tratamento de erros melhorou, mas ainda havia casos onde os cursores persistiam indevidamente ou não eram criados quando deveriam.

### 5. Problema de Gestão de Estado e Comunicação entre Componentes

**Problema**: Diversos componentes do sistema (chat UI, cursor, mensagens) tentavam gerenciar seu próprio estado sem uma coordenação central, levando a estados inconsistentes.

**Análise**: A arquitetura do sistema consistia em módulos frouxamente acoplados que se comunicavam principalmente através de manipulação direta do DOM ou eventos personalizados, sem um fluxo de dados claro.

**Solução tentada**:
- Criação de um sistema centralizado de registro de mensagens (`messageRegistry`)
- Implementação de mecanismos de comunicação via eventos do socket
- Tentativa de sincronização dos estados em pontos-chave do ciclo de vida das mensagens

**Resultado**: Resolveu parcialmente o problema, mas a falta de uma estrutura mais robusta de gestão de estado continuou causando problemas de sincronização.

## Lições Aprendidas

1. **Validação rigorosa de tipos** - Sempre verificar o tipo dos parâmetros antes de acessar propriedades ou métodos.

2. **Verificação de elementos DOM** - Nunca assumir que elementos DOM estão presentes; sempre verificar antes de manipulá-los.

3. **Tratamento defensivo de eventos** - Ao criar eventos personalizados, garantir que eles tenham todos os métodos necessários.

4. **Logging abrangente** - Implementar um sistema de logging que capture informações detalhadas sobre o estado do sistema.

5. **Promessas em vez de valores diretos** - Retornar Promises consistentemente ao lidar com operações assíncronas.

6. **Tratamento de erros em cadeia** - Usar `catch` e `finally` para garantir que recursos sejam liberados mesmo em caso de erro.

7. **Gerenciamento de estado claro** - Manter um fluxo de estado claro para recursos como cursores de digitação.

8. **Fallbacks para APIs de navegador** - Implementar fallbacks para APIs que podem não estar disponíveis em todos os navegadores.

9. **Arquitetura orientada a eventos com cautela** - Usar eventos com cuidado, pois introduzem acoplamento implícito difícil de rastrear.

10. **Evitar manipulação DOM direta em componentes de lógica** - Separar claramente a lógica de negócio da manipulação do DOM.

## Proposta de Reestruturação

Para resolver os problemas de forma mais definitiva, sugerimos uma reestruturação significativa da arquitetura:

### 1. Adoção de um Fluxo de Dados Unidirecional

Implementar uma arquitetura de fluxo de dados unidirecional inspirada em padrões como Flux ou Redux:

```
┌─────────┐       ┌──────────┐       ┌─────────┐       ┌──────┐
│  Ações  │──────▶│  Estado  │──────▶│  Views  │──────▶│ DOM  │
└─────────┘       └──────────┘       └─────────┘       └──────┘
     ▲                                    │                
     └────────────────────────────────────┘                
```

### 2. Separação Mais Clara entre Componentes

Dividir o sistema em camadas bem definidas:

- **Camada de UI**: Responsável apenas por renderizar a interface com base no estado
- **Camada de Estado**: Gerencia todo o estado da aplicação de forma centralizada
- **Camada de Serviços**: Lida com comunicação com o servidor, WebSockets, etc.
- **Camada de Utilitários**: Funções puras para transformação de dados

### 3. Sistema de Tipos Rigoroso

Adotar TypeScript para todo o código frontend, definindo interfaces claras para:

- Tipos de mensagens
- Estados de conversas
- Eventos de socket
- Parâmetros de funções

### 4. Sistema de Testes Automatizados

Implementar testes automatizados para:

- Comportamento da UI
- Fluxo de mensagens
- Manipulação de eventos
- Casos de erro e recuperação

### 5. Sistema de Monitoramento em Tempo Real

Desenvolver um sistema de telemetria que permita visualizar:

- Estado atual de todas as conversas
- Mensagens em trânsito
- Erros e exceções
- Tempos de resposta e desempenho

## Próximos Passos Imediatos

Para resolver os problemas atuais sem uma reescrita completa:

1. **Padronizar assinaturas de funções** - Garantir que todas as funções usem parâmetros consistentes em todo o código.

2. **Centralizar validação DOM** - Criar utilitários compartilhados para verificação de elementos DOM.

3. **Melhorar o isolamento de componentes** - Garantir que cada componente (cursor, mensagem, etc.) tenha seu próprio ciclo de vida isolado.

4. **Implementar system de retry** - Adicionar mecanismos de retry para operações que podem falhar devido a timing.

5. **Introduzir um middleware de eventos** - Criar uma camada intermediária para normalizar eventos e garantir propriedades necessárias.

## Conclusão

Os problemas enfrentados destacam a importância de uma abordagem defensiva na programação frontend, especialmente ao lidar com eventos, manipulação DOM e comunicação assíncrona. As soluções implementadas aumentaram a robustez do sistema, mas será necessária uma revisão mais abrangente da arquitetura para resolver completamente os problemas.

O atual sistema está utilizando uma abordagem muito orientada a eventos com manipulação direta do DOM, o que torna o fluxo de dados difícil de rastrear e propenso a erros. Uma arquitetura mais declarativa com fluxo de dados unidirecional ajudaria a resolver muitos dos problemas encontrados.

**Recomendação final**: Considerar uma reescrita gradual dos componentes mais problemáticos, começando pelo sistema de mensagens e cursor, usando uma abordagem mais moderna e declarativa.


----------------------

# Sistema de Chat com Streaming - Linha de Raciocínio Visão Geral

Este documento descreve o estado atual do sistema de chat com streaming de respostas em tempo real, apresentando o que foi implementado e os próximos passos do desenvolvimento.

## Status Atual (Abril 2025)

* Streaming de respostas em tempo real via Socket.IO
* Persistência de conversas
* Integração com processamento de vídeos do YouTube
* Renderização de markdown nas mensagens

## Últimas Implementações (27/04/2025)

* Correções no sistema de Socket.IO
* Implementado fluxo que entra na nova sala imediatamente
* Saída da sala anterior adiada até receber o evento response_complete
* Adicionadas variáveis globais para rastreamento de mensagens ativas
* Aprimoramento do messageRegistry:
	+ Adicionadas flags isCursor, isComplete e isStreaming
	+ Lógica refinada para preservar apenas mensagens relevantes
	+ Sistema de limpeza automatizada que preserva mensagens completas

## Melhorias Visuais

* Implementada animação de "três pontinhos" para feedback durante carregamento – isso aqui precisa ser revisado pois não está funcionando
* Corrigida importação do módulo marked usando CDN

## Próximos Passos Prioritários

### Sistema de IDs Unificado

* Implementar geração consistente de IDs entre backend e frontend
* Garantir que não ocorram duplicações ou conflitos

### Integração com YouTube

* Finalizar integração do sistema de streaming com processamento de YouTube
* Testar casos específicos de resumo e transcrição

### Testes de Integração

* Testar troca de conversas durante streaming ativo
* Verificar comportamento com mensagens longas e formatação complexa
* Validar interação entre YouTube e streaming

## Arquivos Principais

* `static/js/chat/chatActions.js` - Gerenciamento da comunicação via Socket.IO
* `static/js/modules/streamingManager.js` - Controle do ciclo de vida das mensagens
* `static/css/streaming.css` - Animações e estilos para feedback visual
* `app.py` - Backend Flask com handlers de Socket.IO

==========================================
Conteúdo de animacao-carregamento.md (caminho: linha_de_raciocinio\animacao-carregamento.md):
==========================================
# Substituição do Sistema de Feedback Visual Durante Carregamento

## Problema Original

O sistema antigo de feedback visual durante o carregamento ("três pontinhos") apresentava dois problemas principais:

1. **O cursor antigo ("Gerando resposta...")** continuava aparecendo no DOM mesmo após a implementação da nova animação centralizada
2. **Containers vazios** sendo criados, poluindo a interface e causando problemas visuais
3. **Erro no código**: `TypeError: messageRegistry.forEach is not a function` ocorria periodicamente

## Diagnóstico

Após análise do código e logs, identificamos as seguintes causas:

1. **Múltiplos pontos de criação do cursor antigo**:
   - Em `chatActions.js` na função `carregarConversa`
   - Em `chatSync.js` durante o evento `message_chunk`
   - Em `streamingManager.js` no método `createMessageContainer`

2. **Animação de carregamento centralizada implementada parcialmente**:
   - O elemento HTML havia sido adicionado, mas não todas as integrações necessárias

3. **Erro de tipo no messageRegistry**:
   - O método `cleanupOrphan` em `streamingManager.js` tentava usar `messageRegistry.forEach()`, mas `messageRegistry` é um `Map`

## Soluções Implementadas

### 1. Remoção da Mensagem "Gerando resposta..."

Modificamos todos os locais que criavam o cursor antigo:

- Em `chatActions.js`:
  ```javascript
  // Antes
  if (isStreaming) {
      const streamingMessage = document.createElement('div');
      streamingMessage.className = 'message assistant streaming-message';
      streamingMessage.dataset.conversationId = conversationId;
      streamingMessage.innerHTML = '<div class="message-content">Gerando resposta...</div>';
      chatContainer.appendChild(streamingMessage);
  }
  
  // Depois
  if (isStreaming) {
      const loadingAnimation = document.getElementById('loading-animation');
      if (loadingAnimation) {
          loadingAnimation.style.display = 'block';
          logger.debug('Animação de carregamento exibida ao carregar conversa em streaming');
      }
  }
  ```

- Em `chatSync.js`:
  ```javascript
  // Antes
  let streamingMessage = chatContainer.querySelector(`.message.assistant.streaming-message[data-conversation-id="${data.conversation_id}"]`);
  if (!streamingMessage) {
      streamingMessage = document.createElement('div');
      streamingMessage.className = 'message assistant streaming-message';
      streamingMessage.dataset.conversationId = data.conversation_id;
      streamingMessage.innerHTML = '<div class="message-content">Gerando resposta...</div>';
      chatContainer.appendChild(streamingMessage);
  }
  
  // Depois
  const loadingAnimation = document.getElementById('loading-animation');
  if (loadingAnimation && loadingAnimation.style.display === 'block') {
      loadingAnimation.style.display = 'none';
      console.log('[DEBUG] Animação de carregamento ocultada após receber chunk');
  }
  ```

- Em `streamingManager.js`:
  ```javascript
  // Antes
  messageDiv.innerHTML = `<div class="message-content"><div class="loading-dots"><span>.</span><span>.</span><span>.</span></div></div>`;
  
  // Depois
  messageDiv.innerHTML = `<div class="message-content"></div>`;
  
  // E adicionamos suporte à animação centralizada
  const loadingAnimation = document.getElementById('loading-animation');
  if (loadingAnimation && loadingAnimation.style.display !== 'block') {
      loadingAnimation.style.display = 'block';
      logger.debug('Animação de carregamento exibida ao criar container de mensagem');
  }
  ```

### 2. Integração da Animação Centralizada em Todos os Pontos Críticos

Garantimos o controle da animação em todos os pontos-chave do fluxo:

1. **Ao enviar uma mensagem**:
   ```javascript
   // Mostrar animação de carregamento centralizada
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation) {
       loadingAnimation.style.display = 'block';
       logger.debug('Animação de carregamento exibida');
   }
   ```

2. **Ao receber o primeiro chunk**:
   ```javascript
   // Ocultar a animação de carregamento ao receber o primeiro chunk
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após receber chunk');
   }
   ```

3. **Ao completar a resposta**:
   ```javascript
   // Ocultar a animação de carregamento ao completar a resposta
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após completar resposta');
   }
   ```

4. **Em caso de erro**:
   ```javascript
   // Ocultar a animação de carregamento em caso de erro
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após erro no streaming');
   }
   ```

5. **Ao interromper a resposta**:
   ```javascript
   // Ocultar a animação de carregamento
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation) {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após interrupção');
   }
   ```

### 3. Corrigido o Erro no streamingManager.js

Corrigimos o método `cleanupOrphan` para usar a abordagem correta de iteração sobre Maps:

```javascript
// Antes
messageRegistry.forEach((entry, messageId) => {
    // código...
});

// Depois
for (const [messageId, entry] of messageRegistry.entries()) {
    // código...
}
```

### 4. Atualizamos as Seleções de Elementos no DOM

Removemos todas as referências à classe `.streaming-message` em seletores, substituindo:

```javascript
// Antes
const streamingMessages = chatContainer.querySelectorAll('.message.assistant.streaming-message');

// Depois
// Simplesmente removemos ou substituímos por elementos reais
```

## Resultado

Com estas mudanças:

1. O cursor antigo ("Gerando resposta...") foi completamente removido do sistema
2. A animação de carregamento centralizada (com ícone spinner) agora funciona em todos os cenários
3. Não são mais criados containers vazios no fluxo do chat
4. O erro `TypeError: messageRegistry.forEach is not a function` foi corrigido

O sistema agora apresenta um feedback visual consistente e elegante durante o carregamento das respostas da IA, proporcionando uma melhor experiência ao usuário.

## Considerações para o Futuro

1. O código antigo dos "três pontinhos" foi preservado em formato de comentário (marcado como "CÓDIGO PARA REVISÃO FUTURA") para referência
2. A estrutura atual já suporta fácil extensão para animações mais elaboradas, se necessário
3. Todo o sistema foi documentado com logs de debug para facilitar a manutenção futura 

==========================================
Conteúdo de arvore-funcoes.md (caminho: linha_de_raciocinio\arvore-funcoes.md):
==========================================
### 1. ÁRVORE
```
Listagem de caminhos de pasta
C:.
|   app.py
|   cleanup_ports.py
|   DevMenu.bat
|   DOCUMENTACAO.md
|   iniciar_servidor.bat
|   init_eventlet.py
|   README.md
|   youtube_handler.py
|   
+---linha_de_raciocinio
|       1- documentaþÒo.md
|       2- DFD com foco no youtube- 2025-04-02.png
|       2- DFD com foco no youtube.md
|       3-implementacao-streaming-mensagens.md
|       4-resolucao-problemas-duplicacao-mensagens.md
|       5-problemas-interacao-eventos.md
|       animacao-carregamento.md
|       arvore-funcoes.md
|       Comandos_Rßpidos.xlsx
|       documentacao-sistema.md
|       documentacao_atualizada.md
|       implementacao-streaming-continuo-resumo.md
|       leia-me.md
|       linha_de_raciocinio_atualizada.md
|       Plano-implementacao.md
|       README.md
|       resolucao-problemas-limpeza-mensagens.md
|       
+---static
|   |   1favicon.ico
|   |   favicon.ico
|   |   
|   +---css
|   |   |   messages.css
|   |   |   streaming.css
|   |   |   style.css
|   |   |   styles.css
|   |   |   variables.css
|   |   |   
|   |   +---base
|   |   |       .gitkeep
|   |   |       reset.css
|   |   |       typography.css
|   |   |       variables.css
|   |   |       
|   |   +---components
|   |   |       .gitkeep
|   |   |       buttons.css
|   |   |       code-highlight.css
|   |   |       command-menu.css
|   |   |       forms.css
|   |   |       messages.css
|   |   |       
|   |   +---layout
|   |   |       .gitkeep
|   |   |       container.css
|   |   |       main-content.css
|   |   |       sidebar.css
|   |   |       
|   |   \---themes
|   |           .gitkeep
|   |           dark-theme.css
|   |           light-theme.css
|   |           
|   \---js
|       |   chat.js
|       |   commandMenu.js
|       |   events.js
|       |   init.js
|       |   main.js
|       |   messageRenderer.js
|       |   sidebar.js
|       |   textarea.js
|       |   theme.js
|       |   utils.js
|       |   
|       +---backup
|       |       chatUI.js
|       |       messageRegistry.js
|       |       
|       +---chat
|       |       chatActions.js
|       |       chatStorage.js
|       |       chatSync.js
|       |       chatUI.js
|       |       chatUtils.js
|       |       
|       +---modules
|       |       commandHandler.js
|       |       inputBar.js
|       |       messageRegistry.js
|       |       streamingManager.js
|       |       
|       +---utils
|       |       logger.js
|       |       
|       \---youtube-system
|               youtubeEvents.js
|               youtubeHandler.js
|               youtubeResumoHandler.js
|               
+---templates
|       index.html
|       youtube.html
|       
\---utils
        chat_storage.py
```        

### 2. MAPEAMENTO COMPLETO DE FUNÇÕES DO SISTEMA

```
   As árvores estão no formato de code snippet tree structure, usando ícones para pastas (📁), arquivos (📄), funções locais (🔧), e funções exportadas (📤), conforme o exemplo abaixo:
   📁 js/
   ├── 📁 chat/
   │   ├── 📄 chatActions.js
   │   │   ├── 🔧 nomeFuncao()
   │   │   ├── 📤 nomeFuncaoExportada() 
   │   │   ├── ⬇️ nomeFuncaoImportada() 
```


## 2.1. ARQUIVOS JAVASCRIPT

```
📁 project/
├── 📁 chat/
│   ├── 📄 chatUI.js
│   │   ├── ⬇️ escapeHTML() [from './chatUtils.js']
│   │   ├── ⬇️ renderMarkdown() [from '../messageRenderer.js']
│   │   ├── ⬇️ renderMessageContainer() [from '../messageRenderer.js']
│   │   ├── ⬇️ setCurrentConversation() [from '../messageRenderer.js']
│   │   ├── ⬇️ melhorarBlocosCodigo() [from './chatUtils.js']
│   │   ├── ⬇️ streamingManager [from '../modules/streamingManager.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── 📤 iniciarChat()
│   │   ├── 📤 mostrarTelaInicial()
│   │   ├── 📤 adicionarMensagem()
│   │   ├── 📤 atualizarMensagemStreaming()
│   │   ├── 📤 mostrarCarregamento()
│   │   ├── 📤 handleMessageChunk()
│   │   ├── 📤 chatUI [instance]
│   │   ├── [class] ChatUI
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 initializeEventListeners()
│   │   │   ├── 🔧 sendMessage()
│   │   │   ├── 🔧 appendUserMessage()
│   │   │   ├── 🔧 handleConversationChange()
│   │   │   ├── 🔧 loadConversationHistory()
│   │   │   ├── 🔧 displayConversationHistory()
│   │   │   ├── 🔧 showError()
│   │   │   ├── 🔧 scrollToBottom()
│   │   │   ├── 🔧 escapeHtml()
│   ├── 📄 chatActions.js
│   │   ├── ⬇️ chatUI [from './chatUI.js']
│   │   ├── ⬇️ adicionarMensagemAoHistorico() [from './chatStorage.js']
│   │   ├── ⬇️ criarNovaConversa() [from './chatStorage.js']
│   │   ├── ⬇️ atualizarListaConversas() [from './chatStorage.js']
│   │   ├── ⬇️ renderMessage() [from '../messageRenderer.js']
│   │   ├── ⬇️ renderMessageChunk() [from '../messageRenderer.js']
│   │   ├── ⬇️ completeMessage() [from '../messageRenderer.js']
│   │   ├── ⬇️ messageRegistry [from '../modules/messageRegistry.js']
│   │   ├── ⬇️ melhorarBlocosCodigo() [from './chatUtils.js']
│   │   ├── ⬇️ handleYoutubeCommand() [from '../youtube-system/youtubeHandler.js']
│   │   ├── ⬇️ handleYoutubeResumoCommand() [from '../youtube-system/youtubeResumoHandler.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 🔧 inicializarConversa()
│   │   ├── 🔧 isUserAtBottom()
│   │   ├── 🔧 scrollToBottom()
│   │   ├── 🔧 handleStreamingScroll()
│   │   ├── 🔧 forcarRenderizacao()
│   │   ├── 🔧 isDuplicateMessage()
│   │   ├── 🔧 gerarMessageId()
│   │   ├── [class] ChatDebugger
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 log()
│   │   │   ├── 🔧 info()
│   │   │   ├── 🔧 debug()
│   │   │   ├── 🔧 warn()
│   │   │   ├── 🔧 error()
│   │   │   ├── 🔧 exportLogs()
│   │   ├── 📤 entrarNaSala()
│   │   ├── 📤 sairDaSala()
│   │   ├── 📤 atualizarBotoes()
│   │   ├── 📤 enviarMensagem()
│   │   ├── 📤 carregarConversa()
│   │   ├── 📤 interromperResposta()
│   │   ├── 📤 handleStreamChunk()
│   ├── 📄 chatStorage.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ messageRegistry [from '../modules/messageRegistry.js']
│   │   ├── 🔧 saveConversation()
│   │   ├── 🔧 loadConversation()
│   │   ├── 🔧 deleteConversation()
│   │   ├── 🔧 getAllConversations()
│   │   ├── 📤 adicionarMensagemAoHistorico()
│   │   ├── 📤 criarNovaConversa()
│   │   ├── 📤 atualizarListaConversas()
│   ├── 📄 chatSync.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ chatStorage [from './chatStorage.js']
│   │   ├── 🔧 syncConversation()
│   │   ├── 🔧 handleSyncResponse()
│   │   ├── 🔧 setupSyncListeners()
│   │   ├── 📤 syncMessages()
│   ├── 📄 chatUtils.js
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── 🔧 formatMessage()
│   │   ├── 🔧 validateInput()
│   │   ├── 📤 escapeHTML()
│   │   ├── 📤 melhorarBlocosCodigo()
│   ├── 📄 chat.js
│   │   ├── ⬇️ chatUI [from './chatUI.js']
│   │   ├── ⬇️ chatActions [from './chatActions.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── 🔧 showLoading()
│   │   ├── 🔧 hideLoading()
│   │   ├── 🔧 showError()
│   │   ├── 🔧 showSuccess()
│   │   ├── 📤 iniciarChat()
│   │   ├── 📤 mostrarTelaInicial()
│   │   ├── 📤 adicionarMensagem()
│   │   ├── 📤 mostrarCarregamento()
│   │   ├── 📤 enviarMensagem()
│   │   ├── 📤 interromperResposta()
├── 📁 modules/
│   ├── 📄 messageRegistry.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── [class] MessageRegistry
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 setupPeriodicCheck()
│   │   │   ├── 🔧 generateMessageId()
│   │   │   ├── 🔧 registerMessage()
│   │   │   ├── 🔧 getMessage()
│   │   │   ├── 🔧 updateMessage()
│   │   │   ├── 🔧 addChunk()
│   │   │   ├── 🔧 completeMessage()
│   │   │   ├── 🔧 removeMessage()
│   │   │   ├── 🔧 hasMessage()
│   │   │   ├── 🔧 getMessagesByConversation()
│   │   │   ├── 🔧 cleanOrphanContainers()
│   │   ├── 📤 messageRegistry [instance]
│   ├── 📄 streamingManager.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ messageRegistry [from './messageRegistry.js']
│   │   ├── ⬇️ renderMarkdown() [from '../messageRenderer.js']
│   │   ├── [class] StreamingManager
│   │   │   ├── 🔧 createMessageContainer()
│   │   │   ├── 🔧 renderStreamingContent()
│   │   │   ├── 🔧 renderCompleteMessage()
│   │   │   ├── 🔧 addActionButtons()
│   │   │   ├── 🔧 manageScroll()
│   │   │   ├── 🔧 registerMessage()
│   │   │   ├── 🔧 cleanupOrphan()
│   │   │   ├── 🔧 findMissingChunks()
│   │   │   ├── 🔧 getMessageTimingInfo()
│   │   │   ├── 🔧 calculateAverageChunkTiming()
│   │   │   ├── 🔧 validateContentMatch()
│   │   │   ├── 🔧 findFirstDifference()
│   │   │   ├── 🔧 checkForDuplicates()
│   │   │   ├── 🔧 calculateSimilarity()
│   │   ├── 📤 streamingManager [instance]
│   ├── 📄 commandHandler.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ commandMenu [from '../commandMenu.js']
│   │   ├── [class] CommandHandler
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 registerCommand()
│   │   │   ├── 🔧 executeCommand()
│   │   ├── 📤 handleCommand()
│   ├── 📄 inputBar.js
│   │   ├── ⬇️ chatUI [from '../chat/chatUI.js']
│   │   ├── ⬇️ commandHandler [from './commandHandler.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── 🔧 setupInputListeners()
│   │   ├── 🔧 handleInputSubmit()
│   │   ├── 📤 configureInputBar()
├── 📁 utils/
│   ├── 📄 logger.js
│   │   ├── 🔧 log()
│   │   ├── 📤 logger [instance]
├── 📄 commandMenu.js
│   ├── 📤 initCommandMenu()
├── 📄 events.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ theme [from './theme.js']
│   ├── ⬇️ sidebar [from './sidebar.js']
│   ├── ⬇️ textarea [from './textarea.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── 🔧 handleKeyboardShortcuts()
│   │   ├── 🔧 handleWindowResize()
│   │   ├── 🔧 handleSocketEvents()
│   │   ├── 📤 configureEventListeners()
├── 📄 init.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ streamingManager [from './modules/streamingManager.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── ⬇️ theme [from './theme.js']
│   ├── 🔧 initializeApp()
│   │   ├── 📤 default [socket]
├── 📄 main.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ chatActions [from './chat/chatActions.js']
│   ├── ⬇️ streamingManager [from './modules/streamingManager.js']
│   ├── ⬇️ messageRegistry [from './modules/messageRegistry.js']
│   ├── ⬇️ youtubeHandler [from './youtube-system/youtubeHandler.js']
│   ├── ⬇️ youtubeResumoHandler [from './youtube-system/youtubeResumoHandler.js']
│   ├── ⬇️ commandMenu [from './commandMenu.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── 🔧 initializeSystem()
│   │   ├── 🔧 showLoading()
│   │   ├── 🔧 hideLoading()
│   │   ├── 🔧 showError()
│   │   ├── 🔧 showSuccess()
├── 📄 messageRenderer.js
│   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── ⬇️ messageRegistry [from './modules/messageRegistry.js']
│   ├── 🔧 renderErrorMessage()
│   │   ├── 📤 renderMarkdown()
│   │   ├── 📤 renderMessage()
│   │   ├── 📤 accumulateChunk()
│   │   ├── 📤 setCurrentConversation()
│   │   ├── 📤 renderMessageContainer()
├── 📄 sidebar.js
│   ├── 📤 toggleSidebar()
│   ├── 📤 initSidebar()
├── 📄 textarea.js
│   ├── 📤 configureTextarea()
├── 📄 theme.js
│   ├── 🔧 applyTheme()
│   ├── 📤 toggleTheme()
│   ├── 📤 initializeTheme()
├── 📄 utils.js
│   ├── 📤 escapeHTML()
│   ├── 📤 mostrarCarregamento()
├── 📁 youtube-system/
│   ├── 📄 youtubeEvents.js
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── 📤 setupYoutubeEvents()
│   │   ├── 📤 handleYoutubeCommand()
│   ├── 📄 youtubeHandler.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 🔧 processSubtitles()
│   │   ├── 🔧 formatSubtitles()
│   │   ├── 🔧 displaySubtitles()
│   │   ├── 📤 handleYoutubeCommand()
│   │   ├── 📤 setupYoutubeSocketListeners()
│   ├── 📄 youtubeResumoHandler.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 📤 handleYoutubeResumoCommand()

📁 js/
├── 📁 backup/
│   ├── 📄 chatUI.js
│   │   ├── ⬇️ escapeHTML() [from './chat/chatUtils.js']
│   │   ├── ⬇️ renderMarkdown() [from './messageRenderer.js']
│   │   ├── ⬇️ renderMessageContainer() [from './messageRenderer.js']
│   │   ├── ⬇️ setCurrentConversation() [from './messageRenderer.js']
│   │   ├── ⬇️ streamingManager [from './modules/streamingManager.js']
│   │   ├── ⬇️ logger [from './utils/logger.js']
│   │   ├── 📤 iniciarChat()
│   │   ├── 📤 mostrarTelaInicial()
│   │   ├── 📤 adicionarMensagem()
│   │   ├── 📤 atualizarMensagemStreaming()
│   │   ├── 📤 mostrarCarregamento()
│   │   ├── 📤 handleMessageChunk()
│   │   ├── 📤 chatUI [instance]
│   │   ├── [class] ChatUI
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 initializeEventListeners()
│   │   │   ├── 🔧 sendMessage()
│   │   │   ├── 🔧 appendUserMessage()
│   │   │   ├── 🔧 handleConversationChange()
│   │   │   ├── 🔧 loadConversationHistory()
│   │   │   ├── 🔧 displayConversationHistory()
│   │   │   ├── 🔧 showError()
│   │   │   ├── 🔧 scrollToBottom()
│   │   │   ├── 🔧 escapeHtml()
│   ├── 📄 messageRegistry.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── [class] MessageRegistry
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 setupPeriodicCheck()
│   │   │   ├── 🔧 generateMessageId()
│   │   │   ├── 🔧 registerMessage()
│   │   │   ├── 🔧 getMessage()
│   │   │   ├── 🔧 updateMessage()
│   │   │   ├── 🔧 addChunk()
│   │   │   ├── 🔧 completeMessage()
│   │   │   ├── 🔧 removeMessage()
│   │   │   ├── 🔧 hasMessage()
│   │   │   ├── 🔧 getMessagesByConversation()
│   │   │   ├── 🔧 cleanOrphanContainers()
│   │   ├── 📤 messageRegistry [instance]
├── 📁 chat/
│   ├── 📄 chatUI.js
│   │   ├── ⬇️ escapeHTML() [from './chatUtils.js']
│   │   ├── ⬇️ renderMarkdown() [from '../messageRenderer.js']
│   │   ├── ⬇️ renderMessageContainer() [from '../messageRenderer.js']
│   │   ├── ⬇️ setCurrentConversation() [from '../messageRenderer.js']
│   │   ├── ⬇️ melhorarBlocosCodigo() [from './chatUtils.js']
│   │   ├── ⬇️ streamingManager [from '../modules/streamingManager.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── 📤 iniciarChat()
│   │   ├── 📤 mostrarTelaInicial()
│   │   ├── 📤 adicionarMensagem()
│   │   ├── 📤 atualizarMensagemStreaming()
│   │   ├── 📤 mostrarCarregamento()
│   │   ├── 📤 handleMessageChunk()
│   │   ├── 📤 chatUI [instance]
│   │   ├── [class] ChatUI
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 initializeEventListeners()
│   │   │   ├── 🔧 sendMessage()
│   │   │   ├── 🔧 appendUserMessage()
│   │   │   ├── 🔧 handleConversationChange()
│   │   │   ├── 🔧 loadConversationHistory()
│   │   │   ├── 🔧 displayConversationHistory()
│   │   │   ├── 🔧 showError()
│   │   │   ├── 🔧 scrollToBottom()
│   │   │   ├── 🔧 escapeHtml()
│   ├── 📄 chatActions.js
│   │   ├── ⬇️ chatUI [from './chatUI.js']
│   │   ├── ⬇️ adicionarMensagemAoHistorico() [from './chatStorage.js']
│   │   ├── ⬇️ criarNovaConversa() [from './chatStorage.js']
│   │   ├── ⬇️ atualizarListaConversas() [from './chatStorage.js']
│   │   ├── ⬇️ renderMessage() [from '../messageRenderer.js']
│   │   ├── ⬇️ renderMessageChunk() [from '../messageRenderer.js']
│   │   ├── ⬇️ completeMessage() [from '../messageRenderer.js']
│   │   ├── ⬇️ messageRegistry [from '../modules/messageRegistry.js']
│   │   ├── ⬇️ melhorarBlocosCodigo() [from './chatUtils.js']
│   │   ├── ⬇️ handleYoutubeCommand() [from '../youtube-system/youtubeHandler.js']
│   │   ├── ⬇️ handleYoutubeResumoCommand() [from '../youtube-system/youtubeResumoHandler.js']
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 🔧 inicializarConversa()
│   │   ├── 🔧 isUserAtBottom()
│   │   ├── 🔧 scrollToBottom()
│   │   ├── 🔧 handleStreamingScroll()
│   │   ├── 🔧 forcarRenderizacao()
│   │   ├── 🔧 isDuplicateMessage()
│   │   ├── 🔧 gerarMessageId()
│   │   ├── [class] ChatDebugger
│   │   │   ├── 🔧 constructor()
│   │   │   ├── 🔧 log()
│   │   │   ├── 🔧 info()
│   │   │   ├── 🔧 debug()
│   │   │   ├── 🔧 warn()
│   │   │   ├── 🔧 error()
│   │   │   ├── 🔧 exportLogs()
│   │   ├── 📤 entrarNaSala()
│   │   ├── 📤 sairDaSala()
│   │   ├── 📤 atualizarBotoes()
│   │   ├── 📤 enviarMensagem()
│   │   ├── 📤 carregarConversa()
│   │   ├── 📤 interromperResposta()
│   │   ├── 📤 handleStreamChunk()
│   ├── 📄 chatStorage.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ messageRegistry [from '../modules/messageRegistry.js']
│   │   ├── 🔧 saveConversation()
│   │   ├── 🔧 loadConversation()
│   │   ├── 🔧 deleteConversation()
│   │   ├── 🔧 getAllConversations()
│   │   ├── 📤 adicionarMensagemAoHistorico()
│   │   ├── 📤 criarNovaConversa()
│   │   ├── 📤 atualizarListaConversas()
│   ├── 📄 chatSync.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ chatStorage [from './chatStorage.js']
│   │   ├── 🔧 syncConversation()
│   │   ├── 🔧 handleSyncResponse()
│   │   ├── 🔧 setupSyncListeners()
│   │   ├── 📤 syncMessages()
│   ├── 📄 chatUtils.js
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── 🔧 formatMessage()
│   │   ├── 🔧 validateInput()
│   │   ├── 📤 escapeHTML()
│   │   ├── 📤 melhorarBlocosCodigo()
├── 📄 chat.js
│   │   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   │   ├── ⬇️ chatActions [from './chat/chatActions.js']
│   │   ├── ⬇️ logger [from './utils/logger.js']
│   │   ├── 🔧 showLoading()
│   │   ├── 🔧 hideLoading()
│   │   ├── 🔧 showError()
│   │   ├── 🔧 showSuccess()
│   │   ├── 📤 iniciarChat()
│   │   ├── 📤 mostrarTelaInicial()
│   │   ├── 📤 adicionarMensagem()
│   │   ├── 📤 mostrarCarregamento()
│   │   ├── 📤 enviarMensagem()
│   │   ├── 📤 interromperResposta()
├── 📄 commandMenu.js
│   ├── 📤 initCommandMenu()
├── 📄 events.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ theme [from './theme.js']
│   ├── ⬇️ sidebar [from './sidebar.js']
│   ├── ⬇️ textarea [from './textarea.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── 🔧 handleKeyboardShortcuts()
│   │   ├── 🔧 handleWindowResize()
│   │   ├── 🔧 handleSocketEvents()
│   │   ├── 📤 configureEventListeners()
├── 📄 init.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ streamingManager [from './modules/streamingManager.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── ⬇️ theme [from './theme.js']
│   ├── 🔧 initializeApp()
│   │   ├── 📤 default [socket]
├── 📄 main.js
│   ├── ⬇️ chatUI [from './chat/chatUI.js']
│   ├── ⬇️ chatActions [from './chat/chatActions.js']
│   ├── ⬇️ streamingManager [from './modules/streamingManager.js']
│   ├── ⬇️ messageRegistry [from './modules/messageRegistry.js']
│   ├── ⬇️ youtubeHandler [from './youtube-system/youtubeHandler.js']
│   ├── ⬇️ youtubeResumoHandler [from './youtube-system/youtubeResumoHandler.js']
│   ├── ⬇️ commandMenu [from './commandMenu.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── 🔧 initializeSystem()
│   │   ├── 🔧 showLoading()
│   │   ├── 🔧 hideLoading()
│   │   ├── 🔧 showError()
│   │   ├── 🔧 showSuccess()
├── 📄 messageRenderer.js
│   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   ├── ⬇️ logger [from './utils/logger.js']
│   ├── ⬇️ messageRegistry [from './modules/messageRegistry.js']
│   ├── 🔧 renderErrorMessage()
│   │   ├── 📤 renderMarkdown()
│   │   ├── 📤 renderMessage()
│   │   ├── 📤 accumulateChunk()
│   │   ├── 📤 setCurrentConversation()
│   │   ├── 📤 renderMessageContainer()
├── 📄 sidebar.js
│   ├── 📤 toggleSidebar()
│   ├── 📤 initSidebar()
├── 📄 textarea.js
│   ├── 📤 configureTextarea()
├── 📄 theme.js
│   ├── 🔧 applyTheme()
│   ├── 📤 toggleTheme()
│   ├── 📤 initializeTheme()
├── 📁 utils/
│   ├── 📄 logger.js
│   │   ├── 🔧 log()
│   │   ├── 📤 logger [instance]
├── 📄 utils.js
│   ├── 📤 escapeHTML()
│   ├── 📤 mostrarCarregamento()
├── 📁 youtube-system/
│   ├── 📄 youtubeEvents.js
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── 📤 setupYoutubeEvents()
│   │   ├── 📤 handleYoutubeCommand()
│   ├── 📄 youtubeHandler.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 🔧 processSubtitles()
│   │   ├── 🔧 formatSubtitles()
│   │   ├── 🔧 displaySubtitles()
│   │   ├── 📤 handleYoutubeCommand()
│   │   ├── 📤 setupYoutubeSocketListeners()
│   ├── 📄 youtubeResumoHandler.js
│   │   ├── ⬇️ logger [from '../utils/logger.js']
│   │   ├── ⬇️ marked [from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js']
│   │   ├── ⬇️ DOMPurify [from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js']
│   │   ├── 📤 handleYoutubeResumoCommand()
```

## 2.2. ARQUIVOS PYTHON E HTML

```
📁 persistencia-memoria-html/           # Pasta raiz do projeto
├── 📄 app.py                           # Arquivo principal da aplicação Flask
│   ├── 🔧 setup_logger()               # Configura o sistema de logging com rotação de arquivos e formatos detalhados
│   ├── 🔧 log_with_context()           # Função auxiliar para log com contexto adicional (conversa, mensagem, etc.)
│   ├── 📤 home()                       # Rota principal que renderiza a página inicial com o histórico de conversas
│   ├── 📤 conversation_history()       # Endpoint para obter o histórico de todas as conversas
│   ├── 📤 get_conversation()           # Endpoint para obter uma conversa específica pelo ID
│   ├── 📤 get_conversation_batch()     # Endpoint para carregar mensagens em lotes para lazy loading
│   ├── 📤 stream()                     # [DEPRECATED] Endpoint para streaming de respostas usando SSE
│   ├── 📤 send_message()               # Endpoint para enviar mensagens para a IA e receber respostas
│   ├── 🔧 process_streaming_response() # Processa a resposta da IA em modo streaming usando Socket.IO
│   ├── 📤 save_message()               # Endpoint para salvar mensagens na conversa
│   ├── 📤 process_youtube()            # Endpoint para processar vídeos do YouTube
│   ├── 🔧 process_youtube_background() # Função em background para processar vídeos do YouTube
│   ├── 📤 save_youtube_message()       # Endpoint para salvar mensagens relacionadas ao YouTube
│   ├── 📤 process_youtube_resumo()     # Endpoint para processar resumos de vídeos do YouTube
│   ├── 🔧 process_youtube_resumo_background() # Função em background para gerar resumos de vídeos
│   ├── 📤 handle_rename_conversation() # Endpoint para renomear uma conversa
│   ├── 📤 handle_delete_conversation() # Endpoint para excluir uma conversa
│   ├── 📤 log_frontend()               # Endpoint para registrar logs do frontend
│   ├── 📤 test_socket()                # Endpoint para testar a conectividade do Socket.IO
│   ├── 📤 view_logs()                  # Endpoint para visualizar os logs da aplicação
│   ├── 📤 handle_connect()             # Evento Socket.IO para nova conexão
│   ├── 📤 handle_disconnect()          # Evento Socket.IO para desconexão
│   ├── 📤 handle_join_conversation()   # Evento Socket.IO para entrar em uma sala de conversa
│   ├── 📤 handle_leave_conversation()  # Evento Socket.IO para sair de uma sala de conversa
│   ├── 🔧 process_with_ai()            # Processa um texto com a IA de forma síncrona
│   ├── 🔧 process_with_ai_stream()     # Processa um texto com a IA em modo streaming
│   ├── ⬇️ render_template() [from flask] # Função para renderizar templates HTML
│   ├── ⬇️ request() [from flask]       # Objeto para acessar dados da requisição HTTP
│   ├── ⬇️ jsonify() [from flask]       # Função para retornar respostas JSON
│   ├── ⬇️ Response() [from flask]      # Classe para criar respostas HTTP customizadas
│   ├── ⬇️ json [importado]             # Módulo para manipulação de JSON
│   ├── ⬇️ os [importado]               # Módulo para interagir com o sistema operacional
│   ├── ⬇️ logging [importado]          # Módulo para logging
│   ├── ⬇️ logging.handlers [importado] # Handlers para logging, como RotatingFileHandler
│   ├── ⬇️ traceback [importado]        # Módulo para manipular stack traces
│   ├── ⬇️ datetime [importado]         # Módulo para manipulação de datas e horas
│   ├── ⬇️ requests [importado]         # Módulo para fazer requisições HTTP
│   ├── ⬇️ argparse [importado]         # Módulo para parsing de argumentos de linha de comando
│   ├── ⬇️ Flask() [from flask]         # Classe para criar a aplicação Flask
│   ├── ⬇️ SocketIO() [from flask_socketio] # Classe para integrar Socket.IO com Flask
│   ├── ⬇️ emit() [from flask_socketio] # Função para emitir eventos Socket.IO
│   ├── ⬇️ join_room() [from flask_socketio] # Função para entrar em uma sala Socket.IO
│   ├── ⬇️ leave_room() [from flask_socketio] # Função para sair de uma sala Socket.IO
│   ├── ⬇️ uuid4() [from uuid]          # Função para gerar UUIDs únicos
│   ├── ⬇️ create_new_conversation() [from utils.chat_storage] # Função para criar novas conversas
│   ├── ⬇️ add_message_to_conversation() [from utils.chat_storage] # Função para adicionar mensagens a conversas
│   ├── ⬇️ get_conversation_by_id() [from utils.chat_storage] # Função para obter conversa por ID
│   ├── ⬇️ get_conversation_history() [from utils.chat_storage] # Função para obter histórico de conversas
│   ├── ⬇️ delete_conversation() [from utils.chat_storage] # Função para excluir conversas
│   ├── ⬇️ rename_conversation() [from utils.chat_storage] # Função para renomear conversas
│   ├── ⬇️ update_message_in_conversation() [from utils.chat_storage] # Função para atualizar mensagens
│   ├── ⬇️ re [importado]               # Módulo para expressões regulares
├── 📄 cleanup_ports.py                 # Script utilitário para verificar e liberar portas em uso
│   ├── 🔧 check_port()                 # Verifica se uma porta está em uso e retorna o PID do processo
│   ├── 🔧 kill_process()               # Tenta encerrar um processo pelo PID
│   ├── 🔧 main()                       # Função principal que executa a lógica do script
│   ├── ⬇️ os [importado]               # Módulo para interagir com o sistema operacional
│   ├── ⬇️ sys [importado]              # Módulo para acessar variáveis e funções do sistema
│   ├── ⬇️ subprocess [importado]       # Módulo para criar subprocessos
│   ├── ⬇️ time [importado]             # Módulo para manipulação de tempo
├── 📄 init_eventlet.py                 # Inicializa o monkey patching do Eventlet para suportar operações assíncronas
│   ├── ⬇️ eventlet [importado]         # Biblioteca para programação assíncrona
│   ├── ⬇️ eventlet.monkey_patch() [from eventlet] # Aplica monkey patching para tornar bibliotecas padrão assíncronas
├── 📄 linha_de_raciocinio              # [conteúdo não fornecido]
├── 📁 templates/                       # Pasta para templates HTML renderizados pelo Flask
│   ├── 📄 index.html                   # Template principal da página inicial
│   │   └── [conteúdo fornecido, mas sem funções] # HTML com estrutura da página e scripts incorporados
│   └── 📄 youtube.html                 # Template para a página ou seção relacionada ao YouTube
│       └── [conteúdo fornecido, mas sem funções] # HTML com elementos para exibir legendas e mensagens de status
├── 📁 utils/                           # Pasta para utilitários Python
│   └── 📄 chat_storage.py              # Módulo para gerenciar o armazenamento persistente de conversas em formato JSON
│       ├── 🔧 ensure_directories()     # Garante que os diretórios necessários para armazenamento existam
│       ├── 🔧 create_new_conversation()# Cria uma nova conversa com ID único
│       ├── 🔧 save_conversation()      # Salva uma conversa em seu arquivo JSON correspondente
│       ├── 🔧 update_index()           # Atualiza o arquivo de índice com metadados da conversa
│       ├── 🔧 get_conversation_by_id() # Recupera uma conversa específica pelo ID
│       ├── 🔧 get_conversation_history()# Recupera o histórico de todas as conversas
│       ├── 🔧 add_message_to_conversation()# Adiciona uma mensagem a uma conversa existente
│       ├── 🔧 update_message_in_conversation()# Atualiza o conteúdo de uma mensagem existente
│       ├── 🔧 delete_conversation()    # Exclui uma conversa e sua entrada no índice
│       ├── 🔧 rename_conversation()    # Renomeia uma conversa existente
│       ├── ⬇️ json [importado]         # Módulo para manipulação de JSON
│       ├── ⬇️ os [importado]           # Módulo para interagir com o sistema operacional
│       ├── ⬇️ uuid [importado]         # Módulo para gerar UUIDs
│       ├── ⬇️ datetime [importado]     # Módulo para manipulação de datas e horas
└── 📄 youtube_handler.py               # Contém a classe YoutubeHandler para manipular vídeos do YouTube
    └── [class] YoutubeHandler          # Classe para baixar e processar legendas de vídeos do YouTube
        ├── 🔧 __init__()               # Inicializa o manipulador com caminho para arquivos temporários
        ├── 🔧 download_subtitles()     # Baixa legendas do vídeo em PT-BR, PT ou EN
        ├── 🔧 clean_subtitles()        # Limpa as legendas removendo timestamps e formatação
        ├── 🔧 download_and_clean_transcript()# Combina download e limpeza de legendas
        ├── 🔧 split_transcript_into_chunks()# Divide a transcrição em blocos de texto
        ├── ⬇️ os [importado]           # Módulo para interagir com o sistema operacional
        ├── ⬇️ json [importado]         # Módulo para manipulação de JSON
        ├── ⬇️ yt_dlp [importado]       # Biblioteca para download de vídeos e legendas do YouTube
        ├── ⬇️ re [importado]           # Módulo para expressões regulares
        ├── ⬇️ logging [importado]      # Módulo para logging
        ├── ⬇️ traceback [importado]    # Módulo para manipular stack traces
        ├── ⬇️ Optional [from typing]   # Tipo para indicar valores opcionais
        ├── ⬇️ Dict [from typing]       # Tipo para dicionários
        ├── ⬇️ Any [from typing]        # Tipo para qualquer valor
        ├── ⬇️ Tuple [from typing]      # Tipo para tuplas
        ```

### 3 Árvore Completa do Sistema com Legendas

```
📁 js/
├── 📄 chat.js           # Ponto de entrada do chat: inicializa interface e gerencia fluxo de mensagens do usuário e do sistema
├── 📄 commandMenu.js    # Gerencia o menu de comandos disponíveis, inicializando atalhos e ações de menu
├── 📄 events.js         # Configura e trata eventos globais (teclado, resize, eventos de socket)
├── 📄 init.js           # Inicializa o aplicativo: configura chat, tema, sincronização e logger
├── 📄 main.js           # Coordena a integração de módulos principais: UI, YouTube, storage e comandos
├── 📄 messageRenderer.js# Renderiza mensagens em Markdown e gerencia acumulamento de chunks de streaming
├── 📄 sidebar.js        # Controla a abertura/fechamento da barra lateral e suas interações
├── 📄 textarea.js       # Configura o campo de entrada de texto, incluindo auto-expansão e atalhos
├── 📄 theme.js          # Aplica e alterna temas (claro/escuro), inicializando preferências do usuário
├── 📄 utils.js          # Funções utilitárias gerais: escape de HTML e exibição de carregamento
│
├── 📁 backup/           # Cópias de segurança de versões anteriores, sem comentários
│   ├── 📄 chatUI.js
│   └── 📄 messageRegistry.js
│
├── 📁 chat/             # Módulo de chat: lógica de ações, armazenamento, sincronização e utilitários
│   ├── 📄 chatActions.js  # Lida com ações do usuário no chat: enviar/parar mensagens e atualizar UI
│   ├── 📄 chatStorage.js  # Gerencia persistência local de conversas e histórico de mensagens
│   ├── 📄 chatSync.js     # Sincroniza mensagens em tempo real via WebSocket/sockets
│   ├── 📄 chatUI.js       # Implementa classe ChatUI para renderização dinâmica e streaming de mensagens
│   └── 📄 chatUtils.js    # Funções auxiliares de formatação e validação de entradas de chat
│
├── 📁 modules/          # Módulos de infraestrutura: registro de mensagens, streaming e comandos
│   ├── 📄 commandHandler.js   # Registra e executa comandos personalizados no chat
│   ├── 📄 inputBar.js         # Inicializa e destrói componente de entrada, tratando submissões
│   ├── 📄 messageRegistry.js  # Registra, rastreia e completa mensagens de streaming
│   └── 📄 streamingManager.js # Gerencia container de mensagens, perfis de tempo e duplicações
│
├── 📁 utils/            # Utilitários de logging
│   └── 📄 logger.js       # Fornece instância de logger para registro de info, warn e error
│
└── 📁 youtube-system/   # Integração YouTube: eventos, handlers de comando e resumo
    ├── 📄 youtubeEvents.js        # Configura eventos personalizados do YouTube no cliente
    ├── 📄 youtubeHandler.js       # Processa comandos /youtube: busca e exibe legendas
    └── 📄 youtubeResumoHandler.js # Processa comandos /youtube_resumo: gera sumário de vídeo
```


Ao analisar a árvore de arquivos do projeto e o sistema como um todo, posso compartilhar algumas observações sobre a estrutura, possíveis duplicações e oportunidades de melhoria. Vou abordar cada ponto de forma clara e em português brasileiro, como solicitado.

### O que vejo na árvore de arquivos?

A árvore de arquivos apresenta uma organização modular de um sistema de chat, com funcionalidades bem definidas e separadas em diretórios como `chat/`, `modules/`, `utils/`, e `youtube-system/`. A estrutura reflete um aplicativo web que suporta mensagens em tempo real, streaming de conteúdo, comandos personalizados (como integração com YouTube) e gerenciamento de interface (temas, barra lateral, área de texto). Aqui estão alguns destaques:

1. **Organização Modular**:
   - O diretório `chat/` contém a lógica central do chat, com arquivos como `chatUI.js` (interface do usuário), `chatActions.js` (ações do chat, como enviar mensagens) e `chatStorage.js` (gerenciamento de histórico).
   - `modules/` agrupa componentes reutilizáveis, como `messageRegistry.js` (gerenciamento de mensagens) e `streamingManager.js` (controle de streaming).
   - `youtube-system/` isola a lógica de integração com YouTube, como processamento de legendas e resumos.
   - `utils/` e arquivos como `logger.js` e `utils.js` fornecem funções de suporte genérico, como log e sanitização de HTML.

2. **Duplicações Intencionais**:
   - A pasta `js/backup/` contém versões antigas de `chatUI.js` e `messageRegistry.js`, que são idênticas às versões em `js/chat/` e `js/modules/`. Isso sugere que `backup/` serve como um repositório de versões anteriores, possivelmente para controle manual de alterações antes de um sistema de versionamento (como Git).
   - A duplicação de `chatUI.js` em `js/backup/` e `js/chat/` é explícita e parece intencional, mantendo a mesma estrutura de classes, funções e importações.

3. **Integrações Externas**:
   - O uso de bibliotecas como `marked` (para renderização de Markdown) e `DOMPurify` (para sanitização de HTML) em vários arquivos (`chatActions.js`, `messageRenderer.js`, `youtube-system/`) indica uma preocupação com segurança e formatação de conteúdo dinâmico.
   - A integração com YouTube (via `youtube-system/`) é robusta, com funções específicas para legendas e resumos, sugerindo que o sistema suporta comandos avançados, como `/youtube`.

### Análise do sistema como um todo

O sistema é um aplicativo de chat web com suporte a streaming, comandos personalizados e persistência de dados. Ele utiliza JavaScript puro (sem frameworks como React) e parece depender de WebSocket para comunicação em tempo real (evidenciado pelo `socket` exportado em `init.js`). Abaixo, algumas observações gerais:

1. **Pontos Fortes**:
   - **Modularidade**: A separação em módulos facilita a manutenção e a adição de novas funcionalidades. Por exemplo, `messageRegistry.js` centraliza o gerenciamento de mensagens, enquanto `streamingManager.js` lida com streaming de forma isolada.
   - **Reutilização**: Funções como `renderMarkdown()` e `escapeHTML()` são importadas e usadas em vários arquivos, reduzindo duplicação de lógica.
   - **Robustez**: A inclusão de `logger.js` em quase todos os módulos sugere um sistema bem monitorado, com rastreamento de erros e eventos.

2. **Possíveis Fragilidades**:
   - **Falta de Tipagem**: Como o projeto é em JavaScript puro, não há tipagem estática (como TypeScript), o que pode levar a erros em tempo de execução, especialmente em funções como `renderMessage()` ou `handleStreamChunk()`.
   - **Dependência de Bibliotecas Externas**: O uso de `marked` e `DOMPurify` via CDN pode introduzir riscos de segurança ou instabilidade se as versões mudarem.
   - **Complexidade em `chatActions.js`**: Este arquivo contém muitas funções e uma classe (`ChatDebugger`), o que pode dificultar a manutenção. Dividi-lo em submódulos (por exemplo, um arquivo separado para `ChatDebugger`) pode melhorar a clareza.

### Duplicações Identificadas

1. **Arquivos Duplicados**:
   - **`chatUI.js`**: Aparece em `js/backup/` e `js/chat/` com conteúdo idêntico (mesma classe `ChatUI`, funções como `iniciarChat()`, importações de `renderMarkdown()`, etc.). Essa duplicação é intencional, mas pode ser eliminada se `backup/` for substituído por um sistema de controle de versão.
   - **`messageRegistry.js`**: Presente em `js/backup/` e `js/modules/` com a mesma estrutura (classe `MessageRegistry`, funções como `generateMessageId()`, exportação de `messageRegistry`). Novamente, a duplicação parece ser para backup manual.

2. **Funções Potencialmente Duplicadas**:
   - **`escapeHTML()`**:
     - Aparece em `utils.js` (exportada globalmente) e como método `escapeHtml()` na classe `ChatUI` (`chatUI.js`).
     - A versão em `chatUI.js` é redundante, já que `chatUI.js` importa `escapeHTML()` de `chatUtils.js`. O método `escapeHtml()` da classe `ChatUI` pode ser removido, usando apenas a função importada.
   - **`mostrarCarregamento()`**:
     - Exportada em `utils.js` e presente em `chatUI.js` como função exportada.
     - Há também `showLoading()` em `chat.js` e `main.js`, que parecem ter propósitos semelhantes (exibir um indicador de carregamento). Essas funções podem estar duplicando lógica e poderiam ser consolidadas em uma única função em `utils.js`.
   - **`scrollToBottom()`**:
     - Aparece como método da classe `ChatUI` em `chatUI.js` e como função em `chatActions.js`.
     - Ambas as implementações provavelmente manipulam o scroll da janela de chat. Consolidar essa lógica em um único lugar (por exemplo, mantendo apenas o método da classe `ChatUI`) reduziria redundância.

3. **Lógica Semelhante**:
   - **`renderMarkdown()` e `melhorarBlocosCodigo()`**: 
     - `renderMarkdown()` (em `messageRenderer.js`) processa Markdown, enquanto `melhorarBlocosCodigo()` (em `chatUtils.js`) ajusta blocos de código. Essas funções podem estar sobrepondo funcionalidades, especialmente se `melhorarBlocosCodigo()` for apenas um pós-processamento de Markdown. Integrar essa lógica em `renderMarkdown()` pode simplificar o fluxo.
   - **`handleYoutubeCommand()`**:
     - Presente em `youtubeEvents.js` e `youtubeHandler.js`. Embora os contextos sejam diferentes (eventos vs. manipulação de legendas), os nomes sugerem possível sobreposição. Renomear ou documentar claramente as diferenças ajudaria a evitar confusão.

### Oportunidades de Melhoria

1. **Eliminar Duplicações de Arquivos**:
   - Substituir a pasta `js/backup/` por um sistema de controle de versão (como Git) eliminaria a necessidade de manter cópias manuais de `chatUI.js` e `messageRegistry.js`. Isso reduziria o tamanho do projeto e o risco de inconsistências.

2. **Consolidar Funções Duplicadas**:
   - **Unificar `escapeHTML()` e `escapeHtml()`**: Remover o método `escapeHtml()` da classe `ChatUI` e usar apenas a função importada de `chatUtils.js`.
   - **Centralizar funções de carregamento**: Consolidar `mostrarCarregamento()` (utils.js), `showLoading()` (chat.js, main.js) e similares em uma única função em `utils.js`, com parâmetros para personalização.
   - **Padronizar `scrollToBottom()`**: Manter apenas o método da classe `ChatUI` e importar essa funcionalidade em `chatActions.js`.

3. **Melhorar Modularidade**:
   - Dividir `chatActions.js` em submódulos menores, como:
     - `chatActions.js`: Lógica de ações principais (enviar mensagens, carregar conversa).
     - `chatDebugger.js`: Classe `ChatDebugger` e funções relacionadas a depuração.
     - `chatStreaming.js`: Funções relacionadas a streaming (`handleStreamChunk()`, `handleStreamingScroll()`).
   - Mover funções genéricas de `chatUtils.js` (como `formatMessage()`) para `utils.js` se forem usadas fora do contexto do chat.

4. **Adicionar Documentação**:
   - Cada arquivo deve ter um comentário inicial descrevendo seu propósito. Por exemplo:
     ```javascript
     // chatUI.js
     // Gerencia a interface do usuário do chat, incluindo exibição de mensagens e eventos de interação.
     ```
   - Funções críticas, como `renderMarkdown()` ou `generateMessageId()`, devem ter JSDoc para documentar parâmetros, retornos e comportamento:
     ```javascript
     /**
      * Renderiza texto Markdown em HTML seguro.
      * @param {string} markdown - Texto Markdown a ser renderizado.
      * @returns {string} HTML sanitizado.
      */
     function renderMarkdown(markdown) { ... }
     ```
   - Classes como `ChatUI` e `MessageRegistry` devem ter comentários explicando seus métodos e responsabilidades.

5. **Otimizar Performance**:
   - Revisar `streamingManager.js` para garantir que funções como `findMissingChunks()` e `calculateSimilarity()` sejam eficientes, especialmente em chats com muitas mensagens.
   - Implementar debouncing em eventos como `handleStreamingScroll()` para evitar chamadas excessivas durante rolagem rápida.

6. **Segurança**:
   - Garantir que todas as chamadas a `DOMPurify` sejam consistentes e cubram todos os casos de entrada de usuário (especialmente em `renderMessage()` e `handleYoutubeCommand()`).
   - Avaliar a necessidade de carregar `marked` e `DOMPurify` via CDN. Usar versões locais ou um gerenciador de pacotes (como npm) pode melhorar a confiabilidade.

### Resumo

- **Visão Geral**: A árvore mostra um sistema de chat bem estruturado, com módulos claros para interface, streaming, armazenamento e integração com YouTube. A pasta `js/backup/` indica uma abordagem manual de backup que pode ser modernizada.
- **Duplicações**:
  - Arquivos: `chatUI.js` e `messageRegistry.js` duplicados em `backup/`.
  - Funções: `escapeHTML()`/`escapeHtml()`, `mostrarCarregamento()`/`showLoading()`, `scrollToBottom()` aparecem em múltiplos lugares.
  - Lógica: `renderMarkdown()` e `melhorarBlocosCodigo()` podem ser consolidadas; `handleYoutubeCommand()` precisa de nomes mais distintos.
- **Melhorias**:
  - Eliminar `backup/` com controle de versão.
  - Centralizar funções duplicadas em `utils.js` ou classes relevantes.
  - Dividir `chatActions.js` em submódulos.
  - Adicionar documentação JSDoc e comentários de alto nível.
  - Otimizar performance de streaming e reforçar segurança.

Se quiser, posso começar a criar a documentação para arquivos específicos (como `chatUI.js` ou `messageRenderer.js`) ou sugerir implementações para consolidar as funções duplicadas. Qual é o próximo passo que você prefere?

==========================================
Conteúdo de documentacao-sistema.md (caminho: linha_de_raciocinio\documentacao-sistema.md):
==========================================
# Documentação do Sistema de Chat com Streaming

## Visão Geral do Sistema

O sistema implementa um chat interativo com suporte a streaming de mensagens, permitindo visualização em tempo real da resposta da IA. O sistema conta com um mecanismo de feedback visual durante o carregamento e tratamento robusto de mensagens para evitar duplicações.

## Arquitetura Geral

### Componentes Principais

1. **Frontend**:
   - **chat.js**: Gestão de interface e interação de usuário
   - **messageRegistry.js**: Sistema central de rastreamento de mensagens
   - **streamingManager.js**: Gerencia streaming de mensagens
   - **messageRenderer.js**: Renderiza as mensagens no chat
   - **youtubeHandler.js**: Integração com recursos do YouTube

2. **Backend**:
   - **app.py**: Processamento de mensagens e integração com IA
   - **chat_storage.py**: Persistência das conversas

3. **Integrações**:
   - Socket.IO para comunicação bidirecional em tempo real
   - API de IA para geração de respostas (Ollama)
   - Processamento de vídeos do YouTube

## Fluxo de Dados

1. Usuário envia mensagem através da interface
2. Frontend registra a mensagem no messageRegistry com UUID único
3. streamingManager envia para o backend via Socket.IO
4. Backend processa com IA e retorna chunks de resposta via Socket.IO
5. streamingManager recebe os chunks e atualiza o messageRegistry
6. messageRenderer exibe a resposta em tempo real no chat
7. Após completar, a mensagem é armazenada no histórico

## Sistema de Feedback Visual

### Problema Original Resolvido

O sistema antigo de feedback visual durante o carregamento ("três pontinhos") apresentava problemas:
1. O cursor antigo ("Gerando resposta...") persistia no DOM
2. Containers vazios eram criados, poluindo a interface
3. Erro no código: `TypeError: messageRegistry.forEach is not a function`

### Solução Implementada

1. **Eliminação do Cursor Antigo**:
   - Substituição por animação de carregamento centralizada
   - Remoção de todos os pontos de criação do cursor antigo em:
     - `chatActions.js` (função `carregarConversa`)
     - `chatSync.js` (evento `message_chunk`)
     - `streamingManager.js` (método `createMessageContainer`)

2. **Integração da Animação Centralizada**:
   - Elemento HTML único para feedback visual
   - Controle centralizado em pontos-chave:
     - Ao enviar mensagem
     - Ao receber o primeiro chunk
     - Ao completar a resposta
     - Em caso de erro
     - Ao interromper a resposta

3. **Correção de Bugs**:
   - Corrigido método `cleanupOrphan` para usar iteração correta sobre Maps
   - Removidas referências à classe `.streaming-message` em seletores

### Código de Implementação

**HTML da Animação (index.html)**:
```html
<!-- Animação de carregamento centralizada -->
<div id="loading-animation" style="display: none;">
    <div class="loading-spinner">
        <i class="fas fa-spinner fa-spin"></i>
        <span>Processando...</span>
    </div>
</div>
```

**Estilos CSS (streaming.css)**:
```css
#loading-animation {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    background: rgba(0, 0, 0, 0.7);
    padding: 15px 25px;
    border-radius: 8px;
    color: #fff;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.loading-spinner {
    display: flex;
    align-items: center;
    gap: 10px;
}

.loading-spinner i {
    font-size: 1.5rem;
}

.loading-spinner span {
    font-family: 'Inter', sans-serif;
    font-size: 1rem;
}
```

**Manipulação em JavaScript**:
```javascript
// Mostrar animação
const loadingAnimation = document.getElementById('loading-animation');
if (loadingAnimation) {
    loadingAnimation.style.display = 'block';
    logger.debug('Animação de carregamento exibida');
}

// Ocultar animação
if (loadingAnimation && loadingAnimation.style.display === 'block') {
    loadingAnimation.style.display = 'none';
    logger.debug('Animação de carregamento ocultada');
}
```

## Sistema de Streaming de Mensagens

### Implementação do Streaming

O sistema de streaming permite visualização em tempo real das respostas, com as seguintes características:

1. **Containers Unificados**:
   - Um único container por mensagem
   - Identificação via UUID para evitar duplicação
   - Atualização via chunks em tempo real

2. **Renderização Incremental**:
   - Markdown processado em tempo real
   - Exibição de cursor durante digitação
   - Transição suave entre estados

3. **Gerenciamento de Estado**:
   - Controle centralizado via messageRegistry
   - Limpeza automática de containers órfãos
   - Mecanismo de recuperação pós-erro

### Streaming Manager

O StreamingManager é o componente central que:
1. Gerencia os listeners de Socket.IO
2. Processa chunks de mensagem
3. Atualiza o messageRegistry
4. Coordena renderização via messageRenderer
5. Gerencia o ciclo de vida das mensagens

## Resolução de Problemas Comuns

### Duplicação de Mensagens

**Solução**:
- Uso de UUIDs consistentes durante todo o ciclo da mensagem
- Verificação no messageRegistry antes de criar novos containers
- Limpeza automática de containers órfãos

### Containers Vazios

**Solução**:
- Criação de containers apenas quando há conteúdo real
- Sistema de cleanup periódico via `cleanupOrphan()`
- Melhor gerenciamento de ciclo de vida dos containers

### Conflitos de Renderização

**Solução**:
- Centralização da lógica de renderização
- Sistema de fila para processamento de chunks
- Uso de debounce para evitar atualizações excessivas

## Considerações para o Futuro

1. O código antigo dos "três pontinhos" foi preservado em formato de comentário para referência
2. A estrutura atual suporta extensão para animações mais elaboradas
3. O sistema está documentado com logs para facilitar a manutenção

## Diagrama do Sistema

```mermaid
graph TD
    A[Usuário] -->|Envia mensagem| B[Front-end: chat.js]
    B -->|Registra com UUID| C[messageRegistry.js]
    C -->|Gerencia streaming| D[streamingManager.js]
    D -->|Envia via Socket.IO| E[Back-end: app.py]
    E -->|Processa com IA| F[API Ollama]
    F -->|Resposta em streaming| E
    E -->|Envia chunks via Socket.IO| D
    D -->|Atualiza mensagens| C
    C -->|Renderiza chunks| G[messageRenderer.js]
    G -->|Atualiza DOM| H[chatContainer]
    I[Animação de Carregamento] -.->|Feedback visual| H
``` 

==========================================
Conteúdo de documentacao_atualizada.md (caminho: linha_de_raciocinio\documentacao_atualizada.md):
==========================================
Conteúdo de 1- documentação.md:
Segue a primeira parte da documentação, organizada de acordo com o esquema proposto. Essa seção abrange a **Introdução e Objetivos** e está escrita de forma a oferecer uma visão clara do sistema, seu estado atual e as metas pretendidas para os refinamentos e futuras melhorias.

---

# 1. Introdução e Objetivos

## 1.1. Visão Geral do Sistema
O sistema em desenvolvimento é uma aplicação de conversação que integra diferentes funcionalidades, incluindo:
- **Transcrição de Vídeos do YouTube:** Captação e processamento de legendas dos vídeos.
- **Resumo de Vídeos do YouTube:** Processamento dos dados transcritos para gerar resumos concisos dos conteúdos.
- **Interação com uma Inteligência Artificial (IA):** Permite que os usuários façam consultas e recebam respostas processadas em tempo real via streaming, com formatação em Markdown e sanitização de conteúdos.

Atualmente, as funcionalidades de transcrição, resumo e interação via IA estão implementadas e estão em operação. O sistema também utiliza comunicação em tempo real através do Socket.IO, permitindo que os dados sejam transmitidos dinamicamente para o frontend enquanto o processamento ocorre no backend.

## 1.2. Contexto e Estado Atual
- **Funcionalidades Consolidadas:**  
  - A transcrição dos vídeos do YouTube está operando conforme o esperado.
  - O resumo dos vídeos (YouTube Resumo) já foi implementado e é funcional.
  - A conversa com a IA (processamento dos textos e streaming de respostas) está estabelecida, com a renderização incremental no frontend utilizando técnicas como Markdown e DOMPurify para a sanitização.
- **Pontos de Atenção:**  
  - A linha de raciocínio e a documentação atual estão desatualizadas e contêm trechos de rascunhos antigos, informações redundantes e detalhes que não refletem mais o estado operacional do sistema.
  - Alguns aspectos anteriores relacionados ao acúmulo e duplicação de chunks de resposta, ou processos de re-renderização de conteúdo final, já foram refinados na última versão (documentação número 3).
  - Existe a necessidade de alinhar a documentação com o que já foi implementado, destacando a arquitetura de isolamento por `conversation_id` que garante que as mensagens e respostas sejam exibidas somente no chat correspondente.


## 1.3. Objetivos da Documentação
Esta documentação tem como finalidade:
- **Clarificar o Funcionamento do Sistema:**  
  - Descrever detalhadamente os componentes internos (backend, frontend, utilitários) e como eles interagem para oferecer as funcionalidades de transcrição, resumo e comunicação com a IA.
- **Documentar o Estado Atual e as Funcionalidades Implementadas:**  
  - Registrar quais módulos já estão consolidados (por exemplo, a função do YouTube Resumo) e como eles operam dentro do fluxo do sistema.
- **Identificar Pontos para Refinamento:**  
  - Especificar quais aspectos ainda necessitam de ajustes, como melhorias no layout (animação de carregamento, botão de Stop), tratamento de erros e aprimoramentos na experiência de usuário, sem impactar o que já funciona.
- **Fornecer uma Base para Novos Desenvolvedores ou Inteligências de Suporte:**  
  - Facilitar a compreensão rápida do sistema para que seja possível dar continuidade ao desenvolvimento ou manutenção com clareza sobre quais partes são essenciais, quais já foram implementadas e quais podem ser descartadas ou simplificadas na documentação final.

## 1.4. Escopo e Abordagem
- **Escopo:**  
  - A documentação abrangerá tanto os aspectos técnicos (arquivos e seu conteúdo, fluxos de dados, integrações) quanto os pontos de melhoria e refinamento necessários para evoluir o sistema de forma coesa.
- **Abordagem:**  
  - Inicialmente, serão identificados e descritos os principais arquivos e módulos que compõem a linha de raciocínio (tanto do backend quanto do frontend).
  - Em seguida, será feita uma análise de quais pontos e funcionalidades já estão consolidados, quais informações estão desatualizadas e como eliminar redundâncias para uma versão final mais fluida.
  - Serão listados também os refinamentos pendentes, que devem ser considerados para futuras iterações sem comprometer a estabilidade do fluxo principal (especialmente o isolamento via `conversation_id` e o processamento assíncrono via Socket.IO).

---

# 2. Identificação dos Arquivos do Projeto

## 2.1. Arquivos do Backend

### **app.py**  
- **Função Principal:**  
  - É o núcleo do servidor Flask, responsável por definir as rotas e endpoints do sistema.  
- **Principais Responsabilidades:**  
  - **Rotas e Endpoints:** Gerencia a página inicial, criação, recuperação, atualização e exclusão de conversas.  
  - **Integração com Socket.IO:** Configura a comunicação em tempo real, associando os clientes a salas (com base no `conversation_id`) e emitindo eventos como `message_chunk` e `response_complete`.  
  - **Processamento de Mensagens:** Trata os comandos enviados pelo usuário, diferenciando entre as requisições para a inteligência artificial e os comandos específicos para o YouTube (por exemplo, `/youtube` e `/youtube_resumo`).  
  - **Streaming de Respostas:** Implementa o envio de respostas em tempo real (chunks) para o frontend, permitindo a renderização incremental enquanto o processamento ocorre no backend.

### **init_eventlet.py**  
- **Função Principal:**  
  - Inicializa o ambiente assíncrono utilizando o Eventlet.  
- **Principais Responsabilidades:**  
  - **Monkey Patching do Eventlet:** Assegura que todas as operações ocorram de maneira compatível com o processamento assíncrono, preparando o ambiente para a execução do servidor Flask com suporte a eventos.

### **youtube_handler.py**  
- **Função Principal:**  
  - Contém toda a lógica relativa ao processamento de vídeos do YouTube.  
- **Principais Responsabilidades:**  
  - **Download de Legendas:** Utiliza ferramentas (como o yt-dlp) para baixar as legendas dos vídeos do YouTube.  
  - **Limpeza e Formatação:** Processa as legendas removendo formatações indesejadas e caracteres especiais, preparando o texto para exibição e para a geração de resumos.  
  - **Divisão em Chunks:** Pode incluir a lógica para dividir a transcrição em partes menores, facilitando o processamento e o resumo de cada bloco.

### **text_processor.py**  
- **Função Principal:**  
  - Fornece funções auxiliares para manipulação e formatação de texto.  
- **Principais Responsabilidades:**  
  - **Divisão de Texto:** Separa textos longos em blocos ou chunks de tamanho adequado para processamento.  
  - **Limpeza e Formatação:** Aplica regras para padronizar o conteúdo textual, removendo quebras de linha desnecessárias e ajustando espaçamentos, para garantir consistência na renderização.

### **chat_storage.py**  
- **Função Principal:**  
  - Gerencia o armazenamento e o histórico das conversas.  
- **Principais Responsabilidades:**  
  - **Criação de Conversas:** Implementa a criação de novas conversas, assegurando que cada conversa receba um identificador único (`conversation_id`).  
  - **Armazenamento de Mensagens:** Salva, atualiza e exclui mensagens associadas a cada conversa, geralmente utilizando arquivos JSON para persistência.  
  - **Gerenciamento do Histórico:** Permite a recuperação e o gerenciamento do histórico de conversas, facilitando o acesso aos dados anteriores.

---

## 2.2. Arquivos do Frontend

### **chatUI.js**  
- **Função Principal:**  
  - Gerencia a interface do chat e a interação do usuário.  
- **Principais Responsabilidades:**  
  - **Captura de Entrada:** Lida com o input do usuário para envio de mensagens e comandos.  
  - **Interação com o Backend:** Dispara eventos e chamadas aos endpoints para enviar comandos e receber respostas via Socket.IO.  
  - **Gerenciamento de Sala:** Executa funções para juntar ou sair de salas com base no `conversation_id`, garantindo que as mensagens sejam exibidas no chat correto.

### **messageRenderer.js**  
- **Função Principal:**  
  - Responsável pela renderização das mensagens no DOM.  
- **Principais Responsabilidades:**  
  - **Conversão de Markdown:** Utiliza a biblioteca `marked` para converter o conteúdo das mensagens em Markdown para HTML.  
  - **Sanitização:** Aplica o DOMPurify para sanitizar o HTML gerado, garantindo segurança e evitando a injeção de scripts maliciosos.  
  - **Renderização Incremental:** Trata a atualização em tempo real das respostas (chunks) sem duplicação, utilizando técnicas que evitam a re-renderização do conteúdo final.

### **commandHandler.js**  
- **Função Principal:**  
  - Processa comandos especiais digitados pelo usuário (ex.: `/youtube`, `/youtube_resumo` e outros).  
- **Principais Responsabilidades:**  
  - **Filtragem de Comandos:** Identifica os comandos inseridos pelo usuário e direciona para os handlers específicos.  
  - **Interação com o Backend:** Encaminha as requisições para as rotas correspondentes, garantindo que os comandos sejam processados corretamente e que o fluxo de dados siga o isolamento por `conversation_id`.

### **utils.js**  
- **Função Principal:**  
  - Disponibiliza funções auxiliares que podem ser utilizadas em diversos pontos do Frontend.  
- **Principais Responsabilidades:**  
  - **Escape HTML:** Prover segurança para conteúdos que não passem pelo processo de conversão de Markdown.  
  - **Animações de Carregamento:** Controla a exibição de loaders e placeholders enquanto as respostas estão sendo processadas.  
  - **Outras Utilidades:** Funções diversas que facilitam a manipulação do DOM e o tratamento de erros ou estados especiais na interface.

---

# 3. Análise de Conteúdo Atual

## 3.1. Funcionalidades Consolidadas e Operacionais

### Transcrição e Resumo do YouTube
- **Transcrição:**  
  - A função de transcrição dos vídeos do YouTube já está implementada. O sistema capta as legendas dos vídeos através do módulo do `youtube_handler.py`, realiza o download utilizando ferramentas como yt-dlp, e efetua a limpeza e formatação das legendas.
- **Resumo do YouTube:**  
  - O resumo dos vídeos está funcional. Utiliza a transcrição obtida, divide o conteúdo em blocos (chunks) se necessário e processa cada bloco para gerar um parágrafo resumido. Essa funcionalidade já foi integrada ao backend e está operando de maneira isolada por `conversation_id`, garantindo que os resultados apareçam no chat correto.

### Comunicação com a Inteligência Artificial
- **Processamento de Mensagens e Streaming:**  
  - A interação com a IA, que envolve o envio de mensagens, processamento com streaming e renderização incremental dos chunks de resposta, está consolidada.  
  - O backend (no `app.py`) gerencia o fluxo de mensagens via Socket.IO, isolando as conversas por meio do `conversation_id`, o que permite que a resposta seja renderizada em tempo real sem interferir em outras conversas.

### Gerenciamento de Armazenamento e Histórico
- **Persistência das Conversas:**  
  - O módulo `chat_storage.py` já garante a criação, atualização e armazenamento dos históricos de conversas em arquivos (geralmente JSON), permitindo a recuperação e manutenção dos dados associados a cada conversa.

## 3.2. Elementos que Estão Atualizados

### 3.2.1. Acumulação e Re-renderização Redundante dos Chunks  
**Funcionamento Atual:**  
- O sistema **não acumula chunks no backend**.  
- Cada chunk é enviado individualmente via Socket.IO e renderizado incrementalmente no frontend.  
- O evento `response_complete` finaliza o streaming sem reprocessar o conteúdo, garantindo eficiência.  

---

### 3.2.2. Processamento Manual de Eventos e Logs  
**Padrão Adotado:**  
- Logs são integrados de forma padronizada:  
  ```javascript
  logger.debug('Evento recebido', { conversationId, detalhes }); 
  ```  
- Verificações críticas (ex: `chatId`) são mantidas para evitar vazamentos de contexto.  
- Detalhes internos refinados (ex: `isNearBottom`) são omitidos da documentação, mantendo-se apenas a descrição do comportamento final.  

---

### 3.2.3. Fluxos da IA e do YouTube  
**Arquitetura Unificada:**  
- **Padrão Comum:**  
  - Socket.IO para streaming em tempo real.  
  - Isolamento por `conversation_id`.  
  - Renderização incremental com Markdown/DOMPurify.  
- **Diferenças Específicas:**  
  - **YouTube:**  
    - Download e processamento de legendas via `youtube_handler.py`.  
    - Divisão em blocos de ~300 palavras para resumo.  
  - **IA:**  
    - Integração direta com API de IA para respostas dinâmicas.  



## 3.3. Pontos para Refinamento (Melhorias Pendentes)

- **Ajustes na Interface do Frontend:**  
  - Refinar animações de carregamento e a exibição de placeholders para melhorar a experiência do usuário, garantindo que o conteúdo seja atualizado apenas no chat ativo.
  - Revisar a implementação do botão de Stop, assegurando que ele interrompa efetivamente o streaming, sem deixar processos em segundo plano.

- **Padronização da Renderização e Sanitização:**  
  - Unificar o processo de renderização no frontend, utilizando sempre a conversão com Markdown (via `marked`) seguida pela sanitização com o DOMPurify.
  - Garantir que a função `escapeHTML` seja utilizada somente em casos onde o Markdown não se aplique.

- **Documentação dos Logs e Monitoramento:**  
  - Simplificar a descrição da geração e tratamento dos logs, ressaltando os pontos onde são essenciais para o debug e monitoramento sem entrar em detalhes de implementações que já foram refinadas.

- **Aprimoramento do Isolamento por Conversation_id:**  
  - Validar se todas as requisições e eventos (fetch, SSE, Socket.IO) estão transportando corretamente o `conversation_id` e se a verificação de contexto no frontend (exemplo: `if (response.chatId !== currentChatId) return;`) está garantida.

---

# 4. Refinamentos e Melhorias Necessárias

## 4.1. Ajustes na Interface do Frontend

- **Animação de Carregamento e Placeholders:**
  - **Objetivo:**  
    Garantir que a animação de carregamento seja exibida de forma consistente e que os placeholders sejam criados e removidos apenas no chat ativo.
  - **Melhoria Proposta:**  
    - Utilizar uma classe CSS com `white-space: nowrap` e elementos inline para evitar que a animação quebre a linha.
    - Garantir a remoção imediata da animação assim que a resposta completa for recebida pelo evento `response_complete`.

- **Botão de Stop:**
  - **Objetivo:**  
    Assegurar que o botão de Stop interrompa completamente o processo de streaming, evitando que chamadas fiquem em segundo plano.
  - **Melhoria Proposta:**  
    - Revisar a implementação para utilizar mecanismos como `AbortController` no backend, cancelando requisições que ainda estejam em processamento.
    - Refinar o design do botão para que fique visualmente claro, utilizando um ícone (por exemplo, um “X” dentro de um retângulo) que comunique de forma imediata sua funcionalidade.

## 4.2. Padronização da Renderização e Sanitização

- **Consistência na Conversão de Conteúdo:**
  - **Objetivo:**  
    Garantir que todas as mensagens — sejam respostas da IA ou resultados do YouTube — sejam renderizadas de forma consistente, evitando riscos de injeção e discrepâncias visuais.
  - **Melhoria Proposta:**  
    - Utilizar sempre a conversão de Markdown através da biblioteca `marked` seguida de sanitização com o DOMPurify.
    - Utilizar a função `escapeHTML` apenas para conteúdos que não passaram pelo pipeline Markdown, mantendo a segurança e a integridade do HTML renderizado.

## 4.3. Monitoramento e Logs

- **Simplificação e Padronização dos Logs:**
  - **Objetivo:**  
    Facilitar o monitoramento e o debug sem sobrecarregar o sistema com informações redundantes.
  - **Melhoria Proposta:**  
    - Resumir os detalhes dos logs para destacar somente os eventos críticos, como erros de requisições, inconsistências no `conversation_id` ou falhas durante o streaming.
    - Garantir que os logs sejam enviados tanto para o backend quanto para o frontend com identificação clara do contexto (por exemplo, utilizando tags ou prefixos que indiquem se o log é relacionado à IA ou ao módulo do YouTube).

## 4.4. Isolamento por conversation_id

- **Validação e Consistência do Chat Ativo:**
  - **Objetivo:**  
    Evitar que mensagens de uma conversa "vazem" para outra e assegurar que todos os eventos (fetch, SSE, Socket.IO) carreguem o `conversation_id` corretamente.
  - **Melhoria Proposta:**  
    - Revisar e assegurar que cada requisição e evento inclua o `conversation_id` e que o frontend realize a verificação do `chatId` para descartar respostas que não correspondam ao chat atualmente ativo.
    - Implementar testes de troca de contexto para garantir que, caso o usuário mude de chat durante o processamento de uma mensagem, a resposta permaneça associada à conversa original.

## 4.5. Revisão dos Mecanismos de Divisão e Processamento de Texto

- **Otimização da Divisão em Chunks:**
  - **Objetivo:**  
    Garantir que a transcrição e o processamento para o resumo do YouTube sejam divididos em partes de forma que o processamento seja eficiente e o usuário receba respostas coerentes.
  - **Melhoria Proposta:**  
    - Revisar os métodos de divisão de texto no arquivo `text_processor.py`, assegurando que os chunks gerados sejam adequados para o processamento sem perder o contexto.
    - Ajustar a lógica de reenvio e renderização incremental para evitar redundâncias, especialmente se os chunks já forem processados de forma independente no fluxo final.

---


5. Arquitetura e Fluxos do Sistema
O Tópico 5 detalha a arquitetura do sistema conversacional, incluindo os fluxos de dados entre o frontend e o backend, o funcionamento das principais funcionalidades (transcrição, resumo e comunicação com IA) e os mecanismos de isolamento e streaming que garantem a coesão e a segurança do sistema. Esta seção também apresenta diagramas visuais para ilustrar os processos e destaca aspectos críticos como o uso do conversation_id para evitar vazamentos entre chats.

5.1. Visão Geral da Arquitetura
O sistema é uma aplicação web baseada em Flask (backend) e JavaScript/HTML/CSS (frontend), projetada para oferecer interações em tempo real com três funcionalidades principais:
Transcrição de Vídeos do YouTube: Extrai e processa legendas de vídeos.
Resumo de Vídeos do YouTube: Gera resumos concisos a partir das transcrições.
Comunicação com Inteligência Artificial (IA): Permite conversas dinâmicas com respostas renderizadas incrementalmente.
A arquitetura utiliza o Socket.IO para comunicação assíncrona, garantindo atualizações em tempo real. O isolamento entre conversas é assegurado pelo uso consistente do conversation_id, enquanto a renderização no frontend é unificada com Markdown (marked) e sanitização (DOMPurify).
Componentes Principais
Backend:
app.py: Servidor Flask que gerencia rotas, endpoints e eventos Socket.IO.
youtube_handler.py: Processa vídeos do YouTube (download e limpeza de legendas).
text_processor.py: Manipula e divide textos em chunks.
chat_storage.py: Gerencia o armazenamento e histórico das conversas.
init_eventlet.py: Configura o ambiente assíncrono com Eventlet.
Frontend:
chatUI.js: Controla a interface e captura interações do usuário.
messageRenderer.js: Renderiza mensagens incrementalmente no DOM.
commandHandler.js: Processa comandos como /youtube e /youtube_resumo.
utils.js: Fornece funções auxiliares (ex.: escape HTML, animações).

5.2. Fluxo de Dados e Processos
O sistema segue um fluxo bem definido para processar mensagens e comandos, desde a interação do usuário até a renderização final. Abaixo, descrevemos os fluxos gerais e específicos para cada funcionalidade.
5.2.1. Fluxo Geral de Dados
Entrada do Usuário:
O usuário digita uma mensagem ou comando (ex.: /youtube <URL>) no frontend (chatUI.js).
A mensagem é enviada ao backend via HTTP (fetch) ou Socket.IO, sempre acompanhada do conversation_id.
Processamento no Backend:
O app.py recebe a requisição e verifica/armazena a mensagem em chat_storage.py.
Dependendo do tipo de mensagem:
Mensagem normal: Encaminhada para process_with_ai_stream() para interação com a IA.
Comando YouTube: Direcionada ao youtube_handler.py para processamento específico.
Streaming de Respostas:
Respostas são geradas em chunks (IA ou YouTube) e emitidas via Socket.IO para o frontend.
Cada chunk carrega o conversation_id, garantindo que seja renderizado no chat correto.
Renderização no Frontend:
O messageRenderer.js converte os chunks em Markdown, aplica sanitização e atualiza o DOM incrementalmente.
O evento response_complete finaliza o streaming, removendo placeholders.
Persistência:
O histórico é atualizado em chat_storage.py, associando mensagens ao conversation_id.
5.2.2. Fluxo Específico: Comunicação com IA
Entrada: Usuário envia mensagem via /send_message.
Processamento: process_with_ai_stream() chama a API da IA (ex.: gemma2:2b), gerando chunks.
Saída: Chunks são emitidos via Socket.IO (message_chunk) e renderizados em tempo real.
5.2.3. Fluxo Específico: Transcrição do YouTube
Entrada: Comando /youtube <URL> enviado via /process_youtube.
Processamento: youtube_handler.py baixa legendas com yt_dlp, limpa o texto e formata a resposta.
Saída: Resultado enviado como mensagem única via Socket.IO (youtube_response).
5.2.4. Fluxo Específico: Resumo do YouTube
Entrada: Comando /youtube_resumo <URL> enviado via /process_youtube_resumo.
Processamento:
youtube_handler.py baixa e divide a transcrição em blocos (~300 palavras).
Cada bloco é processado pela IA para gerar resumos.
Saída: Resumos são enviados como chunks via Socket.IO (message_chunk), com cabeçalhos por bloco.

5.3. Diagrama de Fluxo de Dados (DFD)
Abaixo está o diagrama em MermaidJS que ilustra o fluxo completo do sistema, destacando o isolamento por conversation_id e a integração entre os módulos.
mermaid
flowchart TD
    %% Frontend: Captura e Envio
    A[Usuário Interage<br>(input ou comando)]
    A --> B[chatUI.js:<br>Captura e envia mensagem]
    
    %% Envio para o Backend
    B -->|HTTP ou Socket.IO<br>com conversation_id| C[app.py:<br>Recebe requisição]
    
    %% Processamento no Backend
    C --> D[chat_storage.py:<br>Verifica e armazena]
    D --> E{Tipo da Mensagem?}
    E -->|Normal| F[process_with_ai_stream():<br>Geração de chunks]
    E -->|/youtube ou /youtube_resumo| G[youtube_handler.py:<br>Processa YouTube]
    
    %% Streaming e Resposta
    F --> H[Socket.IO:<br>Emite message_chunk]
    G --> I[Divisão e<br>Processamento]
    I --> H
    
    %% Renderização no Frontend
    H -->|room=conversation_id| J[messageRenderer.js:<br>Renderização incremental]
    J --> K[DOM:<br>Markdown + Sanitização]
    
    %% Finalização
    K --> L[Evento response_complete:<br>Finaliza streaming]
    
    %% Armazenamento
    D --> M[chat_storage.py:<br>Atualiza histórico]
Aspectos Destacados
Isolamento: O conversation_id é usado em todas as etapas para garantir que mensagens sejam processadas e exibidas no chat correto.
Streaming: Tanto a IA quanto o YouTube utilizam Socket.IO para enviar chunks, permitindo renderização em tempo real.
Modularidade: Os fluxos de IA e YouTube são distintos, mas convergem no mesmo pipeline de renderização.

5.4. Mecanismos Críticos
5.4.1. Isolamento por conversation_id
Funcionamento: Cada conversa tem um identificador único (conversation_id), gerado em chat_storage.py. Todas as requisições e eventos Socket.IO usam esse ID para associar mensagens ao chat correto.
Implementação:
Backend: join_room(conversation_id) associa clientes a salas específicas.
Frontend: Verifica if (response.conversation_id !== currentChatId) para descartar mensagens irrelevantes.
Benefício: Evita "vazamentos" entre chats, mesmo em cenários de troca rápida de contexto.
5.4.2. Streaming em Tempo Real
Funcionamento: Respostas são divididas em chunks e enviadas via Socket.IO (message_chunk), com finalização sinalizada por response_complete.
Implementação:
Backend: process_with_ai_stream() e process_youtube_resumo_background() geram chunks dinamicamente.
Frontend: messageRenderer.js atualiza o DOM sem acumulação redundante.
Benefício: Permite feedback imediato ao usuário, mantendo a interface responsiva.
5.4.3. Renderização e Sanitização
Funcionamento: Todo conteúdo é convertido para Markdown (marked.parse) e sanitizado (DOMPurify.sanitize) antes de ser inserido no DOM.
Implementação: Centralizado em messageRenderer.js, aplicado a respostas da IA e YouTube.
Benefício: Garante segurança contra XSS e consistência visual.

5.5. Pontos de Integração
Frontend-Backend: Comunicação via Socket.IO e HTTP, com conversation_id como chave de roteamento.
IA-YouTube: Fluxos paralelos que convergem no streaming e renderização, mantendo independência operacional.
Armazenamento: chat_storage.py atua como camada central para persistência, usada por todos os módulos.

5.6. Considerações sobre Escalabilidade
Processamento Assíncrono: O uso de Eventlet e Socket.IO suporta múltiplos usuários e chats simultâneos.
Modularidade: A separação entre IA e YouTube facilita expansões futuras (ex.: suporte a novos comandos).
Persistência: O armazenamento em JSON é funcional, mas pode ser substituído por um banco de dados para maior escala.

---

# 6. Diagrama de Fluxo de Dados Atualizado

Nesta seção, apresentamos diagramas em MermaidJS que sintetizam o fluxo de dados de forma clara. Os diagramas ilustram como as requisições são processadas, desde o envio da mensagem pelo usuário até a renderização incremental dos dados no frontend e a integração entre os módulos de transcrição, resumo e comunicação com a IA.

## 6.1. Diagrama Geral do Sistema

```mermaid
flowchart TD
    %% Frontend: Captura e Envio
    A[Usuário Interage (input de mensagem ou comando)]
    A --> B[chatUI.js: Captura e envia mensagem]
    
    %% Envio para o Backend via HTTP / Socket.IO
    B --> C[app.py: Recebe requisição com conversation_id]
    
    %% Processamento no Backend
    C --> D[Verifica e armazena a mensagem (chat_storage.py)]
    D --> E{Tipo da Mensagem?}
    E -- Mensagem Normal --> F[Processamento da IA]
    E -- Comando /youtube ou /youtube_resumo --> G[youtube_handler.py: Processa YouTube]
    
    %% Streaming e Resposta
    F --> H[process_with_ai_stream(): Geração de chunks]
    G --> I[Divisão e Processamento do Texto]
    H & I --> J[Socket.IO: Emite chunks para o frontend]
    
    %% Renderização no Frontend
    J --> K[messageRenderer.js: Renderização incremental]
    K --> L[Atualiza DOM com Markdown e Sanitização]
    
    %% Feedback e Finalização
    L --> M[Evento response_complete: Finaliza streaming]
    
    %% Armazenamento do Histórico
    D --> N[chat_storage.py: Atualiza histórico de conversas]
```

## 6.2. Aspectos Destacados no Diagrama

- **Isolamento por conversation_id:**  
  Todas as requisições e eventos carregam o `conversation_id`, garantindo que cada mensagem e resposta sejam processadas e renderizadas somente no chat correto.

- **Fluxo Paralelo para IA e YouTube:**  
  O diagrama diferencia, a partir de uma decisão (bloco E), o processamento normal (para a IA) e o processamento específico dos comandos do YouTube. Apesar de distintos, ambos utilizam o mesmo mecanismo de streaming via Socket.IO para enviar chunks de resposta ao frontend.

- **Renderização Incremental:**  
  Os chunks de resposta são enviados progressivamente para o frontend, onde a função de renderização (messageRenderer.js) converte o conteúdo para Markdown, aplica sanitização (com DOMPurify) e atualiza o DOM de forma contínua, mantendo o usuário informado em tempo real.

- **Finalização e Armazenamento:**  
  Após a conclusão do processamento e streaming, o evento `response_complete` sinaliza a finalização do fluxo de dados, enquanto o histórico é atualizado no backend para futuras consultas.

---

# 7. Conclusão e Considerações Finais

## 7.1. Resumo dos Pontos Principais

- **Funcionalidades Consolidadas:**  
  - **Transcrição e Resumo do YouTube:** O sistema já capta legendas de vídeos, as processa e gera resumos de forma eficaz.  
  - **Interação com a Inteligência Artificial:** O fluxo de mensagens e o processamento em streaming estão funcionando, com isolamento das conversas por `conversation_id`.  
  - **Armazenamento e Histórico:** A criação, atualização e recuperação das conversas funcionam corretamente, possibilitando a manutenção do histórico dos chats.

- **Arquitetura e Fluxo de Dados:**  
  - O sistema integra a comunicação via Socket.IO para atualizações em tempo real, garantindo que cada mensagem e resposta seja associada ao chat correto.  
  - A separação dos fluxos, tanto para a IA quanto para o processamento do YouTube, permite que modificações em uma área não comprometam a outra.

- **Refinamentos e Melhorias Pendentes:**  
  - Ajustes na interface do frontend (animação de carregamento, botão de Stop e placeholders) para uma experiência de usuário mais clara e consistente.  
  - Padronização da renderização e sanitização do conteúdo (Markdown com `marked` seguido de DOMPurify) para segurança e consistência visual.  
  - Otimizações na lógica de verificação e isolamento via `conversation_id`, assegurando que as respostas sejam canalizadas corretamente mesmo em situações de troca de contexto ou multitarefa.

## 7.2. Próximos Passos

- **Implementação dos Refinamentos:**  
  - Continuar a aprimorar os elementos de interface e a lógica de streaming, evitando qualquer acúmulo desnecessário ou duplicação de dados.
  - Revisar e testar a funcionalidade do botão de Stop, assegurando que ele interrompa os processos de streaming como esperado.

- **Testes e Validações:**  
  - Desenvolver e expandir os testes unitários e de integração para validar o isolamento por `conversation_id` e o fluxo completo de dados.
  - Monitorar logs e desempenho para detectar e corrigir eventuais problemas, garantindo a robustez do sistema durante cenários de uso real.

- **Documentação Contínua:**  
  - Manter a documentação atualizada à medida que novos requisitos e refinamentos são implementados, permitindo uma transição suave para desenvolvedores e sistemas de suporte.
  - Incluir novos diagramas e exemplos de uso quando houver alterações significativas nas funcionalidades ou na arquitetura do sistema.

## 7.3. Considerações Finais

A documentação apresentada reflete o estado atual do sistema, destacando as funcionalidades já consolidadas e os pontos onde melhorias ainda são necessárias. A abordagem modular e o isolamento por `conversation_id` garantem que as integrações entre os diversos módulos — transcrição, resumo e IA — operem de maneira coesa e sem interferências.  

Com estes ajustes e refinamentos, o sistema se torna mais robusto, escalável e de fácil manutenção, proporcionando uma experiência de usuário consistente e segura. A continuidade do monitoramento e dos testes garantirá que futuras atualizações sejam incorporadas sem comprometer o funcionamento das funcionalidades essenciais.




Conteúdo de 2- DFD com foco no youtube.md:
graph TD
    %% Nível 0: Visão Geral
    subgraph Sistema_de_Chat_com_IA
        A[Usuário] -->|Mensagem ou Comando| B[Interface do Chat Frontend]
        B -->|Input| C[Processamento no Frontend]
        C -->|Requisição com conversation_id| D[Backend do Sistema]
        D -->|Resposta com conversation_id| C
        C -->|Exibição| B
        D -->|Armazenamento| E[Armazenamento JSON ou Banco]
        D -->|Chamada API| F[API Externa como YouTube]
        F -->|Dados| D
    end

    %% Nível 1: Frontend - Foco no Indicador de Carregamento
    subgraph Processamento_no_Frontend
        C --> C1[enviarMensagem]
        C1 --> C2{mensagem vazia?}
        C2 -->|Sim| C3[Retorna sem ação]
        C2 -->|Não| C4{mensagem é /youtube ou /youtube_resumo?}

        %% Fluxo Comando /youtube ou /youtube_resumo
        C4 -->|Sim| C5[Extrair videoUrl]
        C5 --> C6{videoUrl válido?}
        C6 -->|Não| C7[Erro: URL inválida]
        C6 -->|Sim| C8{Conversa existe?}
        C8 -->|Não| C9[criarNovaConversa]
        C8 -->|Sim| C10[Adicionar mensagem com conversation_id]
        C9 --> C10
        C10 --> C11[Atualizar histórico]
        C11 --> C12[Mostrar carregamento]
        C12 --> C13[Requisição /process_youtube ou /process_youtube_resumo com conversation_id]
        C13 --> D1[Backend: Processar YouTube]
        D1 -->|Resposta ou Erro com conversation_id| C14[Remover carregamento]
        C14 --> C15[Exibir resposta ou erro]
        C15 --> C16[Atualizar histórico]

        %% Fluxo Mensagem Normal
        C4 -->|Não| C17{Conversa existe?}
        C17 -->|Não| C18[criarNovaConversa]
        C17 -->|Sim| C19[Adicionar mensagem com conversation_id]
        C18 --> C19
        C19 --> C20[Atualizar histórico]
        C20 --> C21[Mostrar animação de carregamento]
        C21 --> C22[Requisição /send_message com conversation_id]
        C22 --> D2[Backend: Processar Mensagem]
        D2 -->|Chunks com conversation_id| C23[Criar responseDiv]
        C23 --> C24[Atualizar em tempo real]
        C24 -->|Fim streaming| C25[Remover animação]
        C25 --> C26[Exibir resposta final]
        C26 --> C27[Atualizar histórico]
    end

    %% Nível 1: Backend
    subgraph Backend_do_Sistema
        D1 --> D3[Receber video_url e conversation_id]
        D3 -->|Chamada API| F1[API YouTube]
        F1 -->|Dados| D3
        D3 --> D4{Processamento OK?}
        D4 -->|Sim| D5[Retornar texto processado com conversation_id]
        D4 -->|Não| D6[Retornar erro com conversation_id]
        D5 -->|Armazenar| E1[JSON ou Banco]
        D6 -->|Armazenar| E1

        D2 --> D7[Receber message e conversation_id]
        D7 --> D8[Chamada ao modelo de IA]
        D8 -->|Streaming| D9[Processar chunks]
        D9 -->|Chunks com conversation_id| D10[Enviar ao frontend via Socket.IO]
        D10 -->|Resposta completa| D11[Retornar ao frontend]
        D11 -->|Armazenar| E1
    end

    %% Eventos
    E1 -->|Histórico atualizado| C28[Evento: historicoAtualizado]

Conteúdo de 3-implementacao-streaming-mensagens.md:
**Documentação do Projeto - Sistema de Chat com Streaming**  
**Última Atualização:** 25/04/2024  
**Status Atual:** Resolução de duplicação de mensagens pós-reinicialização  

---

### **Contexto do Problema**  
**Problema:** Duplicação de containers de mensagem após reiniciar servidor/página, com dois sistemas concorrentes:  
1. Streaming em tempo real (`message_chunk`)  
2. Renderização pós-completo (`response_complete`)  

**Evidência no HTML:**  
```html
<!-- Container de streaming (vazio) -->
<div id="message-bc061d98-..." class="message assistant">
    <div class="message-content"></div> 
</div>

<!-- Mensagem final duplicada -->
<div class="message assistant">
    <div class="message-content">...</div> 
</div>
```

---

### **Solução Implementada**  
#### Passo 1: Unificação de Containers  
**Arquivo:** `static/js/messageRenderer.js`  
```javascript
// Controle de estado global
let activeStreams = new Map();

export const renderMessageChunk = (messageId, chunk) => {
    if (!activeStreams.has(messageId)) {
        const container = document.createElement('div');
        container.className = 'message assistant streaming';
        container.dataset.messageId = messageId;
        document.querySelector('.chat-container').appendChild(container);
        activeStreams.set(messageId, {
            container,
            content: ''
        });
    }
    
    const stream = activeStreams.get(messageId);
    stream.content += chunk;
    stream.container.innerHTML = DOMPurify.sanitize(marked.parse(stream.content + '<span class="cursor">█</span>'));
};
```

#### Passo 2: Desativação da Renderização Final  
**Arquivo:** `static/js/chat/chatActions.js`  
```javascript
// Comentar/remover esta seção:
// socket.on('response_complete', ({ messageId }) => {
//     // Código que causa duplicação
// });
```

---

### **Checklist de Verificação**  
1. [ ] Backend está usando **mesmo messageId** para chunks e conclusão  
2. [ ] Evento `response_complete` está **comentado/removido**  
3. [ ] Sistema de cache (`activeStreams`) está sendo **limpo após erro/reinício**  
4. [ ] Containers vazios são **removidos automaticamente** (código abaixo)  

---

### **Código de Limpeza Automática**  
**Adicionar em `messageRenderer.js`:**  
```javascript
// Limpeza de containers órfãos a cada 5s
setInterval(() => {
    document.querySelectorAll('.message.assistant').forEach(container => {
        if (!container.querySelector('.message-content').innerHTML.trim()) {
            container.remove();
        }
    });
}, 5000);
```

---

### **Próximos Passos**  
1. **Teste de Reinicialização Forçada**  
   ```bash
   while true; do curl http://localhost:5000/restart-server; sleep 5; done
   ```
2. **Monitoramento de Estado**  
   ```javascript
   // Debug no console
   setInterval(() => {
       console.log('Active Streams:', Array.from(activeStreams.keys()));
   }, 3000);
   ```

---

### **Notas Técnicas**  
- **Critical Path:** Garantir que o `messageId` seja **imutável** durante todo o ciclo da mensagem  
- **Armadilha Comum:** Containers fantasmas de sessões anteriores não limpos  
- **Solução Alternativa:** Usar `sessionStorage` para persistir estado entre recarregamentos  

[Relatar problema ou continuar diagnóstico ▶](https://github.com/seu-usuario/chat-system/issues)


-------------

Vou documentar o que foi feito até agora em português:

1. **Análise Inicial do Problema**:
   - Identificamos um problema de duplicação de mensagens no sistema de chat
   - O problema ocorre mesmo após reiniciar o servidor e a página
   - Há containers vazios e duplicados no HTML

2. **Implementações Realizadas**:

   a) **Em `messageRenderer.js`**:
   - Adicionamos um sistema de cache para chunks de mensagem
   - Implementamos limpeza de containers vazios
   - Adicionamos um sistema de backup para limpeza periódica
   - Melhoramos o scroll automático
   - Adicionamos estilos para o cursor piscante

   b) **Em `chatActions.js`**:
   - Adicionamos monitoramento de streams ativos
   - Removemos a duplicação no evento `response_complete`
   - Implementamos um log periódico para debug

3. **Estrutura Atual do Sistema**:

   ```javascript
   // messageRenderer.js
   const messageCache = new Map();
   let activeStreams = new Set();

   export const renderMessageChunk = (messageId, chunk, isComplete = false) => {
       // Lógica de renderização de chunks
   };

   export const completeMessage = (messageId) => {
       // Lógica de conclusão de mensagem
   };

   // Sistema de backup para limpeza
   const backupContainerCheck = setInterval(() => {
       // Limpeza de containers vazios
   }, 5000);
   ```

   ```javascript
   // chatActions.js
   const streamingMessages = new Set();
   let activeStreams = new Set();

   export const handleSocketMessages = (socket) => {
       socket.on('message_chunk', ({ messageId, content }) => {
           // Lógica de streaming
       });

       socket.on('response_complete', ({ messageId }) => {
           // Lógica de conclusão
       });

       socket.on('stream_error', ({ messageId }) => {
           // Tratamento de erros
       });
   };
   ```

4. **Problemas Identificados**:
   - Possível conflito entre eventos de streaming e renderização final
   - Inconsistência nos `messageId`s
   - Containers vazios não sendo limpos adequadamente
   - Possível vazamento de memória com referências a elementos DOM

5. **Próximos Passos Sugeridos**:
   - Verificar e desativar o evento `response_complete`
   - Garantir consistência nos `messageId`s
   - Refinar a lógica de limpeza
   - Implementar verificações periódicas
   - Testar com diferentes cenários

6. **Melhorias Implementadas**:
   - Unificação do sistema de renderização
   - Melhor gerenciamento de estado
   - Limpeza automática de recursos
   - Tratamento de erros mais robusto

7. **Pontos de Atenção**:
   - Necessidade de sincronização entre frontend e backend
   - Importância da consistência dos IDs de mensagem
   - Gerenciamento adequado do ciclo de vida dos containers
   - Monitoramento e limpeza de recursos

Você gostaria que eu detalhasse algum aspecto específico ou que prosseguíssemos com alguma das melhorias sugeridas?


Conteúdo de 4-resolucao-problemas-duplicacao-mensagens.md:
# Resolução de Problemas: Sistema de Chat com IA

## Análise do Problema

Durante o desenvolvimento do projeto, identificamos e corrigimos vários problemas relacionados à duplicação de mensagens e gestão de estado durante o streaming. A análise do arquivo de log `app_20250425.log` mostra que as correções que implementamos foram bem-sucedidas, com o sistema funcionando corretamente.

## Principais Problemas Resolvidos

1. **Erro na função `completeMessage`**:
   - Identificamos que havia uma incompatibilidade entre a chamada ao método `messageRegistry.completeMessage()` e sua implementação.
   - O método estava sendo chamado com dois parâmetros (`messageId` e `conversationId`), mas a implementação aceitava apenas um parâmetro (`messageId`).
   - Corrigimos as chamadas nos arquivos `messageRenderer.js` e `streamingManager.js` para passar apenas o parâmetro `messageId`.

2. **Problema com a renderização de conteúdo**:
   - Modificamos a função `renderContent` para atualizar apenas o conteúdo dentro da div `message-content`, em vez de substituir toda a estrutura do container de mensagem.
   - Isso garantiu que os botões de ação e outras estruturas permanecessem intactos durante a atualização do conteúdo.

3. **Função `createContainer`**:
   - Implementamos a função `createContainer` que estava faltando, permitindo a criação adequada de containers para novas mensagens.
   - A função verifica a existência de containers existentes e cria novos quando necessário.

4. **Função `cleanupOrphan`**:
   - Corrigimos a função para usar os métodos corretos do `messageRegistry`: `getMessage` em vez de `get` e `removeMessage` em vez de `delete`.
   - Isso garantiu a correta limpeza de mensagens órfãs no DOM.

## Arquitetura do Sistema

O sistema utiliza uma arquitetura baseada em:

1. **Backend (Flask/Python)**:
   - Gerencia conversas e histórico
   - Integra com modelos de IA
   - Fornece endpoints para envio e recebimento de mensagens via Socket.IO

2. **Frontend (JavaScript)**:
   - Utiliza módulos organizados para gerenciar diferentes aspectos do chat
   - `messageRegistry.js`: Sistema centralizado para controle do ciclo de vida das mensagens
   - `streamingManager.js`: Gerencia o streaming em tempo real
   - `messageRenderer.js`: Responsável pela renderização das mensagens
   - `chatActions.js`: Controla as ações do usuário no chat
   - `chatUI.js`: Gerencia a interface de usuário do chat

3. **Sistema de Comunicação**:
   - Unificado em Socket.IO, eliminando o uso de Server-Sent Events (SSE)
   - Eventos como `message_chunk` e `response_complete` coordenam o ciclo de vida das mensagens

## Lições Aprendidas

1. **Importância da centralização do registro de mensagens**:
   - O `messageRegistry` centralizado evita duplicação de mensagens
   - Mantém a consistência do estado entre diferentes componentes

2. **Consistência nos métodos de API**:
   - É crucial que a chamada de métodos corresponda à sua implementação
   - Documentar adequadamente a assinatura dos métodos

3. **Depuração eficiente**:
   - O sistema de logging detalhado permite identificar rapidamente problemas
   - Manter consistência na nomenclatura e nos identificadores facilita o diagnóstico

4. **Gerenciamento de estado**:
   - Utilizar uma fonte única de verdade para o estado das mensagens
   - Implementar mecanismos de limpeza para evitar vazamentos de memória

## Mudanças Implementadas

1. **Fase 1 - Centralização do `messageRegistry`**:
   - Criação de um registro centralizado para todas as mensagens
   - Garantia de acesso consistente ao registry em todos os módulos

2. **Fase 2 - Correção de erros críticos**:
   - Implementação da função `createContainer` ausente
   - Correção no `cleanupOrphan` para usar os métodos corretos

3. **Fase 3 - Refinamento da renderização**:
   - Melhoria na função `renderContent` para preservar a estrutura DOM
   - Correção nas chamadas a `completeMessage` para usar a assinatura correta

4. **Fase 4 - Validação final**:
   - Verificação do log para confirmar operação correta
   - Teste de integração com processamento de mensagens em tempo real

## Estado Atual

O arquivo de log `app_20250425.log` demonstra que o sistema está funcionando corretamente:
- As conexões Socket.IO são estabelecidas com sucesso
- As mensagens são enviadas e recebidas corretamente
- O streaming de chunks funciona adequadamente
- As mensagens são completadas sem erros fatais

Há apenas um erro não crítico relacionado à função `marked.parse()` com parâmetros nulos, que pode ser investigado em uma próxima iteração, mas não impede o funcionamento principal do sistema.

## Próximos Passos Recomendados

1. **Resolver o erro com `marked.parse()`**:
   - Investigar por que está recebendo parâmetros nulos
   - Implementar validação adequada antes da chamada

2. **Melhorar o tratamento de erros**:
   - Implementar recuperação mais robusta de falhas
   - Adicionar notificações visuais de erros para o usuário

3. **Otimizações de desempenho**:
   - Implementar renderização virtual para grandes históricos
   - Otimizar a limpeza de containers órfãos

4. **Expansão de funcionalidades**:
   - Implementar as melhorias sugeridas na documentação
   - Desenvolver recursos de exportação e compartilhamento 

Conteúdo de 5-problemas-interacao-eventos.md:
# Problemas de Interação com Eventos no Sistema de Chat

## Resumo do Problema

Durante o desenvolvimento e manutenção do sistema de chat, encontramos diversos problemas relacionados ao tratamento de eventos JavaScript, especialmente na interação entre diferentes componentes do sistema. Os problemas principais estavam relacionados a:

1. **Inconsistência no tratamento de eventos de formulário** - Problemas com `preventDefault()` e com objetos de evento personalizados
2. **Gestão do cursor de digitação** - Falhas ao criar e remover o cursor de digitação durante o ciclo de mensagens
3. **Elementos DOM não encontrados** - Tentativas de manipular elementos antes de estarem disponíveis no DOM
4. **Problemas de sincronização entre eventos** - Desafios na coordenação entre eventos de envio, recebimento e renderização de mensagens
5. **Problemas na gestão de estado** - Dificuldades em manter o estado consistente entre diferentes componentes

## Problemas Específicos e Soluções Tentadas

### 1. Problema com o método `preventDefault()`

**Problema**: Ao enviar mensagens usando a tecla Enter no textarea, ocorria um erro do tipo "TypeError" indicando que `e.preventDefault is not a function`. Este erro ocorria quando eventos de submit eram criados manualmente sem implementar completamente a interface de eventos.

**Análise**: No arquivo `textarea.js`, identificamos que estava sendo criado um evento de submit personalizado usando `new Event('submit')` que não tinha o método `preventDefault()` implementado.

**Solução tentada**: 
- Modificamos o código para usar `SubmitEvent` quando disponível
- Implementamos um fallback para criar um `Event` regular com uma implementação manual de `preventDefault()`
- Adicionamos verificação de tipo antes de chamar `preventDefault()` na função `enviarMensagem`

```javascript
try {
    const event = new SubmitEvent('submit', {
        bubbles: true,
        cancelable: true
    });
    form.dispatchEvent(event);
} catch (error) {
    console.debug("[TEXTAREA] Fallback para Event padrão:", error);
    let event = new Event('submit', {
        bubbles: true,
        cancelable: true
    });
    
    if (typeof event.preventDefault !== 'function') {
        event.preventDefault = function() {
            console.debug("[TEXTAREA] preventDefault chamado no evento personalizado");
        };
    }
    
    form.dispatchEvent(event);
}
```

**Resultado**: Mesmo com esta correção, ainda ocorreram problemas em alguns navegadores ou condições específicas, sugerindo que a disparidade entre os diferentes tipos de eventos é mais complexa do que o esperado.

### 2. Problema com Tratamento de Parâmetros em `enviarMensagem`

**Problema**: A função `enviarMensagem` não estava preparada para lidar com diferentes tipos de parâmetros (eventos vs. string de mensagem).

**Análise**: A função estava assumindo que o primeiro parâmetro era sempre um evento, mas em alguns casos era chamada diretamente com uma string. Além disso, havia inconsistências entre as chamadas de diferentes partes do código.

**Solução tentada**: 
- Refatoramos a função para aceitar tanto um objeto de evento quanto uma string diretamente
- Adicionamos verificações de tipo robustas para determinar como tratar o parâmetro
- Implementamos código defensivo para lidar com erros de `preventDefault()`

```javascript
function enviarMensagem(eventOrMessage, conversationId) {
    console.debug("[CHAT ACTIONS] Tentativa de enviar mensagem, parâmetro:", eventOrMessage);
    
    // Verificar se o primeiro parâmetro é um evento e prevenir comportamento padrão
    let mensagem = '';
    if (eventOrMessage && typeof eventOrMessage === 'object' && eventOrMessage.preventDefault && typeof eventOrMessage.preventDefault === 'function') {
        try {
            eventOrMessage.preventDefault();
            console.debug("[CHAT ACTIONS] Evento de formulário interceptado e prevenido");
        } catch (err) {
            console.warn("[CHAT ACTIONS] Erro ao prevenir evento:", err);
        }
        // Obter mensagem do campo de entrada
        const messageInput = document.getElementById('message-input');
        mensagem = messageInput ? messageInput.value.trim() : '';
    } else if (typeof eventOrMessage === 'string') {
        // O primeiro parâmetro já é a mensagem
        mensagem = eventOrMessage.trim();
    } else {
        console.error("[CHAT ACTIONS] Parâmetro inválido para enviarMensagem:", eventOrMessage);
        return Promise.resolve(false);
    }
    
    // [resto da função...]
}
```

**Resultado**: A função ficou mais robusta, mas introduziu complexidade adicional. O ideal seria padronizar todas as chamadas para usar um formato consistente em todo o código.

### 3. Problema com Elementos DOM não Encontrados

**Problema**: Ocorreram erros indicando que elementos como `.chat-container` não foram encontrados, causando erros de `appendChild is not a function`.

**Análise**: Identificamos que algumas funções estavam tentando manipular elementos DOM antes que estivessem disponíveis ou em condições onde não existiam. Isso ocorria especialmente durante a inicialização da aplicação ou durante mudanças de conversas.

**Solução tentada**:
- Adicionamos verificações mais robustas de existência de elementos antes de operações DOM
- Verificamos se elementos são instâncias válidas de `Element` antes de chamar métodos DOM
- Adicionamos tratamento de erros para falhas de manipulação DOM

```javascript
// Verificar se o contêiner de chat existe
const chatContainer = document.querySelector('.chat-container');
if (!chatContainer || !(chatContainer instanceof Element)) {
    console.error("[CHAT ACTIONS] Contêiner de chat não encontrado ou inválido");
    alert("Erro ao enviar mensagem: contêiner de chat não encontrado. Tente recarregar a página.");
    return Promise.resolve(false);
}
```

**Resultado**: Reduziu os erros não tratados, mas ainda havia ocasiões onde os elementos não eram encontrados devido à ordem de carregamento ou a problemas de timing.

### 4. Problema com Gerenciamento de Cursores de Digitação

**Problema**: O sistema de criação e remoção de cursores de digitação estava falhando, especialmente em casos de erro durante o envio de mensagens.

**Análise**: O código para gerenciar cursores não estava verificando adequadamente a existência dos elementos DOM necessários e não tinha um ciclo de vida claro, resultando em cursores órfãos ou duplicados.

**Solução tentada**:
- Verificação robusta da existência do `chatContainer` antes de criar cursores
- Tratamento adequado de erros durante a criação do cursor
- Implementação correta de limpeza em caso de falha de envio

```javascript
// Criar cursor de digitação
let cursorContainer = null;
try {
    cursorContainer = cursorManager.createCursor(activeConversationId);
    console.debug("[CHAT ACTIONS] Cursor de digitação criado para conversa:", activeConversationId);
} catch (err) {
    console.warn("[CHAT ACTIONS] Erro ao criar cursor de digitação:", err);
    // Continuar mesmo sem o cursor
}
```

**Resultado**: O tratamento de erros melhorou, mas ainda havia casos onde os cursores persistiam indevidamente ou não eram criados quando deveriam.

### 5. Problema de Gestão de Estado e Comunicação entre Componentes

**Problema**: Diversos componentes do sistema (chat UI, cursor, mensagens) tentavam gerenciar seu próprio estado sem uma coordenação central, levando a estados inconsistentes.

**Análise**: A arquitetura do sistema consistia em módulos frouxamente acoplados que se comunicavam principalmente através de manipulação direta do DOM ou eventos personalizados, sem um fluxo de dados claro.

**Solução tentada**:
- Criação de um sistema centralizado de registro de mensagens (`messageRegistry`)
- Implementação de mecanismos de comunicação via eventos do socket
- Tentativa de sincronização dos estados em pontos-chave do ciclo de vida das mensagens

**Resultado**: Resolveu parcialmente o problema, mas a falta de uma estrutura mais robusta de gestão de estado continuou causando problemas de sincronização.

## Lições Aprendidas

1. **Validação rigorosa de tipos** - Sempre verificar o tipo dos parâmetros antes de acessar propriedades ou métodos.

2. **Verificação de elementos DOM** - Nunca assumir que elementos DOM estão presentes; sempre verificar antes de manipulá-los.

3. **Tratamento defensivo de eventos** - Ao criar eventos personalizados, garantir que eles tenham todos os métodos necessários.

4. **Logging abrangente** - Implementar um sistema de logging que capture informações detalhadas sobre o estado do sistema.

5. **Promessas em vez de valores diretos** - Retornar Promises consistentemente ao lidar com operações assíncronas.

6. **Tratamento de erros em cadeia** - Usar `catch` e `finally` para garantir que recursos sejam liberados mesmo em caso de erro.

7. **Gerenciamento de estado claro** - Manter um fluxo de estado claro para recursos como cursores de digitação.

8. **Fallbacks para APIs de navegador** - Implementar fallbacks para APIs que podem não estar disponíveis em todos os navegadores.

9. **Arquitetura orientada a eventos com cautela** - Usar eventos com cuidado, pois introduzem acoplamento implícito difícil de rastrear.

10. **Evitar manipulação DOM direta em componentes de lógica** - Separar claramente a lógica de negócio da manipulação do DOM.

## Proposta de Reestruturação

Para resolver os problemas de forma mais definitiva, sugerimos uma reestruturação significativa da arquitetura:

### 1. Adoção de um Fluxo de Dados Unidirecional

Implementar uma arquitetura de fluxo de dados unidirecional inspirada em padrões como Flux ou Redux:

```
┌─────────┐       ┌──────────┐       ┌─────────┐       ┌──────┐
│  Ações  │──────▶│  Estado  │──────▶│  Views  │──────▶│ DOM  │
└─────────┘       └──────────┘       └─────────┘       └──────┘
     ▲                                    │                
     └────────────────────────────────────┘                
```

### 2. Separação Mais Clara entre Componentes

Dividir o sistema em camadas bem definidas:

- **Camada de UI**: Responsável apenas por renderizar a interface com base no estado
- **Camada de Estado**: Gerencia todo o estado da aplicação de forma centralizada
- **Camada de Serviços**: Lida com comunicação com o servidor, WebSockets, etc.
- **Camada de Utilitários**: Funções puras para transformação de dados

### 3. Sistema de Tipos Rigoroso

Adotar TypeScript para todo o código frontend, definindo interfaces claras para:

- Tipos de mensagens
- Estados de conversas
- Eventos de socket
- Parâmetros de funções

### 4. Sistema de Testes Automatizados

Implementar testes automatizados para:

- Comportamento da UI
- Fluxo de mensagens
- Manipulação de eventos
- Casos de erro e recuperação

### 5. Sistema de Monitoramento em Tempo Real

Desenvolver um sistema de telemetria que permita visualizar:

- Estado atual de todas as conversas
- Mensagens em trânsito
- Erros e exceções
- Tempos de resposta e desempenho

## Próximos Passos Imediatos

Para resolver os problemas atuais sem uma reescrita completa:

1. **Padronizar assinaturas de funções** - Garantir que todas as funções usem parâmetros consistentes em todo o código.

2. **Centralizar validação DOM** - Criar utilitários compartilhados para verificação de elementos DOM.

3. **Melhorar o isolamento de componentes** - Garantir que cada componente (cursor, mensagem, etc.) tenha seu próprio ciclo de vida isolado.

4. **Implementar system de retry** - Adicionar mecanismos de retry para operações que podem falhar devido a timing.

5. **Introduzir um middleware de eventos** - Criar uma camada intermediária para normalizar eventos e garantir propriedades necessárias.

## Conclusão

Os problemas enfrentados destacam a importância de uma abordagem defensiva na programação frontend, especialmente ao lidar com eventos, manipulação DOM e comunicação assíncrona. As soluções implementadas aumentaram a robustez do sistema, mas será necessária uma revisão mais abrangente da arquitetura para resolver completamente os problemas.

O atual sistema está utilizando uma abordagem muito orientada a eventos com manipulação direta do DOM, o que torna o fluxo de dados difícil de rastrear e propenso a erros. Uma arquitetura mais declarativa com fluxo de dados unidirecional ajudaria a resolver muitos dos problemas encontrados.

**Recomendação final**: Considerar uma reescrita gradual dos componentes mais problemáticos, começando pelo sistema de mensagens e cursor, usando uma abordagem mais moderna e declarativa.


----------------------

# Sistema de Chat com Streaming - Linha de Raciocínio Visão Geral

Este documento descreve o estado atual do sistema de chat com streaming de respostas em tempo real, apresentando o que foi implementado e os próximos passos do desenvolvimento.

## Status Atual (Abril 2025)

* Streaming de respostas em tempo real via Socket.IO
* Persistência de conversas
* Integração com processamento de vídeos do YouTube
* Renderização de markdown nas mensagens

## Últimas Implementações (27/04/2025)

* Correções no sistema de Socket.IO
* Implementado fluxo que entra na nova sala imediatamente
* Saída da sala anterior adiada até receber o evento response_complete
* Adicionadas variáveis globais para rastreamento de mensagens ativas
* Aprimoramento do messageRegistry:
	+ Adicionadas flags isCursor, isComplete e isStreaming
	+ Lógica refinada para preservar apenas mensagens relevantes
	+ Sistema de limpeza automatizada que preserva mensagens completas

## Melhorias Visuais

* Implementada animação de "três pontinhos" para feedback durante carregamento – isso aqui precisa ser revisado pois não está funcionando
* Corrigida importação do módulo marked usando CDN

## Próximos Passos Prioritários

### Sistema de IDs Unificado

* Implementar geração consistente de IDs entre backend e frontend
* Garantir que não ocorram duplicações ou conflitos

### Integração com YouTube

* Finalizar integração do sistema de streaming com processamento de YouTube
* Testar casos específicos de resumo e transcrição

### Testes de Integração

* Testar troca de conversas durante streaming ativo
* Verificar comportamento com mensagens longas e formatação complexa
* Validar interação entre YouTube e streaming

## Arquivos Principais

* `static/js/chat/chatActions.js` - Gerenciamento da comunicação via Socket.IO
* `static/js/modules/streamingManager.js` - Controle do ciclo de vida das mensagens
* `static/css/streaming.css` - Animações e estilos para feedback visual
* `app.py` - Backend Flask com handlers de Socket.IO

## Referências de Implementação

Conteúdo de animacao-carregamento.md:
# Substituição do Sistema de Feedback Visual Durante Carregamento

## Problema Original

O sistema antigo de feedback visual durante o carregamento ("três pontinhos") apresentava dois problemas principais:

1. **O cursor antigo ("Gerando resposta...")** continuava aparecendo no DOM mesmo após a implementação da nova animação centralizada
2. **Containers vazios** sendo criados, poluindo a interface e causando problemas visuais
3. **Erro no código**: `TypeError: messageRegistry.forEach is not a function` ocorria periodicamente

## Diagnóstico

Após análise do código e logs, identificamos as seguintes causas:

1. **Múltiplos pontos de criação do cursor antigo**:
   - Em `chatActions.js` na função `carregarConversa`
   - Em `chatSync.js` durante o evento `message_chunk`
   - Em `streamingManager.js` no método `createMessageContainer`

2. **Animação de carregamento centralizada implementada parcialmente**:
   - O elemento HTML havia sido adicionado, mas não todas as integrações necessárias

3. **Erro de tipo no messageRegistry**:
   - O método `cleanupOrphan` em `streamingManager.js` tentava usar `messageRegistry.forEach()`, mas `messageRegistry` é um `Map`

## Soluções Implementadas

### 1. Remoção da Mensagem "Gerando resposta..."

Modificamos todos os locais que criavam o cursor antigo:

- Em `chatActions.js`:
  ```javascript
  // Antes
  if (isStreaming) {
      const streamingMessage = document.createElement('div');
      streamingMessage.className = 'message assistant streaming-message';
      streamingMessage.dataset.conversationId = conversationId;
      streamingMessage.innerHTML = '<div class="message-content">Gerando resposta...</div>';
      chatContainer.appendChild(streamingMessage);
  }
  
  // Depois
  if (isStreaming) {
      const loadingAnimation = document.getElementById('loading-animation');
      if (loadingAnimation) {
          loadingAnimation.style.display = 'block';
          logger.debug('Animação de carregamento exibida ao carregar conversa em streaming');
      }
  }
  ```

- Em `chatSync.js`:
  ```javascript
  // Antes
  let streamingMessage = chatContainer.querySelector(`.message.assistant.streaming-message[data-conversation-id="${data.conversation_id}"]`);
  if (!streamingMessage) {
      streamingMessage = document.createElement('div');
      streamingMessage.className = 'message assistant streaming-message';
      streamingMessage.dataset.conversationId = data.conversation_id;
      streamingMessage.innerHTML = '<div class="message-content">Gerando resposta...</div>';
      chatContainer.appendChild(streamingMessage);
  }
  
  // Depois
  const loadingAnimation = document.getElementById('loading-animation');
  if (loadingAnimation && loadingAnimation.style.display === 'block') {
      loadingAnimation.style.display = 'none';
      console.log('[DEBUG] Animação de carregamento ocultada após receber chunk');
  }
  ```

- Em `streamingManager.js`:
  ```javascript
  // Antes
  messageDiv.innerHTML = `<div class="message-content"><div class="loading-dots"><span>.</span><span>.</span><span>.</span></div></div>`;
  
  // Depois
  messageDiv.innerHTML = `<div class="message-content"></div>`;
  
  // E adicionamos suporte à animação centralizada
  const loadingAnimation = document.getElementById('loading-animation');
  if (loadingAnimation && loadingAnimation.style.display !== 'block') {
      loadingAnimation.style.display = 'block';
      logger.debug('Animação de carregamento exibida ao criar container de mensagem');
  }
  ```

### 2. Integração da Animação Centralizada em Todos os Pontos Críticos

Garantimos o controle da animação em todos os pontos-chave do fluxo:

1. **Ao enviar uma mensagem**:
   ```javascript
   // Mostrar animação de carregamento centralizada
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation) {
       loadingAnimation.style.display = 'block';
       logger.debug('Animação de carregamento exibida');
   }
   ```

2. **Ao receber o primeiro chunk**:
   ```javascript
   // Ocultar a animação de carregamento ao receber o primeiro chunk
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após receber chunk');
   }
   ```

3. **Ao completar a resposta**:
   ```javascript
   // Ocultar a animação de carregamento ao completar a resposta
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após completar resposta');
   }
   ```

4. **Em caso de erro**:
   ```javascript
   // Ocultar a animação de carregamento em caso de erro
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation && loadingAnimation.style.display === 'block') {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após erro no streaming');
   }
   ```

5. **Ao interromper a resposta**:
   ```javascript
   // Ocultar a animação de carregamento
   const loadingAnimation = document.getElementById('loading-animation');
   if (loadingAnimation) {
       loadingAnimation.style.display = 'none';
       logger.debug('Animação de carregamento ocultada após interrupção');
   }
   ```

### 3. Corrigido o Erro no streamingManager.js

Corrigimos o método `cleanupOrphan` para usar a abordagem correta de iteração sobre Maps:

```javascript
// Antes
messageRegistry.forEach((entry, messageId) => {
    // código...
});

// Depois
for (const [messageId, entry] of messageRegistry.entries()) {
    // código...
}
```

### 4. Atualizamos as Seleções de Elementos no DOM

Removemos todas as referências à classe `.streaming-message` em seletores, substituindo:

```javascript
// Antes
const streamingMessages = chatContainer.querySelectorAll('.message.assistant.streaming-message');

// Depois
// Simplesmente removemos ou substituímos por elementos reais
```

## Resultado

Com estas mudanças:

1. O cursor antigo ("Gerando resposta...") foi completamente removido do sistema
2. A animação de carregamento centralizada (com ícone spinner) agora funciona em todos os cenários
3. Não são mais criados containers vazios no fluxo do chat
4. O erro `TypeError: messageRegistry.forEach is not a function` foi corrigido

O sistema agora apresenta um feedback visual consistente e elegante durante o carregamento das respostas da IA, proporcionando uma melhor experiência ao usuário.

## Considerações para o Futuro

1. O código antigo dos "três pontinhos" foi preservado em formato de comentário (marcado como "CÓDIGO PARA REVISÃO FUTURA") para referência
2. A estrutura atual já suporta fácil extensão para animações mais elaboradas, se necessário
3. Todo o sistema foi documentado com logs de debug para facilitar a manutenção futura 

Conteúdo de documentacao-sistema.md:
# Documentação do Sistema de Chat com Streaming

## Visão Geral do Sistema

O sistema implementa um chat interativo com suporte a streaming de mensagens, permitindo visualização em tempo real da resposta da IA. O sistema conta com um mecanismo de feedback visual durante o carregamento e tratamento robusto de mensagens para evitar duplicações.

## Arquitetura Geral

### Componentes Principais

1. **Frontend**:
   - **chat.js**: Gestão de interface e interação de usuário
   - **messageRegistry.js**: Sistema central de rastreamento de mensagens
   - **streamingManager.js**: Gerencia streaming de mensagens
   - **messageRenderer.js**: Renderiza as mensagens no chat
   - **youtubeHandler.js**: Integração com recursos do YouTube

2. **Backend**:
   - **app.py**: Processamento de mensagens e integração com IA
   - **chat_storage.py**: Persistência das conversas

3. **Integrações**:
   - Socket.IO para comunicação bidirecional em tempo real
   - API de IA para geração de respostas (Ollama)
   - Processamento de vídeos do YouTube

## Fluxo de Dados

1. Usuário envia mensagem através da interface
2. Frontend registra a mensagem no messageRegistry com UUID único
3. streamingManager envia para o backend via Socket.IO
4. Backend processa com IA e retorna chunks de resposta via Socket.IO
5. streamingManager recebe os chunks e atualiza o messageRegistry
6. messageRenderer exibe a resposta em tempo real no chat
7. Após completar, a mensagem é armazenada no histórico

## Sistema de Feedback Visual

### Problema Original Resolvido

O sistema antigo de feedback visual durante o carregamento ("três pontinhos") apresentava problemas:
1. O cursor antigo ("Gerando resposta...") persistia no DOM
2. Containers vazios eram criados, poluindo a interface
3. Erro no código: `TypeError: messageRegistry.forEach is not a function`

### Solução Implementada

1. **Eliminação do Cursor Antigo**:
   - Substituição por animação de carregamento centralizada
   - Remoção de todos os pontos de criação do cursor antigo em:
     - `chatActions.js` (função `carregarConversa`)
     - `chatSync.js` (evento `message_chunk`)
     - `streamingManager.js` (método `createMessageContainer`)

2. **Integração da Animação Centralizada**:
   - Elemento HTML único para feedback visual
   - Controle centralizado em pontos-chave:
     - Ao enviar mensagem
     - Ao receber o primeiro chunk
     - Ao completar a resposta
     - Em caso de erro
     - Ao interromper a resposta

3. **Correção de Bugs**:
   - Corrigido método `cleanupOrphan` para usar iteração correta sobre Maps
   - Removidas referências à classe `.streaming-message` em seletores

### Código de Implementação

**HTML da Animação (index.html)**:
```html
<!-- Animação de carregamento centralizada -->
<div id="loading-animation" style="display: none;">
    <div class="loading-spinner">
        <i class="fas fa-spinner fa-spin"></i>
        <span>Processando...</span>
    </div>
</div>
```

**Estilos CSS (streaming.css)**:
```css
#loading-animation {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    background: rgba(0, 0, 0, 0.7);
    padding: 15px 25px;
    border-radius: 8px;
    color: #fff;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.loading-spinner {
    display: flex;
    align-items: center;
    gap: 10px;
}

.loading-spinner i {
    font-size: 1.5rem;
}

.loading-spinner span {
    font-family: 'Inter', sans-serif;
    font-size: 1rem;
}
```

**Manipulação em JavaScript**:
```javascript
// Mostrar animação
const loadingAnimation = document.getElementById('loading-animation');
if (loadingAnimation) {
    loadingAnimation.style.display = 'block';
    logger.debug('Animação de carregamento exibida');
}

// Ocultar animação
if (loadingAnimation && loadingAnimation.style.display === 'block') {
    loadingAnimation.style.display = 'none';
    logger.debug('Animação de carregamento ocultada');
}
```

## Sistema de Streaming de Mensagens

### Implementação do Streaming

O sistema de streaming permite visualização em tempo real das respostas, com as seguintes características:

1. **Containers Unificados**:
   - Um único container por mensagem
   - Identificação via UUID para evitar duplicação
   - Atualização via chunks em tempo real

2. **Renderização Incremental**:
   - Markdown processado em tempo real
   - Exibição de cursor durante digitação
   - Transição suave entre estados

3. **Gerenciamento de Estado**:
   - Controle centralizado via messageRegistry
   - Limpeza automática de containers órfãos
   - Mecanismo de recuperação pós-erro

### Streaming Manager

O StreamingManager é o componente central que:
1. Gerencia os listeners de Socket.IO
2. Processa chunks de mensagem
3. Atualiza o messageRegistry
4. Coordena renderização via messageRenderer
5. Gerencia o ciclo de vida das mensagens

## Resolução de Problemas Comuns

### Duplicação de Mensagens

**Solução**:
- Uso de UUIDs consistentes durante todo o ciclo da mensagem
- Verificação no messageRegistry antes de criar novos containers
- Limpeza automática de containers órfãos

### Containers Vazios

**Solução**:
- Criação de containers apenas quando há conteúdo real
- Sistema de cleanup periódico via `cleanupOrphan()`
- Melhor gerenciamento de ciclo de vida dos containers

### Conflitos de Renderização

**Solução**:
- Centralização da lógica de renderização
- Sistema de fila para processamento de chunks
- Uso de debounce para evitar atualizações excessivas

## Considerações para o Futuro

1. O código antigo dos "três pontinhos" foi preservado em formato de comentário para referência
2. A estrutura atual suporta extensão para animações mais elaboradas
3. O sistema está documentado com logs para facilitar a manutenção

## Diagrama do Sistema

```mermaid
graph TD
    A[Usuário] -->|Envia mensagem| B[Front-end: chat.js]
    B -->|Registra com UUID| C[messageRegistry.js]
    C -->|Gerencia streaming| D[streamingManager.js]
    D -->|Envia via Socket.IO| E[Back-end: app.py]
    E -->|Processa com IA| F[API Ollama]
    F -->|Resposta em streaming| E
    E -->|Envia chunks via Socket.IO| D
    D -->|Atualiza mensagens| C
    C -->|Renderiza chunks| G[messageRenderer.js]
    G -->|Atualiza DOM| H[chatContainer]
    I[Animação de Carregamento] -.->|Feedback visual| H
``` 

Conteúdo de implementacao-streaming-continuo-resumo.md:
# Implementação de Streaming Contínuo Durante Troca de Chat

Este documento resume as alterações implementadas para garantir que o streaming de respostas não seja interrompido ao trocar de conversas, mantendo o usuário imerso no diálogo até o último chunk chegar.

## Alterações Implementadas

### Backend (app.py)

1. **Evento `leave_conversation_safe`**:
   - Adicionado novo evento que é emitido pelo backend após a finalização do streaming (após `response_complete`)
   - Também é emitido em casos de erro para permitir que o cliente saia da sala com segurança
   - Permite ao frontend saber exatamente quando é seguro sair de uma sala de conversa

### Frontend (main.js)

1. **Comportamento de Troca de Salas**:
   - O frontend não sai mais automaticamente da sala anterior ao mudar de conversa
   - Apenas entra na nova sala e aguarda o evento `leave_conversation_safe` para sair da sala anterior
   - Isso garante que nenhum fragmento de resposta seja perdido durante a troca de chat

### Front-end (streamingManager.js)

1. **Flag `isStreaming`**:
   - Adicionado flag `isStreaming` ao messageRegistry para rastrear mensagens em andamento
   - Definido como `true` ao iniciar o streaming
   - Atualizado para `false` quando o streaming é concluído
   - Permite verificar o estado do streaming de cada mensagem

2. **Renderização Condicional**:
   - Adicionada verificação de `conversation_id` antes de renderizar os chunks
   - Mensagens são sempre processadas e armazenadas, independente da conversa ativa
   - Renderização ocorre apenas se o chunk pertence à conversa atual
   - Isso evita renderização cruzada entre conversas

### Frontend (messageRegistry.js)

1. **Limpeza de Containers Órfãos**:
   - Modificado para nunca remover containers que estão com `isStreaming: true`
   - Verifica o estado de streaming antes de remover qualquer container
   - Isso evita remoção prematura de containers ainda em streaming

### Frontend (chatActions.js)

1. **Funções `entrarNaSala` e `sairDaSala`**:
   - Modificada a função `sairDaSala` para verificar se há streaming ativo para a conversa
   - Não sai da sala se ainda houver streaming ativo
   - Adicionado listener para `leave_conversation_safe` para sair da sala apenas quando seguro

## Como Testar

Para testar a funcionalidade de streaming contínuo:

1. Inicie uma conversa e envie uma pergunta que provavelmente gerará uma resposta longa
2. Enquanto a resposta estiver sendo gerada (streaming ativo), clique em outra conversa ou crie uma nova
3. Verifique no console do navegador (logs) que:
   - O cliente entra na nova sala (`Entrando na sala: [ID]`)
   - Mantém-se conectado à sala anterior durante o streaming
   - Os chunks continuam sendo recebidos e processados
   - Ao concluir a resposta, o backend emite `leave_conversation_safe`
   - O cliente sai da sala anterior apenas após o streaming concluir

4. Confirme que:
   - O conteúdo completo da resposta é mantido na conversa original
   - Não há vazamento de conteúdo entre conversas
   - Não há duplicação de mensagens

## Extras

Esta implementação completa a fase 1 do projeto, garantindo:

1. Isolamento completo por `conversation_id`
2. Streaming ininterrupto durante a troca de chat
3. Prevenção de exclusão prematura de containers em streaming
4. Saída segura de salas após conclusão do streaming

Próximos passos incluem aplicar o mesmo comportamento ao processamento de vídeos do YouTube e iniciar a modularização do código para melhor manutenção. 

Conteúdo de plano-implementacao.md:
# Plano de Implementação - Sistema de Chat com Feedback Visual

## Visão Geral
Este documento apresenta o plano de implementação para resolver os problemas de duplicação de mensagens, melhorar o feedback visual durante o carregamento e aprimorar a arquitetura do sistema de chat.

## Fases de Implementação

### Fase 1: Preparação e Limpeza Inicial (3 Horas)

1. **Revisão do Fluxo Atual (1 Hora)**
   - Mapear os componentes: `streamingManager.js`, `messageRenderer.js`, `chatActions.js` e `messageRegistry`
   - Identificar pontos de geração de IDs e comunicação entre canais
   - Resultado: Diagrama de fluxo do estado atual do sistema

2. **Escolha do Canal Único (1 Hora)**
   - Padronizar usando Socket.IO como meio exclusivo de comunicação
   - Remover código relacionado a SSE (Server-Sent Events) do backend
   - Resultado: Backend mais enxuto e menor chance de duplicação de mensagens

3. **Centralização do messageRegistry (1 Hora)**
   - Criar módulo único para o `messageRegistry`
   - Garantir importação consistente em todos os arquivos
   - Resultado: Sistema de registro de mensagens consistente e confiável

### Fase 2: Implementação da Padronização de IDs (4 Horas)

4. **Geração de UUID no Backend (1 Hora)**
   - Modificar `app.py` para gerar UUID único por mensagem
   - Enviar UUID via Socket.IO com cada mensagem
   - Resultado: IDs consistentes em todo o ciclo da mensagem

5. **Ajuste no Frontend (1 Hora)**
   - Adaptar `streamingManager.js` para usar UUIDs do backend
   - Atualizar `messageRenderer.js` para renderização baseada em UUID
   - Resultado: Frontend alinhado com backend, evitando duplicações

6. **Integração com messageRegistry (1 Hora)**
   - Implementar UUID como chave primária no registry
   - Adicionar verificação de duplicação
   - Resultado: Controle centralizado de mensagens

7. **Testes Básicos (1 Hora)**
   - Testar fluxo de mensagens com UUIDs
   - Verificar se duplicações foram eliminadas
   - Resultado: Confirmação da solução básica funcionando

### Fase 3: Refatoração e Consolidação (4 Horas)

8. **Remoção Completa do SSE (1 Hora)**
   - Eliminar endpoint `/stream` e código relacionado
   - Consolidar toda comunicação via Socket.IO
   - Resultado: Canal único de comunicação

9. **Centralização do Streaming (1 Hora)**
   - Tornar `streamingManager.js` o controlador central de eventos
   - Simplificar relacionamento com `messageRenderer.js`
   - Resultado: Fluxo de streaming mais limpo e organizado

10. **Logs e Verificação (1 Hora)**
    - Implementar sistema de log para ciclo de vida das mensagens
    - Monitorar comportamento do UUID em todo o fluxo
    - Resultado: Verificação em tempo real do funcionamento

11. **Testes de Integração (1 Hora)**
    - Testar cenários complexos: mensagens normais, YouTube, streaming pesado
    - Validar comportamento do sistema sob carga
    - Resultado: Sistema estável em condições reais

### Fase 4: Documentação e Finalização (2 Horas)

12. **Atualização da Documentação (1 Hora)**
    - Documentar nova arquitetura e fluxo de mensagens
    - Criar diagramas atualizados do sistema
    - Resultado: Documentação clara para futura manutenção

13. **Revisão Final (1 Hora)**
    - Revisar implementação completa
    - Testar sistema end-to-end
    - Resultado: Sistema finalizado e estável

## Total: 13 Horas de Implementação

## Diagrama de Fluxo Final

```mermaid
graph TD
    A[Usuário] -->|Envia mensagem| B[Front-end: chat.js]
    B -->|Gera UUID para mensagem| C[messageRegistry.js]
    C -->|Registra mensagem| D[streamingManager.js]
    D -->|Envia via Socket.IO| E[Back-end: app.py]
    E -->|Processa com IA| F[API Ollama]
    F -->|Resposta em streaming| E
    E -->|Envia chunks via Socket.IO| D
    D -->|Atualiza mensagem| C
    C -->|Renderiza mensagem| G[messageRenderer.js]
    G -->|Exibe no chat| H[chatContainer]
    I[YouTube Handler] -->|Processa vídeo, se aplicável| E
    E -->|Salva no histórico| J[chat_storage.py]
    J -->|Persiste em JSON| K[Arquivo de conversa]
```

## Principais Arquivos e Funções

### Frontend
- **chat.js**: Captura mensagens e gerencia interação inicial
- **messageRegistry.js**: Centraliza rastreamento via UUID
- **streamingManager.js**: Gerencia comunicação em tempo real
- **messageRenderer.js**: Renderiza mensagens no chat
- **youtubeHandler.js**: Processa conteúdo do YouTube

### Backend
- **app.py**: Processamento central e integração com IA
- **chat_storage.py**: Persistência do histórico de conversas 

Conteúdo de README.md:

# Documentação do Projeto - Sistema de Chat com IA

## 1. Visão Geral do Projeto

### Descrição Geral
O projeto é um sistema de chat interativo que utiliza inteligência artificial para gerar respostas contextualizadas. É baseado em uma arquitetura cliente-servidor usando Flask como backend e uma interface web responsiva.

### Objetivo e Funcionalidades Principais
- Fornecer uma interface de chat intuitiva para interação com IA
- Gerenciar histórico de conversas
- Permitir criação de novas conversas
- Suportar temas claro/escuro
- Salvar conversas em arquivos JSON para persistência

### Tecnologias Utilizadas
- **Backend**: Python/Flask
- **Frontend**: HTML, CSS, JavaScript
- **Armazenamento**: Sistema de arquivos (JSON)
- **IA**: Integração com modelo de linguagem

## 2. Árvore de Diretórios

```
Projeto/
├── app.py                     # Aplicação principal Flask
├── static/
│   ├── css/                  # Estilos da aplicação
│   │   ├── styles.css       # Estilos principais
│   │   ├── base/           # Estilos base
│   │   ├── components/     # Estilos de componentes
│   │   ├── layout/        # Estilos de layout
│   │   └── themes/        # Temas claro/escuro
│   │
│   └── js/                   # Scripts JavaScript
│       ├── main.js          # Script principal
│       ├── chat.js         # Lógica do chat
│       ├── sidebar.js      # Controle da barra lateral
│       ├── theme.js        # Controle de tema
│       ├── events.js       # Gerenciamento de eventos
│       ├── init.js         # Inicialização
│       └── utils.js        # Funções utilitárias
│
├── templates/
│   └── index.html            # Template principal
│
├── utils/
│   ├── chat_storage.py      # Gerenciamento de armazenamento
│   ├── chat_history.py      # Manipulação do histórico
│   └── text_processor.py    # Processamento de texto
│
└── data/                     # Diretório de dados
    └── conversations/        # Armazenamento de conversas

```

## 3. Descrição Detalhada das Funções

### Backend (app.py)

#### Rotas Principais:
- `@app.route('/')`: Renderiza a página inicial
- `@app.route('/send_message')`: Processa mensagens e retorna respostas da IA
- `@app.route('/get_conversation_history')`: Retorna histórico de conversas
- `@app.route('/get_conversation/<conversation_id>')`: Obtém conversa específica

#### Funções de Processamento:
- `process_with_ai(text)`: Processa texto com IA
- `process_with_ai_stream(text)`: Versão streaming do processamento

### Utilitários (utils/)

#### chat_storage.py:
- `ensure_directories()`: Garante existência dos diretórios necessários
- `create_new_conversation()`: Cria nova conversa
- `save_conversation()`: Salva conversa em arquivo
- `get_conversation_by_id()`: Recupera conversa por ID

#### chat_history.py:
- `get_conversation_history()`: Obtém histórico completo
- `save_conversation()`: Salva conversa no histórico
- `get_conversation_by_id()`: Busca conversa específica

### Frontend (static/js/)

#### main.js:
- Inicialização da aplicação
- Gerenciamento de estado global
- Configuração de event listeners

#### chat.js:
- `iniciarChat()`: Inicia nova sessão de chat
- `enviarMensagem()`: Envia mensagem para o backend
- `adicionarMensagem()`: Adiciona mensagem na interface
- `carregarConversa()`: Carrega conversa existente

## 4. Fluxo de Execução

1. **Inicialização**:
   - Servidor Flask inicia (app.py)
   - Diretórios são verificados/criados
   - Interface web é carregada

2. **Interação do Usuário**:
   - Usuário inicia nova conversa ou carrega existente
   - Mensagens são enviadas via interface
   - Backend processa com IA
   - Respostas são exibidas em tempo real

3. **Armazenamento**:
   - Conversas são salvas automaticamente
   - Histórico é mantido em arquivos JSON
   - Dados persistem entre sessões

## 5. Estrutura do Código

O projeto segue uma arquitetura MVC simplificada:
- **Modelo**: Gerenciamento de dados em JSON
- **Visão**: Templates HTML e estilos CSS
- **Controlador**: Rotas Flask e lógica JavaScript

### Boas Práticas:
- Separação de responsabilidades
- Modularização do código
- Armazenamento persistente
- Tratamento de erros

## 6. Instruções de Instalação

1. **Preparação do Ambiente**:
```bash
# Criar ambiente virtual
python -m venv venv

# Ativar ambiente
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Instalar dependências
pip install -r requirements.txt
```

2. **Configuração**:
- Garantir que Python 3.6+ está instalado
- Verificar permissões de escrita no diretório data/

3. **Execução**:
```bash
python app.py
```
- Acessar http://localhost:5000 no navegador

## 7. Evolução do Projeto e Linha de Raciocínio

### Problema Inicial: Duplicação de Mensagens no Streaming
Nosso principal desafio foi a duplicação de mensagens no DOM durante o streaming de respostas da IA. Após análise detalhada, identificamos duas causas principais:

1. **Sistemas Concorrentes de Renderização:**
   - Streaming em tempo real via `message_chunk`
   - Renderização final completa via `response_complete`
   - Estes sistemas criavam containers independentes para a mesma mensagem

2. **Inconsistência de IDs:**
   - O `messageId` gerado no streaming não era reutilizado na renderização final
   - Após reiniciar o servidor, os containers antigos permaneciam órfãos no DOM

### Evolução da Solução

#### Fase 1: Diagnóstico e Primeira Abordagem
Inicialmente, tentamos resolver o problema implementando um sistema de cache simples:
```javascript
const messageCache = new Map();

export const renderMessageChunk = (messageId, chunk) => {
    // Busca container existente ou cria novo
    // Acumula chunks no cache
    // Renderiza conteúdo acumulado
};
```

Esta abordagem funcionava em sessões contínuas, mas falhava após reinícios do servidor, pois o estado do cache era perdido.

#### Fase 2: Gerenciamento de Estado Global
Evoluímos para um sistema mais robusto com estas características:
1. **Registro Global de Mensagens:** Um Map central para controlar todas as mensagens ativas
2. **Identificadores Únicos:** Uso consistente do mesmo `messageId` em todo o ciclo da mensagem
3. **Limpeza Automática:** Sistema para detectar e remover containers órfãos
4. **Monitoramento:** Logs detalhados do ciclo de vida das mensagens

#### Fase 3: Arquitetura Unificada
Nossa solução atual visa uma abordagem completamente unificada:
1. **Fluxo Único:** Um único sistema de renderização do início ao fim da mensagem
2. **Estado Compartilhado:** `messageRegistry` compartilhado entre módulos
3. **Limpeza Preventiva:** Remoção automática de containers vazios a cada 5 segundos
4. **Resistência a Reinícios:** Mecanismos para lidar com estado entre reinicializações

### Lições Aprendidas

1. **Importância da Consistência de IDs:**
   - O mesmo identificador deve ser usado em todo o ciclo de vida da mensagem
   - A geração de IDs deve ser determinística ou persistente entre reinícios

2. **Desafios do Streaming em Tempo Real:**
   - Eventos assíncronos podem chegar fora de ordem ou duplicados
   - É necessário um mecanismo robusto para detectar e ignorar duplicações

3. **Gerenciamento de Estado:**
   - Estado global deve ser compartilhado entre módulos relevantes
   - Mecanismos de limpeza automática são essenciais para evitar vazamentos de memória

4. **Importância da Depuração:**
   - Logs detalhados são cruciais para identificar problemas sutis
   - Um sistema centralizado de logs facilita o diagnóstico

### Próximos Passos

1. **Resolução de Problemas Pendentes:**
   - Corrigir o erro de referência: `messageRegistry is not defined`
   - Implementar um sistema de log centralizado e mais detalhado
   - Garantir limpeza consistente de estado entre reinicializações

2. **Melhorias Planejadas:**
   - Refatorar o código para uma arquitetura mais modular
   - Implementar testes automatizados para validar comportamento
   - Melhorar a experiência do usuário com feedback visual durante o streaming
   - Implementar mecanismos de recuperação de falhas

3. **Documentação e Manutenção:**
   - Atualizar a documentação com decisões de design e lições aprendidas
   - Implementar um sistema de versionamento mais rigoroso
   - Melhorar a colaboração entre diferentes inteligências artificiais e desenvolvedores humanos

## 8. Considerações Finais

### Melhorias Sugeridas:
1. Implementar autenticação de usuários
2. Adicionar suporte a múltiplos modelos de IA
3. Melhorar sistema de backup de conversas
4. Implementar busca no histórico
5. Adicionar suporte a markdown nas mensagens

### Funcionalidades Futuras:
1. Exportação de conversas em diferentes formatos
2. Compartilhamento de conversas
3. Personalização avançada da interface
4. Integração com APIs externas
5. Sistema de tags para organização

Conteúdo de resolucao-problemas-limpeza-mensagens.md:
# Resolução de Problemas: Limpeza Indevida de Mensagens

## Problema Identificado

Após a implementação do sistema de streaming contínuo durante a troca de chat, identificamos um problema crítico: o sistema estava removendo indevidamente containers de mensagens completas da IA durante a limpeza de containers órfãos. Isso acontecia porque:

1. A lógica de `cleanOrphanContainers` no `messageRegistry.js` não distinguia adequadamente entre diferentes tipos de containers
2. Containers válidos com respostas completas da IA eram removidos durante operações de limpeza
3. Ocorriam erros durante o processamento de `marked()` com conteúdo potencialmente indefinido

## Solução Implementada

### 1. Flags Adicionais no MessageRegistry

Introduzimos duas novas flags para gerenciar o ciclo de vida dos containers:

- `isCursor`: Marca containers temporários usados apenas para animação
- `isComplete`: Flag explícita que indica se uma mensagem foi finalizada com sucesso

Estas flags são mais robustas que a anterior `isStreaming`, permitindo distinguir entre:
- Containers de cursor temporário
- Mensagens em processo de streaming
- Mensagens completas que nunca devem ser removidas

### 2. Nova Lógica de Limpeza

A função `cleanOrphanContainers` foi completamente reescrita seguindo as seguintes regras:

1. NUNCA remover containers com `isComplete=true`
2. Remover cursores inativos (`isCursor=true` e `isStreaming=false`)
3. Remover containers vazios não completos e não em streaming
4. Para containers não registrados, verificar classes para determinar se são temporários

### 3. Sistema de Cursor Independente

Criamos um sistema de cursor completamente separado do `messageRegistry`:

- Novo módulo `cursorManager.js` para gerenciar cursores de digitação
- Cursor removido automaticamente quando o primeiro chunk real é recebido
- CSS animado em arquivo separado `cursor.css`
- Evita conflitos com o sistema de mensagens real

### 4. Tratamento de Erros

Adicionamos tratamento robusto de erros e fallbacks:

- Verificação explícita de `content` vazio antes de renderizar Markdown
- Garantia que `isComplete=true` é definido mesmo em caso de erro de renderização
- Registro de logs para facilitar depuração em caso de problemas futuros

## Benefícios da Implementação

1. **Preservação de Mensagens**: Respostas da IA nunca são removidas indevidamente
2. **Clareza Visual**: Cursores temporários são claramente separados do conteúdo real
3. **Robustez**: Tratamento adequado de erros e estados inconsistentes
4. **Melhor UX**: Feedback visual imediato quando o usuário envia uma mensagem
5. **Base para Evolução**: Estrutura modular que permite refinar a animação de digitação na fase 3

## Teste e Validação

Para testar estas mudanças:

1. Inicie uma conversação e envie uma mensagem
2. Observe o cursor de "três pontinhos" enquanto aguarda resposta
3. Quando o primeiro chunk chegar, verifique se o cursor desaparece e a resposta começa a ser renderizada
4. Troque de conversa durante o streaming e depois volte
5. Verifique se a resposta completa permanece visível e não é removida

## Próximos Passos

1. Refinar a animação do cursor na fase 3
2. Aplicar a mesma separação de responsabilidades no processamento do YouTube
3. Continuar a modularização do código em arquivos mais específicos
4. Melhorar as transições visuais entre cursor e conteúdo real 


==========================================
Estrutura de pastas:
==========================================
linha_de_raciocinio
    1- documentação.md
    2- DFD com foco no youtube.md
    3-implementacao-streaming-mensagens.md
    4-resolucao-problemas-duplicacao-mensagens.md
    5-problemas-interacao-eventos.md
    animacao-carregamento.md
    documentacao-sistema.md
    implementacao-streaming-continuo-resumo.md
    plano-implementacao.md
    README.md
    resolucao-problemas-limpeza-mensagens.md


==========================================
Conteúdo de implementacao-streaming-continuo-resumo.md (caminho: linha_de_raciocinio\implementacao-streaming-continuo-resumo.md):
==========================================
# Implementação de Streaming Contínuo Durante Troca de Chat

Este documento resume as alterações implementadas para garantir que o streaming de respostas não seja interrompido ao trocar de conversas, mantendo o usuário imerso no diálogo até o último chunk chegar.

## Alterações Implementadas

### Backend (app.py)

1. **Evento `leave_conversation_safe`**:
   - Adicionado novo evento que é emitido pelo backend após a finalização do streaming (após `response_complete`)
   - Também é emitido em casos de erro para permitir que o cliente saia da sala com segurança
   - Permite ao frontend saber exatamente quando é seguro sair de uma sala de conversa

### Frontend (main.js)

1. **Comportamento de Troca de Salas**:
   - O frontend não sai mais automaticamente da sala anterior ao mudar de conversa
   - Apenas entra na nova sala e aguarda o evento `leave_conversation_safe` para sair da sala anterior
   - Isso garante que nenhum fragmento de resposta seja perdido durante a troca de chat

### Front-end (streamingManager.js)

1. **Flag `isStreaming`**:
   - Adicionado flag `isStreaming` ao messageRegistry para rastrear mensagens em andamento
   - Definido como `true` ao iniciar o streaming
   - Atualizado para `false` quando o streaming é concluído
   - Permite verificar o estado do streaming de cada mensagem

2. **Renderização Condicional**:
   - Adicionada verificação de `conversation_id` antes de renderizar os chunks
   - Mensagens são sempre processadas e armazenadas, independente da conversa ativa
   - Renderização ocorre apenas se o chunk pertence à conversa atual
   - Isso evita renderização cruzada entre conversas

### Frontend (messageRegistry.js)

1. **Limpeza de Containers Órfãos**:
   - Modificado para nunca remover containers que estão com `isStreaming: true`
   - Verifica o estado de streaming antes de remover qualquer container
   - Isso evita remoção prematura de containers ainda em streaming

### Frontend (chatActions.js)

1. **Funções `entrarNaSala` e `sairDaSala`**:
   - Modificada a função `sairDaSala` para verificar se há streaming ativo para a conversa
   - Não sai da sala se ainda houver streaming ativo
   - Adicionado listener para `leave_conversation_safe` para sair da sala apenas quando seguro

## Como Testar

Para testar a funcionalidade de streaming contínuo:

1. Inicie uma conversa e envie uma pergunta que provavelmente gerará uma resposta longa
2. Enquanto a resposta estiver sendo gerada (streaming ativo), clique em outra conversa ou crie uma nova
3. Verifique no console do navegador (logs) que:
   - O cliente entra na nova sala (`Entrando na sala: [ID]`)
   - Mantém-se conectado à sala anterior durante o streaming
   - Os chunks continuam sendo recebidos e processados
   - Ao concluir a resposta, o backend emite `leave_conversation_safe`
   - O cliente sai da sala anterior apenas após o streaming concluir

4. Confirme que:
   - O conteúdo completo da resposta é mantido na conversa original
   - Não há vazamento de conteúdo entre conversas
   - Não há duplicação de mensagens

## Extras

Esta implementação completa a fase 1 do projeto, garantindo:

1. Isolamento completo por `conversation_id`
2. Streaming ininterrupto durante a troca de chat
3. Prevenção de exclusão prematura de containers em streaming
4. Saída segura de salas após conclusão do streaming

Próximos passos incluem aplicar o mesmo comportamento ao processamento de vídeos do YouTube e iniciar a modularização do código para melhor manutenção. 

==========================================
Conteúdo de leia-me.md (caminho: linha_de_raciocinio\leia-me.md):
==========================================
Antes de implementarmos qualquer melhoria no sistema de chat, é essencial que primeiro adicionemos logs detalhados em todas as partes do sistema, tanto no frontend (JavaScript) quanto no backend (Python). Peço que você implemente esses logs em todos os arquivos e funções relevantes, incluindo, mas não se limitando a, `chatActions.js`, `streamingManager.js`, `messageRenderer.js`, `youtubeHandler.js`, `app.py`, e `chat_storage.py`. Os logs devem registrar o início e o fim de cada função, os eventos principais (como envio de mensagens, recebimento de chunks, e conclusão de respostas), e informações críticas como `conversationId` e `messageId`. Use níveis apropriados, como `logger.info` para eventos principais, `logger.debug` para detalhes, e `logger.warn` para problemas potenciais. 

O objetivo é mapear o fluxo completo do sistema, identificar quais funções estão sendo chamadas, em quais arquivos elas estão localizadas, e detectar duplicações ou código não utilizado. Isso nos permitirá descartar partes desnecessárias, limpar o sistema e evitar problemas futuros, como duplicação de mensagens ou renderização incorreta. Após essa análise, poderemos prosseguir com as melhorias necessárias, como corrigir a renderização tardia do comando `/youtube`, a ausência da mensagem do usuário, a duplicação no `/youtube_resumo`, e a ordem incorreta das mensagens.

Por favor, use a árvore de diretórios e funções fornecida, junto com o código do sistema, como referência para garantir que os logs cubram todas as áreas relevantes. Certifique-se de que os logs sejam claros, estruturados e fáceis de analisar, para que possamos planejar a refatoração com base nos resultados.

Mas atenção! eu já tenho um sistema de log implantado vamos apenas melhorar e ele com essas melhorias que Eu mencionei anteriormente nesse texto

Antes de implementar qualquer código de melhoria quero apenas colocar esses log no sistema para nós rastrearmos e vermos Quais são os códigos que estamos utilizando e quais são os códigos que estão duplicados indevidamente para que possa facilitar a nossa melhoria nas próximas implementações

Para podermos continuar a fase 2 e tentarmos resolver o que está acontecendo 

—-------------

Essa é a representação exata do seu código, no estilo de code snippet tree structure. Ela mostra tudo como está, com todos os arquivos, funções locais e exportações, sem nenhuma mudança ou reorganização. Agora você pode usar isso para comparar com o seu projeto, verificar as duplicações (como chatUI.js na raiz e em chat/, ou messageRegistry.js na raiz e em modules/), e planejar suas correções.
Se precisar de ajuda para analisar algum arquivo específico ou começar a corrigir os problemas, é só me dizer! Estou aqui para te apoiar.
📁 js/
├── 📄 chat.js
│   ├── 📤 iniciarChat
│   ├── 📤 mostrarTelaInicial
│   ├── 📤 adicionarMensagem
│   ├── 📤 enviarMensagem
│   ├── 📤 interromperResposta
│   ├── 📤 carregarConversa
│   ├── 📤 atualizarListaConversas
│   ├── 📤 criarNovaConversa
│   ├── 📤 adicionarMensagemAoHistorico
│   ├── 📤 renomearConversa
│   ├── 📤 excluirConversa
│   ├── 📤 melhorarBlocosCodigo
│   ├── 📤 atualizarBotoes
│   ├── 📤 inicializarSync
│   ├── 📤 entrarNaSalaDeConversa
├── 📄 chatUI.js
│   ├── 🔧 adicionarMensagem()
│   ├── 🔧 atualizarMensagemStreaming()
│   ├── 🔧 constructor()
│   ├── 🔧 handleMessageChunk()
│   ├── 🔧 iniciarChat()
│   ├── 🔧 mostrarCarregamento()
│   ├── 🔧 mostrarTelaInicial()
├── 📄 commandMenu.js
│   ├── 🔧 initCommandMenu()
│   ├── 🔧 updateMenuPosition()
│   ├── 🔧 updateSelectedItem()
├── 📄 events.js
│   ├── 🔧 configureEventListeners()
├── 📄 init.js
│   ├── 📤 socket
├── 📄 main.js
│   ├── 🔧 hideLoading()
│   ├── 🔧 showError()
│   ├── 🔧 showLoading()
│   ├── 🔧 showSuccess()
│   ├── 📤 socket
├── 📄 messageRegistry.js
│   ├── 🔧 constructor()
│   ├── 📤 messageRegistry
├── 📄 messageRenderer.js
│   ├── 🔧 accumulateChunk()
│   ├── 🔧 cleanupOrphan()
│   ├── 🔧 clearAccumulatedResponse()
│   ├── 🔧 completeMessage()
│   ├── 🔧 createContainer()
│   ├── 🔧 getAccumulatedState()
│   ├── 🔧 processCodeChunk()
│   ├── 🔧 renderCompleteResponse()
│   ├── 🔧 renderContent()
│   ├── 🔧 renderMarkdown()
│   ├── 🔧 renderMessageChunk()
│   ├── 🔧 renderMessageContainer()
│   ├── 🔧 scrollToBottomIfNear()
│   ├── 🔧 setCurrentConversation()
│   ├── 📤 messageRegistry
├── 📄 sidebar.js
│   ├── 🔧 initSidebar()
│   ├── 🔧 toggleSidebar()
├── 📄 textarea.js
│   ├── 🔧 configureTextarea()
├── 📄 theme.js
│   ├── 🔧 applyTheme()
│   ├── 🔧 initializeTheme()
│   ├── 🔧 toggleTheme()
├── 📄 utils.js
│   ├── 🔧 escapeHTML()
│   ├── 🔧 mostrarCarregamento()
├── 📁 chat/
│   ├── 📄 chatActions.js
│   │   ├── 🔧 atualizarBotoes()
│   │   ├── 🔧 carregarConversa()
│   │   ├── 🔧 constructor()
│   │   ├── 🔧 entrarNaSala()
│   │   ├── 🔧 enviarMensagem()
│   │   ├── 🔧 forcarRenderizacao()
│   │   ├── 🔧 handleStreamChunk()
│   │   ├── 🔧 handleStreamingScroll()
│   │   ├── 🔧 inicializarConversa()
│   │   ├── 🔧 interromperResposta()
│   │   ├── 🔧 isDuplicateMessage()
│   │   ├── 🔧 isUserAtBottom()
│   │   ├── 🔧 sairDaSala()
│   │   ├── 🔧 scrollListener()
│   │   ├── 🔧 scrollToBottom()
│   ├── 📄 chatStorage.js
│   │   ├── 🔧 adicionarMensagemAoHistorico()
│   │   ├── 🔧 atualizarListaConversas()
│   │   ├── 🔧 carregarConversa()
│   │   ├── 🔧 carregarMensagensEmLotes()
│   │   ├── 🔧 configureScrollListener()
│   │   ├── 🔧 criarNovaConversa()
│   │   ├── 🔧 excluirConversa()
│   │   ├── 🔧 renomearConversa()
│   ├── 📄 chatSync.js
│   │   ├── 🔧 atualizarBufferDaConversa()
│   │   ├── 🔧 entrarNaSalaDeConversa()
│   │   ├── 🔧 gerarSessionId()
│   │   ├── 🔧 inicializarSync()
│   │   ├── 🔧 marcarParaRecarregar()
│   │   ├── 🔧 setupConnectionListeners()
│   │   ├── 🔧 setupEventListeners()
│   │   ├── 🔧 testSocketConnection()
│   │   ├── 🔧 verificarRecarregamento()
│   ├── 📄 chatUI.js
│   │   ├── 🔧 adicionarMensagem()
│   │   ├── 🔧 adicionarMensagemStreaming()
│   │   ├── 🔧 atualizarMensagemStreaming()
│   │   ├── 🔧 iniciarChat()
│   │   ├── 🔧 mostrarCarregamento()
│   │   ├── 🔧 mostrarTelaInicial()
│   │   ├── 🔧 scrollToBottom()
│   │   ├── 🔧 updateStreamingMessage()
│   │   ├── 🔧 updateStreamingScroll()
│   ├── 📄 chatUtils.js
│   │   ├── 🔧 copiarCodigo()
│   │   ├── 🔧 copiarMensagem()
│   │   ├── 🔧 escapeHTML()
│   │   ├── 🔧 melhorarBlocosCodigo()
│   │   ├── 🔧 regenerarResposta()
├── 📁 modules/
│   ├── 📄 commandHandler.js
│   │   ├── 🔧 constructor()
│   ├── 📄 inputBar.js
│   │   ├── 🔧 boundSubmitHandler()
│   │   ├── 🔧 destroyInputBar()
│   │   ├── 🔧 handleSubmit()
│   │   ├── 🔧 initializeInputBar()
│   ├── 📄 messageRegistry.js
│   │   ├── 🔧 constructor()
│   │   ├── 📤 messageRegistry
│   ├── 📄 streamingManager.js
│   │   ├── 🔧 constructor()
├── 📁 utils/
│   ├── 📄 logger.js
│   │   ├── 🔧 log()
│   │   ├── 📤 logger
├── 📁 youtube-system/
│   ├── 📄 youtubeEvents.js
│   │   ├── 🔧 handleYoutubeCommand()
│   │   ├── 🔧 setupYoutubeEvents()
│   ├── 📄 youtubeHandler.js
│   │   ├── 🔧 displaySubtitles()
│   │   ├── 🔧 formatSubtitles()
│   │   ├── 🔧 handleYoutubeCommand()
│   │   ├── 🔧 processSubtitles()
│   │   ├── 🔧 setupYoutubeSocketListeners()
│   ├── 📄 youtubeResumoHandler.js
│   │   ├── 🔧 handleYoutubeResumoCommand()



Vou descrever a situação como está, sem propor mudanças, e te ajudar a entender o que pode estar errado, mantendo tudo no lugar. Não vou gerar a árvore ainda, como você pediu, e vou manter a conversa fluida, sem tópicos ou listas.
Quando olho para o que você mandou, vejo que sua estrutura tem uma pasta js/ na raiz, e dentro dela há vários arquivos soltos e algumas subpastas. Os arquivos soltos são chat.js, chatUI.js, commandMenu.js, events.js, init.js, main.js, messageRegistry.js, messageRenderer.js, sidebar.js, textarea.js, theme.js, e utils.js. Depois, tem as subpastas chat/, modules/, utils/, e youtube-system/. Dentro da pasta chat/, você tem chatActions.js, chatStorage.js, chatSync.js, chatUI.js (que parece duplicar o chatUI.js da raiz), e chatUtils.js. Na pasta modules/, estão commandHandler.js, inputBar.js, messageRegistry.js (outro duplicado, já que também está na raiz), e streamingManager.js. A pasta utils/ tem só logger.js, e a youtube-system/ contém youtubeEvents.js, youtubeHandler.js, e youtubeResumoHandler.js.
O que salta aos olhos logo de cara é a duplicação de alguns arquivos. Por exemplo, chatUI.js aparece tanto na raiz quanto na pasta chat/. Olhando o conteúdo que você forneceu, o chatUI.js da pasta chat/ tem funções como adicionarMensagem, adicionarMensagemStreaming, atualizarMensagemStreaming, iniciarChat, mostrarCarregamento, mostrarTelaInicial, scrollToBottom, updateStreamingMessage, e updateStreamingScroll. Já o chatUI.js da raiz tem funções parecidas, como adicionarMensagem, atualizarMensagemStreaming, constructor, handleMessageChunk, iniciarChat, mostrarCarregamento, e mostrarTelaInicial. Isso sugere que pode haver uma sobreposição ou confusão entre esses dois arquivos. Talvez você tenha começado com um chatUI.js na raiz e depois criado um na pasta chat/ para organizar melhor, mas o da raiz não foi removido ou atualizado. Isso pode causar erros no código, como funções sendo chamadas do arquivo errado ou conflitos de importação.
Outro ponto que parece problemático é o messageRegistry.js. Ele está tanto na raiz quanto na pasta modules/. No conteúdo que você mandou, o messageRegistry.js da pasta modules/ tem uma classe MessageRegistry com um constructor e exporta uma instância chamada messageRegistry. O da raiz parece ter a mesma estrutura, com constructor e a exportação do messageRegistry. Isso é outro sinal de duplicação. Provavelmente, você tem dois arquivos fazendo a mesma coisa, o que pode bagunçar o gerenciamento de mensagens no seu sistema de chat, especialmente porque o messageRegistry é algo central que outros arquivos, como chatActions.js e streamingManager.js, dependem.
Agora, sobre as funções, você listou várias em cada arquivo, mas algumas coisas me chamaram atenção. No chat.js, você mencionou exportações como iniciarChat, mostrarTelaInicial, adicionarMensagem, enviarMensagem, interromperResposta, carregarConversa, atualizarListaConversas, criarNovaConversa, adicionarMensagemAoHistorico, renomearConversa, excluirConversa, melhorarBlocosCodigo, atualizarBotoes, inicializarSync, e entrarNaSalaDeConversa. Mas, no conteúdo do chatActions.js dentro da pasta chat/, muitas dessas funções aparecem, como enviarMensagem, interromperResposta, carregarConversa, atualizarBotoes, entrarNaSala, e outras. Isso me faz pensar que o chat.js pode ser um arquivo mais antigo ou uma tentativa de centralizar tudo, enquanto o chatActions.js é onde essas funções estão realmente implementadas agora. Se o chat.js está sendo usado no seu código, ele pode estar chamando versões desatualizadas dessas funções, ou pior, pode nem estar sendo importado corretamente.
Outro arquivo que parece confuso é o events.js. Você disse que ele tem uma função configureEventListeners, mas no conteúdo que você forneceu, não vi nenhum detalhe sobre ele. Isso pode indicar que o events.js está vazio, desatualizado, ou simplesmente não está sendo usado. Se ele é importante, você precisa verificar se a função configureEventListeners está realmente lá e sendo chamada em algum lugar, porque, do jeito que está, parece um arquivo órfão.
Sobre os arquivos na pasta youtube-system/, eles parecem bem organizados, com youtubeEvents.js tendo setupYoutubeEvents, youtubeHandler.js com displaySubtitles, formatSubtitles, handleYoutubeCommand, processSubtitles, e setupYoutubeSocketListeners, e youtubeResumoHandler.js com handleYoutubeResumoCommand. Não vi duplicações óbvias aqui, mas notei que o youtubeEvents.js tem uma função handleYoutubeCommand que também aparece no youtubeHandler.js. Isso pode ser intencional, mas vale checar se essas funções estão fazendo coisas diferentes ou se uma delas está sobrando.
Nos arquivos da pasta modules/, o inputBar.js tem boundSubmitHandler, destroyInputBar, handleSubmit, e initializeInputBar, que parecem consistentes com o gerenciamento da barra de entrada. O commandHandler.js tem só um constructor, o que é meio vago, então talvez ele esteja incompleto ou precise de mais funções. O streamingManager.js tem um constructor, mas o conteúdo que você forneceu mostra que ele também lida com coisas como handleMessageChunk, handleResponseComplete, e createMessageContainer, que não estão listadas na sua árvore original. Isso sugere que sua árvore pode estar desatualizada em relação ao código real.
Na pasta utils/, o logger.js tem log e exporta logger, o que está alinhado com o conteúdo. Já o utils.js na raiz tem escapeHTML e mostrarCarregamento, mas notei que escapeHTML também aparece no chatUtils.js dentro da pasta chat/. Isso é mais uma duplicação que pode causar problemas, porque se diferentes partes do código estão importando escapeHTML de lugares diferentes, você pode acabar com comportamentos inconsistentes.
Os arquivos sidebar.js, textarea.js, e theme.js parecem estar ok, com funções como initSidebar e toggleSidebar no sidebar.js, configureTextarea no textarea.js, e applyTheme, initializeTheme, e toggleTheme no theme.js. Não vi duplicações óbvias aqui, mas você pode querer verificar se esses arquivos estão sendo importados corretamente no seu main.js ou init.js.
Falando do main.js e init.js, o main.js tem hideLoading, showError, showLoading, showSuccess, e exporta socket, enquanto o init.js só exporta socket. Isso é um pouco redundante, porque ambos estão exportando socket. No conteúdo, vi que o main.js inicializa o socket com io(), então o init.js pode estar sobrando ou sendo usado em um contexto diferente. Você precisa checar se ambos são necessários ou se um deles pode ser eliminado.
Para te ajudar a identificar os erros, acho que o maior problema está nas duplicações: chatUI.js na raiz e na pasta chat/, messageRegistry.js na raiz e em modules/, e funções como escapeHTML aparecendo em utils.js e chatUtils.js. Além disso, o chat.js parece ser um ponto de confusão, porque muitas das suas funções estão em chatActions.js ou outros arquivos da pasta chat/. Minha sugestão seria você verificar se o chat.js está sendo usado no seu código atual. Se não estiver, ele pode ser um resquício de uma versão antiga. Também vale olhar o events.js para confirmar se ele tem alguma função ativa, porque ele parece estar incompleto.
Se você quiser, posso te guiar para checar essas duplicações no código, tipo, olhando os imports em cada arquivo para ver se estão apontando para os lugares certos. Ou, se preferir, posso montar a árvore agora, só com o que está no seu código, sem mover nada, para você comparar com o que tem no seu projeto. Me diz como você quer prosseguir!



````
estamos no meio da fase 2


Estamos desenvolvendo um sistema de chat que integra funcionalidades de resumo de vídeos do YouTube, mas atualmente enfrentamos alguns problemas.
o primeiro deles é Em relação as mensagens do comando /YouTube só aparecem após a conclusão do download, atualizando o DOM apenas no final. Além disso, a mensagem do usuário não é exibida na tela quando ele a envia usando /youtube, enquanto para /youtube_resumo isso funciona corretamente.
A parte da inteligência artificial não sofreu alterações e está funcionando adequadamente. O segundo problema diz respeito ao comando /YouTube resumo, a digitação está ocorrendo de forma perfeita, mas há uma duplicação da mensagem no final. Isso sugere que o sistema de identificação único não foi implementado adequadamente na parte do resumo do YouTube.
Além disso, as mensagens do resumo do YouTube estão sendo renderizadas na ordem errada. Quando eu transito entre os chunks, o DOM é ajustado e fica na ordem correta, mas ainda está ocorrendo a duplicação de mensagens. Acredito que, se ajustarmos a questão dos IDs das mensagens, copiando a lógica que existe na inteligência artificial para implementar um ID único na função do resumo do YouTube, isso funcionará perfeitamente.


—------

anteriormente em resolvi a fase 1 com isso

Na Fase 1, focamos em estabelecer um núcleo robusto para o sistema de chat. Aqui estão os principais pontos que resolvemos:

Streaming Contínuo de Mensagens: Implementamos o streaming contínuo usando Socket.IO para garantir que as mensagens fossem enviadas e recebidas em tempo real.

Isolamento de Salas por conversation_id: Garantimos que cada conversa fosse isolada, utilizando conversation_id para manter as mensagens organizadas e sem interferência entre elas.

Containers Únicos por messageId: Resolvemos o problema de duplicação, garantindo que cada mensagem tivesse seu próprio container único, evitando a criação de elementos desnecessários.

Limpeza de Containers Órfãos: Implementamos uma rotina de limpeza para garantir que containers órfãos fossem removidos, mantendo o sistema limpo e eficiente.

Controle de Eventos join_conversation e leave_conversation_safe: Ajustamos eventos para garantir que o usuário pudesse entrar e sair de conversas sem problemas, sem afetar o streaming contínuo.

Animação de Carregamento Separada: Criamos uma animação de carregamento que agora é exibida separadamente, fora do container de mensagens.

Essas melhorias garantiram um sistema de chat mais robusto, seguro e eficiente
—----
podemos resolver essa quetao da fase 2 com :


Para replicar a lógica da Fase 1 na Fase 2, especialmente para comandos como o /youtube_resumo, você pode seguir esses passos:

Reutilização do conversation_id:

Assim como no chat padrão, use o conversation_id para isolar as conversas de cada usuário. Isso garantirá que os comandos /youtube_resumo sejam processados separadamente para cada conversa ativa.

Containers Únicos por messageId:

Utilize o mesmo sistema de containers únicos para cada resposta gerada pelo comando /youtube_resumo. Isso manterá a consistência visual e evitará duplicações.

Streaming Contínuo:

Adapte o fluxo de streaming para lidar com a resposta do /youtube_resumo da mesma maneira que lida com mensagens de texto da IA. Isso inclui receber message_chunk e response_complete de forma contínua.

Animação de Carregamento:

Utilize a mesma animação de carregamento que foi implementada para o chat IA, mas ajuste para ser exibida dentro do container de mensagens do YouTube.

Eventos Específicos:

Adapte eventos como join_conversation e leave_conversation_safe para que possam lidar com sessões de YouTube de maneira isolada, sem interferir no chat principal.

Essas etapas garantem que a lógica usada para o chat padrão seja replicada de forma eficiente para o comando /youtube_resumo, mantendo a consistência e a qualidade da experiência do usuário.


—--

A lógica da fase 1 está espalhada em vários arquivos principais que compõem o núcleo do seu sistema de chat. No backend, tudo gira principalmente em torno do app.py, que é onde o Socket.IO é configurado, os eventos send_message, message_chunk, response_complete, join_conversation e leave_conversation_safe são tratados. É nele que o servidor recebe as mensagens do frontend, emite os fragmentos da resposta em streaming, organiza os clientes nas salas certas usando conversation_id e controla a limpeza de sessões. Ainda no backend, o chat_storage.py é essencial porque é ele quem cria e gerencia os arquivos JSON para armazenar os históricos de conversa de cada conversation_id, garantindo a persistência dos dados.
No frontend, a parte crítica da fase 1 está em alguns arquivos-chave. O main.js é quem inicializa a conexão do Socket.IO, escuta e despacha os eventos básicos, além de fazer a ponte inicial entre o carregamento da página e a conexão ao servidor. Já o chatActions.js é o cérebro que gerencia o envio de mensagens, escuta os eventos de message_chunk e response_complete, coordena o envio para o streamingManager, exibe a animação de carregamento e atualiza o estado do chat. O streamingManager.js é quem cuida do estado interno do streaming, usando o messageRegistry, gerenciando a criação dos containers corretos para as mensagens, organizando os fragmentos que chegam via streaming e garantindo que o fluxo visual no chat seja incremental e correto. O messageRenderer.js é onde a mágica da renderização acontece: é ele quem transforma cada fragmento de resposta em HTML seguro usando marked e DOMPurify, acumulando os chunks no mesmo container correto, aplicando a renderização incremental para dar a sensação de digitação contínua.
Esses quatro arquivos, mais o chatUI.js (que organiza a interface, como scroll e comandos visuais) e o init.js (que faz a inicialização básica da interface), juntos formam a espinha dorsal que foi construída na fase 1. A lógica de animação de carregamento nova, aquela que substitui o cursor antigo, ficou misturada entre ajustes no chatActions.js (para ativar e desativar a animação) e a adição do elemento visual no index.html junto com pequenos ajustes no CSS em streaming.css para estilizar o spinner. Tudo isso se conecta para formar o comportamento atual que você tem no sistema, garantindo o streaming contínuo, o isolamento de conversas e a interação fluida sem perdas de resposta, mesmo ao trocar de chats.


Relatório de Soluções Implementadas
Problemas Identificados
Mensagens do usuário não aparecem imediatamente ao usar o comando /youtube
Duplicação de mensagens no comando /youtube_resumo
Ordem incorreta das mensagens do resumo do YouTube
Erro no messageRegistry ("messageRegistry.entries is not a function")
Falta de feedback visual durante o processamento de vídeos
Soluções Implementadas
1. Renderização Imediata de Mensagens do Usuário
Modificamos a função enviarMensagem em chatActions.js para renderizar a mensagem do usuário imediatamente após o envio, antes de qualquer processamento
Movemos a verificação de mensagens duplicadas para o início da função, evitando processamento desnecessário
Criamos a função renderUserMessage para padronizar a renderização de mensagens do usuário
2. Prevenção de Duplicação de Mensagens
Implementamos a função isMessageExists no streamingManager.js para verificar se uma mensagem já existe no DOM
Adicionamos verificações de duplicação em pontos críticos:
No início do processamento da mensagem
No recebimento de chunks
Na conclusão da resposta
Melhoramos a detecção de mensagens duplicadas baseada em tempo e conteúdo similar
Criamos verificações para impedir renderização de mensagens já existentes no DOM
3. Correção da Ordem das Mensagens
Implementamos a função reorderMessages em streamingManager.js que:
Seleciona todas as mensagens de uma conversa
Ordena-as por timestamp (data-created-at) ou ID da mensagem
Verifica se a reordenação é necessária antes de alterar o DOM
Reinsere as mensagens na ordem cronológica correta
Adicionamos chamada à reorderMessages após a conclusão de cada resposta
4. Resolução do Erro do messageRegistry
Adicionamos verificação para garantir que messageRegistry seja sempre um Map válido
Implementamos tratamento de erro para o método cleanupOrphan
Adicionamos reinicialização do messageRegistry em caso de erro
Substituímos messageRegistry por window.messageRegistry para garantir acesso ao objeto global
5. Melhoria no Feedback Visual
Adicionamos uma mensagem de processamento temporária para o comando /youtube com ícone de loading
Criamos mensagens de erro informativas em caso de falha no processamento
Implementamos remoção automática das mensagens de processamento quando a resposta começa
6. Implementação de Streaming para /youtube
Criamos a função setupYoutubeStreamListeners para processar chunks em tempo real
Configuramos para escutar os eventos message_chunk específicos para o YouTube
Implementamos atualização progressiva do conteúdo em tempo real
7. Melhorias na Interface de Usuário
Padronizamos a criação de contêineres de mensagens com a função createMessageContainer
Implementamos rolagem automática para novas mensagens
Adicionamos verificação de elementos essenciais da interface antes da inicialização
8. Otimização de Conexões Socket.IO
Implementamos funções manageRoomConnection, joinConversation e leaveConversation
Adicionamos sistema de debounce para evitar múltiplas entradas/saídas em salas
Criamos controle centralizado da sala atual para evitar conexões desnecessárias
Resultado Final
Todas estas mudanças visam garantir:
Renderização imediata das mensagens do usuário para todos os comandos
Exibição em tempo real do conteúdo de ambos os comandos do YouTube
Ordenação cronológica correta das mensagens
Eliminação de mensagens duplicadas
Feedback visual apropriado durante o processamento
Operação estável do sistema sem erros no messageRegistry
Estas melhorias devem proporcionar uma experiência de usuário mais fluida e responsiva, especialmente ao trabalhar com os comandos /youtube e /youtube_resumo.



—----

Sim, observei que o texto do resumo do vídeo "DUBLADORA DA FERN CONTA O DESAFIO DE DUBLAR EM FRIEREN" foi duplicado na interface. O mesmo conteúdo aparece duas vezes seguidas - uma vez com a primeira mensagem do assistente e depois repetido exatamente igual como uma mensagem completa adicional.
Isso é provavelmente resultado do problema de duplicação que estávamos discutindo anteriormente. O sistema está gerando ou exibindo a mesma resposta duas vezes quando você usa o comando /youtube_resumo.


Read file: static/js/chat/chatActions.js Encontrei o problema de duplicação de mensagens no código. O arquivo chatActions.js contém mecanismos para lidar com mensagens duplicadas, mas parece haver um problema na implementação.
A função isDuplicateMessage na linha 462 verifica se uma mensagem é duplicada comparando o conteúdo e o ID da conversa:
function isDuplicateMessage(conversationId, content) {
    const key = `${conversationId}:${content}`;
    const lastSentTime = sentMessages.get(key);
    const now = Date.now();
    
    // Se a mensagem foi enviada nos últimos 2 segundos, é considerada duplicata
    if (lastSentTime && (now - lastSentTime) < 2000) {
        logger.debug('Mensagem duplicada detectada', {
            conversationId,
            content: content.substring(0, 20) + '...',
            timeDiff: now - lastSentTime
        });
        return true;
    }
    
    sentMessages.set(key, now);
    return false;
}

O problema pode estar ocorrendo por diversos motivos:
O sistema de verificação de duplicação está configurado para detectar apenas mensagens enviadas nos últimos 2 segundos, o que pode ser insuficiente se o atraso for maior.
Na função handleStreamChunk (linha 1032), existe uma verificação para chunks duplicados:
// Verificar se este é um chunk duplicado
if (processedChunks.has(`${message_id}-${chunk}`)) {
    chatDebugger.warn('Chunk duplicado detectado e ignorado', { 
        message_id, 
        chunk_length: chunk.length 
    });
    return;
}

Porém, se a mensagem chegar com um ID diferente (por exemplo, se for reenviada pelo servidor), este mecanismo não vai funcionar.
O código também monitora "mensagens órfãs" a cada 10 segundos, o que sugere que há casos onde mensagens podem ficar sem processamento adequado.
Para resolver este problema, você poderia:
Aumentar o tempo de detecção de duplicação (de 2 segundos para um valor maior)
Implementar um mecanismo de verificação baseado no conteúdo da mensagem, não apenas no ID
Verificar no servidor se não está enviando a mesma mensagem duas vezes
Este problema parece ser um desafio comum em sistemas de chat em tempo real, especialmente com streaming de mensagens.


````


Observação Importante: Como mencionado anteriormente e confirmado pela análise do código, existem alguns arquivos duplicados (chatUI.js, messageRegistry.js) e funções com nomes semelhantes em arquivos diferentes (escapeHTML, mostrarCarregamento, várias funções de chat.js que parecem estar implementadas em chatActions.js e chatStorage.js). A documentação abaixo tenta descrever a intenção ou a implementação mais provável (geralmente a que está dentro de pastas mais específicas como chat/ ou modules/), mas você precisará revisar seu projeto para eliminar essas redundâncias e garantir que está usando as versões corretas dos arquivos e funções.

Dicionário de Funções do Projeto de Chat
Este documento descreve a função de cada arquivo JavaScript principal e suas funções internas no projeto.
📁 js/ (Raiz)
📄 chat.js
Propósito Geral: Parece ser um arquivo centralizador antigo ou uma tentativa inicial de agrupar as funções do chat. Muitas de suas funções exportadas parecem ter implementações mais recentes ou específicas nos arquivos dentro da pasta js/chat/. Recomendação: Verifique se este arquivo ainda está sendo usado ou se pode ser removido/refatorado.
Funções Exportadas (📤):
iniciarChat: (Provavelmente) Inicia uma nova sessão de chat na UI.
mostrarTelaInicial: (Provavelmente) Exibe a tela de boas-vindas.
adicionarMensagem: (Provavelmente) Adiciona uma mensagem completa ao chat.
enviarMensagem: (Provavelmente) Lida com o envio da mensagem do usuário para o backend. (Similar a chatActions.js)
interromperResposta: (Provavelmente) Interrompe o streaming de uma resposta da IA. (Similar a chatActions.js)
carregarConversa: (Provavelmente) Carrega o histórico de uma conversa existente. (Similar a chatStorage.js e chatActions.js)
atualizarListaConversas: (Provavelmente) Atualiza a lista de conversas na barra lateral. (Similar a chatStorage.js)
criarNovaConversa: (Provavelmente) Cria uma nova conversa. (Similar a chatStorage.js)
adicionarMensagemAoHistorico: (Provavelmente) Salva uma mensagem no histórico. (Similar a chatStorage.js)
renomearConversa: (Provavelmente) Renomeia uma conversa existente. (Similar a chatStorage.js)
excluirConversa: (Provavelmente) Exclui uma conversa. (Similar a chatStorage.js)
melhorarBlocosCodigo: (Provavelmente) Aplica formatação ou destaque a blocos de código. (Similar a chatUtils.js)
atualizarBotoes: (Provavelmente) Atualiza o estado dos botões (enviar/parar). (Similar a chatActions.js)
inicializarSync: (Provavelmente) Inicia a sincronização via WebSocket. (Similar a chatSync.js)
entrarNaSalaDeConversa: (Provavelmente) Conecta o cliente à sala WebSocket da conversa. (Similar a chatSync.js)
📄 chatUI.js (Arquivo na Raiz)
Propósito Geral: Contém funções relacionadas à manipulação da interface do usuário (UI) do chat. Observação: Existe um arquivo com o mesmo nome em js/chat/chatUI.js, sugerindo que este arquivo na raiz pode ser redundante ou uma versão antiga.
Funções (🔧):
adicionarMensagem(): Adiciona uma mensagem completa à interface do chat.
atualizarMensagemStreaming(): Atualiza uma mensagem existente na UI durante o streaming.
constructor(): Método construtor da classe (se for uma classe).
handleMessageChunk(): Processa um pedaço (chunk) de mensagem recebido via streaming.
iniciarChat(): Configura a interface para iniciar um novo chat.
mostrarCarregamento(): Exibe um indicador de carregamento na UI.
mostrarTelaInicial(): Exibe a tela inicial ou de boas-vindas.
📄 commandMenu.js
Propósito Geral: Gerencia a exibição e interação com um menu de comandos que aparece quando o usuário digita / no campo de entrada.
Funções (🔧):
initCommandMenu(): Inicializa o menu de comandos, associando-o ao campo de input.
updateMenuPosition(): Ajusta a posição do menu na tela em relação ao campo de input.
updateSelectedItem(): Destaca o item selecionado no menu (navegação por teclado).
📄 events.js
Propósito Geral: Configura os ouvintes de eventos (event listeners) globais ou principais da aplicação (ex: cliques em botões de tema, sidebar).
Funções (🔧):
configureEventListeners(): Adiciona os listeners aos elementos relevantes do DOM.
📄 init.js
Propósito Geral: Parece ser um arquivo de inicialização, possivelmente para configurar o socket ou outras configurações globais iniciais. Observação: Exporta socket, o que é redundante com main.js. Pode ser um arquivo antigo ou parte de uma estrutura diferente.
Exportações (📤):
socket: (Provavelmente) Uma instância do cliente Socket.IO.
📄 main.js
Propósito Geral: Ponto de entrada principal do JavaScript ou local de inicialização central. Configura o Socket.IO, inicializa componentes e define funções globais de feedback visual.
Funções (🔧):
hideLoading(): Esconde o indicador de carregamento global.
showError(): Exibe uma mensagem de erro global.
showLoading(): Exibe o indicador de carregamento global.
showSuccess(): Exibe uma mensagem de sucesso global.
Exportações (📤):
socket: A instância principal do cliente Socket.IO, inicializada aqui.
📄 messageRegistry.js (Arquivo na Raiz)
Propósito Geral: Define a classe MessageRegistry para gerenciar o estado das mensagens. Observação: Existe um arquivo com o mesmo nome em js/modules/messageRegistry.js. Este na raiz é provavelmente redundante.
Funções (🔧):
constructor(): Inicializa o registro (provavelmente um Map).
Exportações (📤):
messageRegistry: Uma instância da classe MessageRegistry.
📄 messageRenderer.js
Propósito Geral: Responsável por renderizar mensagens (completas ou em streaming) no DOM, incluindo formatação Markdown e sanitização.
Funções (🔧):
accumulateChunk(): Acumula chunks de texto para uma mensagem específica (pode estar obsoleto se o messageRegistry centralizar isso).
cleanupOrphan(): Remove containers de mensagens do DOM que não estão mais no registro ou estão incompletos (essencial para evitar "fantasmas").
clearAccumulatedResponse(): Limpa o buffer de chunks acumulados para uma conversa.
completeMessage(): Marca uma mensagem como completa no messageRegistry e remove indicadores de streaming da UI.
createContainer(): Cria o elemento DOM base para uma nova mensagem.
getAccumulatedState(): Retorna o estado atual dos chunks acumulados.
processCodeChunk(): Processa e formata especificamente blocos de código dentro das mensagens.
renderCompleteResponse(): Renderiza a resposta completa após o fim do streaming.
renderContent(): Renderiza o conteúdo principal (texto) dentro do container da mensagem.
renderMarkdown(): Converte texto Markdown em HTML usando marked.js e DOMPurify.
renderMessageChunk(): Renderiza um chunk incremental de uma mensagem em streaming.
renderMessageContainer(): Cria ou atualiza o container DOM completo para uma mensagem.
scrollToBottomIfNear(): Rola o chat para o final automaticamente se o usuário já estiver perto do final.
setCurrentConversation(): Define qual conversa está ativa para o renderizador (evita renderizar em chats errados).
Exportações (📤):
messageRegistry: Exporta a instância do registro de mensagens (provavelmente importada de modules/).
📄 sidebar.js
Propósito Geral: Gerencia a funcionalidade da barra lateral (exibir/ocultar, carregar lista de chats).
Funções (🔧):
initSidebar(): Inicializa o estado da barra lateral (ex: verifica se estava recolhida no localStorage).
toggleSidebar(): Alterna a visibilidade da barra lateral.
📄 textarea.js
Propósito Geral: Configura o comportamento do elemento <textarea> usado para digitar mensagens.
Funções (🔧):
configureTextarea(): Adiciona funcionalidades como auto-ajuste de altura e envio com Enter (sem Shift).
📄 theme.js
Propósito Geral: Gerencia a troca de temas (claro/escuro) da aplicação.
Funções (🔧):
applyTheme(): Aplica as variáveis CSS do tema selecionado ao documento.
initializeTheme(): Define o tema inicial com base na preferência do usuário (localStorage) ou do sistema operacional.
toggleTheme(): Alterna entre os temas claro e escuro.
📄 utils.js (Arquivo na Raiz)
Propósito Geral: Contém funções utilitárias genéricas. Observação: Funções como escapeHTML também existem em js/chat/chatUtils.js. Pode ser parcialmente redundante.
Funções (🔧):
escapeHTML(): Escapa caracteres HTML para prevenir XSS em locais onde Markdown não é usado.
mostrarCarregamento(): Função utilitária para exibir um indicador de carregamento (pode ser específica para um contexto diferente do chat principal).
📁 js/chat/
📄 chatActions.js
Propósito Geral: Orquestra as principais ações e lógica do chat, interagindo com a UI, armazenamento e sincronização. Parece ser o controlador principal do fluxo de chat.
Funções (🔧):
atualizarBotoes(): Mostra/esconde os botões de enviar/parar com base no estado do streaming.
carregarConversa(): Inicia o processo de carregamento de uma conversa existente na UI.
constructor(): Construtor (se for uma classe).
entrarNaSala(): Emite evento para o servidor (via chatSync.js) para entrar na sala WebSocket da conversa.
enviarMensagem(): Lida com o envio da mensagem do usuário (validação, adição à UI, envio ao backend).
forcarRenderizacao(): (Provavelmente) Força uma atualização visual da interface.
handleStreamChunk(): Processa um chunk de mensagem recebido (pode delegar para messageRenderer ou streamingManager).
handleStreamingScroll(): Gerencia o comportamento de rolagem durante o streaming.
inicializarConversa(): Inicializa o estado de uma conversa específica (pode estar em chatStorage.js).
interromperResposta(): Envia solicitação para parar o streaming de uma resposta.
isDuplicateMessage(): Verifica se uma mensagem recebida é duplicada (evita renderização dupla).
isUserAtBottom(): Verifica se o scroll do chat está no final.
sairDaSala(): Emite evento para sair da sala WebSocket.
scrollListener(): Listener para eventos de scroll no chat.
scrollToBottom(): Rola o chat para a última mensagem.
📄 chatStorage.js
Propósito Geral: Gerencia a persistência das conversas (leitura e escrita, possivelmente interagindo com localStorage ou APIs backend).
Funções (🔧):
adicionarMensagemAoHistorico(): Salva uma nova mensagem no histórico da conversa.
atualizarListaConversas(): Busca o histórico de conversas e atualiza a lista na barra lateral.
carregarConversa(): Carrega os dados completos de uma conversa (provavelmente do backend).
carregarMensagensEmLotes(): Implementa lazy loading, carregando mensagens de uma conversa em partes.
configureScrollListener(): Configura o listener de scroll para disparar o carregamento de mais mensagens (lazy loading).
criarNovaConversa(): Cria a estrutura de dados para uma nova conversa e a salva.
excluirConversa(): Remove uma conversa do armazenamento.
renomearConversa(): Altera o título de uma conversa salva.
📄 chatSync.js
Propósito Geral: Gerencia a comunicação em tempo real via Socket.IO, sincronizando o estado entre o cliente e o servidor e entre diferentes abas/clientes.
Funções (🔧):
atualizarBufferDaConversa(): Atualiza um buffer interno com chunks recebidos para conversas não ativas.
entrarNaSalaDeConversa(): Envia o evento join_conversation ao servidor.
gerarSessionId(): Cria um ID de sessão único para o cliente.
inicializarSync(): Estabelece a conexão Socket.IO e configura listeners de eventos básicos.
marcarParaRecarregar(): Marca uma conversa para ser atualizada quando a aba/janela ficar visível.
setupConnectionListeners(): Configura listeners para eventos de conexão/desconexão do socket.
setupEventListeners(): Configura listeners para eventos específicos da aplicação (ex: message_chunk, conversation_updated).
testSocketConnection(): Função para testar a conexão WebSocket.
verificarRecarregamento(): Verifica se há conversas marcadas para recarregar ao tornar a aba visível.
📄 chatUI.js (Arquivo na pasta chat/)
Propósito Geral: Funções de UI específicas para a interface do chat ativo. Observação: Provavelmente a versão ativa em comparação com o arquivo na raiz.
Funções (🔧):
adicionarMensagem(): Adiciona uma mensagem completa ao container do chat.
adicionarMensagemStreaming(): Cria o container inicial para uma mensagem que chegará via streaming.
atualizarMensagemStreaming(): Atualiza o conteúdo de um container de mensagem em streaming.
iniciarChat(): Limpa o container e prepara a UI para uma nova conversa ou carregamento.
mostrarCarregamento(): Exibe um indicador de carregamento dentro do chat.
mostrarTelaInicial(): Reverte a UI para a tela de boas-vindas.
scrollToBottom(): Rola o container do chat para o final.
updateStreamingMessage(): Sinônimo ou função relacionada a atualizarMensagemStreaming.
updateStreamingScroll(): Gerencia o scroll durante o streaming.
📄 chatUtils.js
Propósito Geral: Funções utilitárias específicas para a funcionalidade do chat.
Funções (🔧):
copiarCodigo(): Copia o conteúdo de um bloco de código para a área de transferência.
copiarMensagem(): Copia o texto de uma mensagem inteira.
escapeHTML(): Escapa caracteres HTML. (Duplica js/utils.js)
melhorarBlocosCodigo(): Adiciona cabeçalhos, botões de copiar e aplica syntax highlighting (usando hljs) a blocos <pre><code>.
regenerarResposta(): Pega a última mensagem do usuário e a reenvia para obter uma nova resposta da IA.
📁 js/modules/
📄 commandHandler.js
Propósito Geral: (Provavelmente) Lida com a interpretação e execução de comandos digitados pelo usuário (ex: /youtube). Pode estar incompleto ou ser uma estrutura base.
Funções (🔧):
constructor(): Inicializador da classe.
📄 inputBar.js
Propósito Geral: Gerencia a barra de input, incluindo o textarea e potencialmente o menu de comandos associado.
Funções (🔧):
boundSubmitHandler(): Uma versão "ligada" (bound) do handler de submit, provavelmente para manter o contexto (this).
destroyInputBar(): Remove listeners e limpa recursos associados à barra de input.
handleSubmit(): Função que lida com o evento de submit do formulário de input.
initializeInputBar(): Configura a barra de input, associando eventos e o menu de comandos.
📄 messageRegistry.js (Arquivo na pasta modules/)
Propósito Geral: Implementação central e ativa do registro de mensagens. Essencial para rastrear o estado (conteúdo, container DOM, status de streaming/completo) de cada mensagem, prevenindo duplicações e gerenciando o ciclo de vida.
Funções (🔧):
constructor(): Inicializa o registro (um Map). Configura a instância global window.messageRegistry.
Métodos internos (não listados na árvore, mas inferidos pelo uso): registerMessage, getMessage, updateMessage, addChunk, completeMessage, removeMessage, hasMessage, cleanOrphanContainers.
Exportações (📤):
messageRegistry: A instância única e ativa do MessageRegistry.
📄 streamingManager.js
Propósito Geral: Gerencia o recebimento e processamento de eventos de streaming via Socket.IO (message_chunk, response_complete). Coordena a atualização do messageRegistry e da UI (messageRenderer).
Funções (🔧):
constructor(): Inicializa o manager e configura os listeners do Socket.IO.
Métodos internos (inferidos): handleMessageChunk, handleResponseComplete, handleStreamError.
📁 js/utils/
📄 logger.js
Propósito Geral: Fornece um sistema centralizado de logging para a aplicação frontend, com níveis diferentes (DEBUG, INFO, WARN, ERROR) e envio opcional para o backend.
Funções (🔧):
log(): Função base que formata e envia/exibe a mensagem de log.
Exportações (📤):
logger: Objeto com métodos (debug, info, warn, error) para facilitar o logging.
📁 js/youtube-system/
📄 youtubeEvents.js
Propósito Geral: Configura listeners de Socket.IO específicos para os eventos relacionados ao processamento de vídeos do YouTube.
Funções (🔧):
handleYoutubeCommand(): Processa um comando YouTube recebido (pode interagir com youtubeHandler.js). Observação: Nome duplicado com função em youtubeHandler.js. Verificar propósito exato.
setupYoutubeEvents(): Adiciona os listeners de Socket.IO relevantes (youtube_response, youtube_error, etc.).
📄 youtubeHandler.js
Propósito Geral: Contém a lógica principal para interagir com o backend para processar comandos /youtube, buscar legendas e exibi-las.
Funções (🔧):
displaySubtitles(): Exibe as legendas formatadas na UI.
formatSubtitles(): Formata o texto bruto das legendas.
handleYoutubeCommand(): Envia a requisição para o backend processar o comando /youtube.
processSubtitles(): Orquestra o processo de obtenção e exibição de legendas.
setupYoutubeSocketListeners(): Configura os listeners do socket (pode ser redundante com youtubeEvents.js).
📄 youtubeResumoHandler.js
Propósito Geral: Lida especificamente com o comando /youtube_resumo, enviando a requisição ao backend para iniciar o processo de resumo do vídeo.
Funções (🔧):
handleYoutubeResumoCommand(): Envia a requisição para o endpoint /process_youtube_resumo.

Espero que este dicionário detalhado ajude você a entender melhor a estrutura e a função de cada parte do seu código JavaScript! Lembre-se de revisar as duplicações e redundâncias para organizar melhor seu projeto.
Fontes e conteúdo relacionado

-------------

**Contexto Atual:**

Olá! Nós trabalhamos anteriormente na implementação de logs detalhados (Fase 1) no sistema de chat (arquivos como `chatActions.js`, `streamingManager.js`, `messageRenderer.js`, `app.py`, etc.). O objetivo foi mapear o fluxo, identificar gargalos e preparar o terreno para correções. Os logs foram adicionados com sucesso e nos ajudaram a diagnosticar os problemas com mais clareza.

**Próximo Objetivo (Fase 2):**

Agora, estamos iniciando a **Fase 2**, que consiste em **alinhar os comandos `/youtube` e `/youtube_resumo` com a lógica funcional do chat com IA**. Os problemas específicos que precisamos resolver nesta fase, identificados com ajuda dos logs e análises anteriores, são:

1.  **`/youtube`**:
    * A mensagem do usuário (`/youtube URL`) não aparece na interface do chat quando enviada.
    * A transcrição completa do vídeo só é exibida após todo o processamento no backend, sem streaming.
2.  **`/youtube_resumo`**:
    * Ocorre duplicação da mensagem final do resumo na interface.
    * A ordem de renderização dos blocos do resumo pode apresentar problemas visuais temporários (embora o conteúdo final pareça correto após a conclusão).

**Estratégia Acordada:**

Concluímos que a melhor abordagem é **replicar o padrão de funcionamento do chat com IA** para os comandos do YouTube. Isso envolve principalmente:

* **Gerenciamento de ID:** O Frontend deve gerar um `messageId` único para cada comando `/youtube` ou `/youtube_resumo` e enviá-lo ao Backend.
* **Consistência no Backend:** O Backend (`app.py`) deve receber e **usar** esse `messageId` do frontend para todos os eventos Socket.IO (`message_chunk`, `response_complete`) relacionados àquela resposta específica.
* **Lógica de Armazenamento Unificada:** O Backend deve salvar a resposta completa (transcrição ou resumo) no `chat_storage.py` **apenas uma vez**, no final do processamento, antes de emitir `response_complete`, espelhando o comportamento da IA e evitando o padrão problemático de "salvar parcial e depois atualizar".
* **Correções Adicionais:** Resolver bugs pendentes identificados na Fase 1, como o erro `messageRegistry.entries` e a lógica de limpeza `cleanupOrphan`, além de garantir a renderização imediata da mensagem do usuário para o comando `/youtube`.

**Plano Detalhado (Fase 2):**

A seguir está o plano estruturado que desenvolvemos para executar a Fase 2. Peço que siga estes passos para me ajudar a implementar as correções e melhorias necessárias no código.

**(---

# 🔥 Fase 2: Alinhamento dos Comandos YouTube (Em Andamento)

**Contexto:** A Fase 1 estabeleceu um fluxo de streaming funcional para a IA, com IDs consistentes e gerenciamento de estado via `messageRegistry`. Agora, aplicaremos esses mesmos princípios aos comandos `/youtube` e `/youtube_resumo` para corrigir os problemas atuais.

**Problemas Atuais a Resolver:**

* `/youtube`: Mensagem do usuário não aparece na UI; transcrição só é renderizada no final.
* `/youtube_resumo`: Duplicação da mensagem final; ordem de renderização dos blocos incorreta (embora se corrija visualmente com novos chunks).
* (Correção Pendente da Fase 1): Possíveis erros remanescentes de limpeza (`cleanupOrphan`) ou renderização (`marked()`) que podem impactar a estabilidade geral.

**Objetivo da Fase 2:** Garantir que ambos os comandos do YouTube sigam o fluxo padrão `Frontend gera ID -> Backend usa ID -> Chunks/Resposta via Socket.IO -> Frontend renderiza com ID conhecido -> Backend salva UMA VEZ no final`, eliminando inconsistências e bugs.

## Plano Estruturado - Fase 2

### Passo 2.1: Verificação Rigorosa do Fluxo de IDs (YouTube e Resumo)

*(Objetivo: Confirmar que a geração e o uso de `messageId` estão corretos ponta a ponta, como planejado)*

1.  **Frontend - Geração e Envio:**
    * **Verificar:** Código em `static/js/chat/chatActions.js` (ou handlers específicos como `youtubeHandler.js`, `youtubeResumoHandler.js`).
    * **Confirmar:** Se um `messageId` único é gerado **ANTES** da chamada `Workspace` para `/process_youtube` e `/process_youtube_resumo`.
    * **Confirmar:** Se este `messageId` gerado está sendo incluído corretamente no `body` da requisição enviada ao backend.
    * **Log:** Usar `logger.debug` no JS para registrar o `messageId` gerado e o corpo da requisição.
2.  **Backend - Recepção:**
    * **Verificar:** Código em `app.py`, nas rotas `/process_youtube` e `/process_youtube_resumo`.
    * **Confirmar:** Se o `messageId` está sendo extraído corretamente do `request.json`.
    * **Confirmar:** Se este `messageId` recebido está sendo passado como argumento para as funções `process_youtube_background` e `process_youtube_resumo_background`.
    * **Log:** Usar `logger.info` no Python para registrar o `messageId` recebido do frontend.
3.  **Backend - Uso Consistente:**
    * **Verificar:** Código em `app.py`, nas funções `process_youtube_background` e `process_youtube_resumo_background`.
    * **Confirmar:** Se o `messageId` recebido (e NÃO um novo UUID) está sendo usado em **TODAS** as chamadas `socketio.emit()` (`message_chunk`, `response_complete`, `stream_error`, etc.) relacionadas a essa resposta.
    * **Log:** Usar `logger.debug` no Python dentro dessas funções para mostrar o `messageId` sendo usado em cada `emit`.
4.  **Rastreamento Completo:**
    * **Ação:** Executar um comando `/youtube_resumo` e um `/youtube`.
    * **Analisar:** Logs do frontend e backend para seguir o *mesmo* `messageId` desde a geração no JS até a recepção dos eventos (`message_chunk`, `response_complete`) no JS. Qualquer troca ou novo ID gerado indica um erro na implementação.

### Passo 2.2: Verificação da Lógica de Armazenamento (`/youtube_resumo`)

*(Objetivo: Garantir que o resumo só seja salvo no histórico UMA VEZ, no final do processo)*

1.  **Backend - Ponto de Salvamento:**
    * **Verificar:** Código em `app.py` na função `process_youtube_resumo_background`.
    * **Confirmar:** Se a chamada `add_message_to_conversation` ocorre **APENAS UMA VEZ**, logo antes de `socketio.emit('response_complete')`.
    * **Confirmar:** Se a chamada `update_message_in_conversation` **NÃO está sendo usada** para a mensagem do resumo.
    * **Confirmar:** Se o `messageId` passado para `add_message_to_conversation` é o mesmo ID recebido do frontend.
    * **Log:** Usar `logger.info` para registrar o momento exato do salvamento e o `messageId` associado.
2.  **Backend - Tratamento de Conteúdo:**
    * **Verificar:** Código em `utils/chat_storage.py`.
    * **Confirmar:** Se a função `add_message_to_conversation` (e `save_conversation` chamada por ela) consegue lidar com conteúdos potencialmente grandes do resumo completo sem erros ou truncamentos.

### Passo 2.3: Diagnóstico e Correção da Duplicação (`/youtube_resumo`)

*(Objetivo: Eliminar a renderização duplicada da resposta final)*

1.  **Frontend - Análise de Eventos Concorrentes:**
    * **Analisar:** Logs do frontend (`streamingManager.js`, `messageRenderer.js`, `chatActions.js`) no momento em que os eventos `response_complete` e `conversation_updated` chegam para o *mesmo* `conversation_id` após um `/youtube_resumo`.
    * **Investigar:** A lógica de `atualizarListaConversas` e `carregarConversa` (em `chatStorage.js` ou `chatActions.js`). Ela está causando uma re-renderização completa do chat que ignora a mensagem já finalizada pelo `response_complete`?
    * **Log:** Adicionar logs específicos em `messageRenderer.js` (ex: `renderCompleteResponse`, `renderMessageContainer`) para identificar se a mesma mensagem (`messageId`) está sendo renderizada/atualizada por gatilhos diferentes (streaming vs. recarga de histórico).
2.  **Frontend - Lógica de Prevenção:**
    * **Verificar:** Código que renderiza mensagens do histórico (`carregarConversa` ou similar).
    * **Implementar/Confirmar:** Se existe uma verificação **robusta** para **NÃO** adicionar um elemento ao DOM se outro elemento com o **mesmo `data-message-id`** já existir, independentemente das classes (`streaming`, `complete`). O `messageRegistry` pode ser consultado aqui.

### Passo 2.4: Correção da Mensagem de Usuário Ausente (`/youtube`)

*(Objetivo: Garantir que o comando `/youtube URL` apareça na UI)*

1.  **Frontend - Verificação da Renderização:**
    * **Verificar:** Código em `static/js/chat/chatActions.js` (ou `youtubeHandler.js`) onde o comando `/youtube` é tratado.
    * **Confirmar:** Se o bloco de código que adiciona o `div` da mensagem do usuário (como sugerido na correção anterior) está presente e sendo executado.
    * **Log:** Adicionar `logger.debug` *imediatamente antes* e *imediatamente depois* do código que deveria adicionar a mensagem do usuário ao DOM.
2.  **Inspeção do DOM:**
    * **Ação:** Usar as ferramentas de desenvolvedor do navegador.
    * **Verificar:** Inspecionar o `div.chat-container` logo após enviar o comando `/youtube URL`. O `div.message.user` correspondente foi adicionado?

### Passo 2.5: Alinhamento da Resposta (`/youtube`)

*(Objetivo: Fazer a transcrição usar o fluxo padrão de eventos Socket.IO)*

1.  **Backend - Emissão de Eventos:**
    * **Verificar:** Código em `app.py`, função `process_youtube_background`.
    * **Confirmar:** Se está usando o `messageId` recebido do frontend.
    * **Implementar (Opção A - Recomendada):**
        * Remover o evento customizado `youtube_response`.
        * Acumular toda a `response_content` (transcrição).
        * Salvar uma única vez com `add_message_to_conversation` usando o `messageId` do frontend.
        * Emitir **apenas `response_complete`** com o `messageId` e o `complete_response` contendo toda a transcrição.
    * **Implementar (Opção B - Opcional/Futuro):**
        * Quebrar `cleaned_subtitles` em chunks razoáveis.
        * Emitir múltiplos `message_chunk` com o `messageId` do frontend.
        * Salvar uma única vez com `add_message_to_conversation` no final.
        * Emitir `response_complete` no final.
    * **Log:** Adicionar logs para confirmar qual fluxo de eventos (`response_complete` ou `message_chunk`/`response_complete`) está sendo usado e com qual `messageId`.
2.  **Frontend - Recepção de Eventos:**
    * **Verificar:** Código em `static/js/youtube-system/youtubeEvents.js` ou onde os listeners para respostas do YouTube estão.
    * **Ajustar:** Se optou pela Opção A no backend, garantir que o listener de `response_complete` (provavelmente em `streamingManager.js`) consiga tratar essa resposta completa corretamente (usando o `messageId`).
    * **Ajustar:** Se optou pela Opção B, garantir que os listeners de `message_chunk` e `response_complete` estejam configurados para tratar a resposta do `/youtube` usando o `messageId`. Remover listeners de `youtube_response`.

### Passo 2.6: Diagnóstico e Correção da Ordem (`/youtube_resumo`)

*(Objetivo: Garantir que os blocos do resumo apareçam na ordem correta)*

1.  **Análise de Chunks:**
    * **Verificar:** Logs do frontend para o evento `message_chunk` durante um `/youtube_resumo`.
    * **Confirmar:** Se o `chunk_number` recebido está sequencial e correto para cada parte (cabeçalho, bloco 1, resumo 1, bloco 2, resumo 2...).
2.  **Frontend - Lógica de Renderização:**
    * **Verificar:** Código em `messageRenderer.js` e `streamingManager.js`.
    * **Investigar:** Se a forma como os chunks são adicionados ao `messageRegistry` ou atualizados no DOM (`renderContent` / `renderMessageChunk`) pode estar causando a reordenação visual temporária. A renderização é puramente sequencial ou há alguma lógica assíncrona que pode embaralhar a ordem visual?
    * **Log:** Adicionar logs detalhados mostrando a ordem exata em que `renderContent` é chamado e o conteúdo que está sendo renderizado para um `messageId` específico.

### Passo 2.7: Testes Integrados (Foco YouTube)

1.  **Executar Testes:** Após implementar cada sub-passo acima, testar exaustivamente os comandos `/youtube` e `/youtube_resumo`.
2.  **Cenários:**
    * Vídeos curtos e longos.
    * Vídeos sem legendas ou com legendas em outros idiomas.
    * Trocar de chat rapidamente durante o processamento.
    * Enviar múltiplos comandos YouTube em sequência.
    * Interromper o resumo com o botão "Stop".
3.  **Validar:**
    * Ausência de duplicações.
    * Mensagem do usuário sempre visível para `/youtube`.
    * Ordem correta das mensagens do resumo.
    * Logs de frontend e backend consistentes com o fluxo esperado e IDs corretos.
    * Estabilidade geral e ausência de erros no console.

---

Com este plano detalhado para a Fase 2, podemos atacar os problemas do YouTube de forma sistemática, usando a base sólida da Fase 1 e os insights dos logs. Boa caçada aos bugs!
)**
*Cole o bloco de Markdown que começa com `# 🔥 Fase 2: Alinhamento dos Comandos YouTube (Em Andamento)` e termina antes de `--- Com este plano detalhado...`.*

**Pedido:**

Com base neste contexto e no plano detalhado acima (que você colou), por favor, me ajude a implementar o **Passo 2.1: Verificação Rigorosa do Fluxo de IDs (YouTube e Resumo)**. Vamos começar verificando o código e os logs para garantir que os `messageId`s estão fluindo corretamente do frontend para o backend e sendo usados de forma consistente nas emissões do Socket.IO para ambos os comandos `/youtube` e `/youtube_resumo`.

Vamos prestar atenção para não quebrar o sistema!


==========================================
Conteúdo de linha_de_raciocinio_atualizada.md (caminho: linha_de_raciocinio\linha_de_raciocinio_atualizada.md):
==========================================
# ✅ Fase 1: Núcleo do Sistema (Concluída)

- Implementar streaming contínuo de mensagens usando Socket.IO.
- Gerenciar mensagens por `conversation_id`, garantindo isolamento de salas.
- Criar containers de mensagens únicos por `messageId`, sem duplicações.
- Resolver problemas de limpeza de containers órfãos no `cleanupOrphan`.
- Garantir que a troca de chat não interrompa o streaming em andamento.
- Implementar controle de eventos `join_conversation`, `leave_conversation_safe`.
- Eliminar lógica antiga de cursor que criava containers vazios.
- Introduzir uma animação de carregamento separada (fora do `chat-container`).

**Status:** Concluído.

---

# 🔥 Fase 2: Implementação dos Comandos YouTube

- Reaproveitar o fluxo de streaming já criado para receber respostas de `/youtube` e `/youtube_resumo`.
- Garantir que o sistema trate o processamento de vídeos como uma "resposta em streaming" normal, sem alterar a base de mensagens.
- Isolar também o YouTube por `conversation_id` e `messageId`, exatamente como no chat IA.
- Adaptar a animação de carregamento para funcionar também durante o processamento de vídeos.
- Ajustar a finalização do processo de vídeo para emitir `response_complete` ao final da resposta.
- Garantir que a transição entre vídeos e chats não cause erros ou perda de dados.

**Status:** A iniciar agora.

---

# ✨ Fase 3: Refinamento da Experiência de Usuário (UX)

- Ajustar a animação de carregamento para que ela apareça dentro do fluxo de mensagens (embaixo da mensagem do usuário), de forma integrada.
- Criar novo efeito visual para o início do streaming: "IA está digitando..." (de maneira fluida).
- Melhorar o comportamento do botão "Stop" com `AbortController`, interrompendo o streaming sem travar o sistema.
- Tornar a troca de chats ainda mais fluida, carregando mensagens de forma assíncrona e sem travamentos.
- Corrigir detalhes de scroll automático suave para seguir a resposta da IA.
- Melhorar transições visuais: fade-in nas novas mensagens, animações leves.

**Status:** Planejado para depois da fase 2.

---

# 🛠️ Fase 4: Modularização do Frontend

- Dividir grandes arquivos JavaScript (`chatUI.js`, `streamingManager.js`, `chatActions.js`) em módulos pequenos e coesos.
- Criar diretórios organizados (`/services`, `/components`, `/handlers`, `/utils`).
- Eliminar duplicação de funções.
- Comentar o código explicando função por função (nome, parâmetros, retorno, fluxo).
- Atualizar as importações/exportações entre arquivos.
- Deixar o frontend preparado para possível migração para frameworks modernos no futuro (React, Vue, etc.).

**Status:** Planejado.

---

# 📄 Fase 5: Documentação Completa

- Criar documentação geral do sistema (`README.md` ou um arquivo separado mais completo).
- Explicar a arquitetura de comunicação backend/frontend.
- Explicar o fluxo de mensagens (`message_chunk`, `response_complete`, `leave_conversation_safe`).
- Documentar cada comando disponível: IA padrão, YouTube, Resumo de YouTube.
- Incluir instruções de instalação, execução local, e futuras extensões.
- Anexar prints de fluxo real (opcional) para ilustrar o sistema funcionando.

**Status:** Planejado.

---

# 📌 Resumo Geral de Status Atual

| Fase | Status |
|:---|:---|
| Fase 1: Núcleo do Sistema | ✅ Concluído |
| Fase 2: Comandos YouTube | 🚀 Começando agora |
| Fase 3: UX Refinado | 🔜 Próximo |
| Fase 4: Modularização | 🛠️ Aguardando UX |
| Fase 5: Documentação Final | 📄 Aguardando Modularização |

==========================================
Conteúdo de Plano-implementacao.md (caminho: linha_de_raciocinio\Plano-implementacao.md):
==========================================
# Plano de Implementação - Sistema de Chat com Feedback Visual

## Visão Geral
Este documento apresenta o plano de implementação para resolver os problemas de duplicação de mensagens, melhorar o feedback visual durante o carregamento e aprimorar a arquitetura do sistema de chat.

## Fases de Implementação

### Fase 1: Preparação e Limpeza Inicial (3 Horas)

1. **Revisão do Fluxo Atual (1 Hora)**
   - Mapear os componentes: `streamingManager.js`, `messageRenderer.js`, `chatActions.js` e `messageRegistry`
   - Identificar pontos de geração de IDs e comunicação entre canais
   - Resultado: Diagrama de fluxo do estado atual do sistema

2. **Escolha do Canal Único (1 Hora)**
   - Padronizar usando Socket.IO como meio exclusivo de comunicação
   - Remover código relacionado a SSE (Server-Sent Events) do backend
   - Resultado: Backend mais enxuto e menor chance de duplicação de mensagens

3. **Centralização do messageRegistry (1 Hora)**
   - Criar módulo único para o `messageRegistry`
   - Garantir importação consistente em todos os arquivos
   - Resultado: Sistema de registro de mensagens consistente e confiável

### Fase 2: Implementação da Padronização de IDs (4 Horas)

4. **Geração de UUID no Backend (1 Hora)**
   - Modificar `app.py` para gerar UUID único por mensagem
   - Enviar UUID via Socket.IO com cada mensagem
   - Resultado: IDs consistentes em todo o ciclo da mensagem

5. **Ajuste no Frontend (1 Hora)**
   - Adaptar `streamingManager.js` para usar UUIDs do backend
   - Atualizar `messageRenderer.js` para renderização baseada em UUID
   - Resultado: Frontend alinhado com backend, evitando duplicações

6. **Integração com messageRegistry (1 Hora)**
   - Implementar UUID como chave primária no registry
   - Adicionar verificação de duplicação
   - Resultado: Controle centralizado de mensagens

7. **Testes Básicos (1 Hora)**
   - Testar fluxo de mensagens com UUIDs
   - Verificar se duplicações foram eliminadas
   - Resultado: Confirmação da solução básica funcionando

### Fase 3: Refatoração e Consolidação (4 Horas)

8. **Remoção Completa do SSE (1 Hora)**
   - Eliminar endpoint `/stream` e código relacionado
   - Consolidar toda comunicação via Socket.IO
   - Resultado: Canal único de comunicação

9. **Centralização do Streaming (1 Hora)**
   - Tornar `streamingManager.js` o controlador central de eventos
   - Simplificar relacionamento com `messageRenderer.js`
   - Resultado: Fluxo de streaming mais limpo e organizado

10. **Logs e Verificação (1 Hora)**
    - Implementar sistema de log para ciclo de vida das mensagens
    - Monitorar comportamento do UUID em todo o fluxo
    - Resultado: Verificação em tempo real do funcionamento

11. **Testes de Integração (1 Hora)**
    - Testar cenários complexos: mensagens normais, YouTube, streaming pesado
    - Validar comportamento do sistema sob carga
    - Resultado: Sistema estável em condições reais

### Fase 4: Documentação e Finalização (2 Horas)

12. **Atualização da Documentação (1 Hora)**
    - Documentar nova arquitetura e fluxo de mensagens
    - Criar diagramas atualizados do sistema
    - Resultado: Documentação clara para futura manutenção

13. **Revisão Final (1 Hora)**
    - Revisar implementação completa
    - Testar sistema end-to-end
    - Resultado: Sistema finalizado e estável

## Total: 13 Horas de Implementação

## Diagrama de Fluxo Final

```mermaid
graph TD
    A[Usuário] -->|Envia mensagem| B[Front-end: chat.js]
    B -->|Gera UUID para mensagem| C[messageRegistry.js]
    C -->|Registra mensagem| D[streamingManager.js]
    D -->|Envia via Socket.IO| E[Back-end: app.py]
    E -->|Processa com IA| F[API Ollama]
    F -->|Resposta em streaming| E
    E -->|Envia chunks via Socket.IO| D
    D -->|Atualiza mensagem| C
    C -->|Renderiza mensagem| G[messageRenderer.js]
    G -->|Exibe no chat| H[chatContainer]
    I[YouTube Handler] -->|Processa vídeo, se aplicável| E
    E -->|Salva no histórico| J[chat_storage.py]
    J -->|Persiste em JSON| K[Arquivo de conversa]
```

## Principais Arquivos e Funções

### Frontend
- **chat.js**: Captura mensagens e gerencia interação inicial
- **messageRegistry.js**: Centraliza rastreamento via UUID
- **streamingManager.js**: Gerencia comunicação em tempo real
- **messageRenderer.js**: Renderiza mensagens no chat
- **youtubeHandler.js**: Processa conteúdo do YouTube

### Backend
- **app.py**: Processamento central e integração com IA
- **chat_storage.py**: Persistência do histórico de conversas 

==========================================
Conteúdo de plano_atual_12.05.2025.txt (caminho: linha_de_raciocinio\plano_atual_12.05.2025.txt):
==========================================
﻿Estamos implementando um plano de estabilização para o chat. Já concluímos o primeiro item do checklist e agora vamos avançar para o segundo. Vou contextualizá-lo e peço que você leia alguns arquivos do sistema, cujas orientações estão no final desta mensagem.


—--
✅ Plano de Ação para Estabilização do Sistema de Chat
🧩 Etapas técnicas em ordem de execução
* [✅] Identificar o ponto de geração do messageId no frontend
Descobrir onde o ID está sendo criado e verificar se há duplicações.
* [ ] Centralizar a geração do messageId no frontend
Escolher um único local para gerar o ID e padronizar seu formato.
* [ ] Garantir que o messageId seja enviado junto com a mensagem
Confirmar que o ID está presente em todas as comunicações com o backend.
* [ ] Ajustar o backend para usar o messageId fornecido pelo frontend
Backend deve apenas reutilizar o ID — nunca gerar outro.
* [ ] Corrigir o fluxo de streaming da resposta da IA
Validar o recebimento e renderização correta dos chunks de resposta.
* [ ] Verificar e eliminar duplicação de mensagens de usuário
Consolidar as funções que adicionam mensagens no DOM.
* [ ] Validar a lógica de exibição do feedback de carregamento ("três pontinhos")
Confirmar funcionamento correto e dar um nome técnico apropriado (ex: streamingIndicator).
* [ ] Consolidar funções duplicadas e reorganizar utilitários
Criar arquivos únicos para utilitários e centralizar lógica repetida.
* [ ] Estabilizar o sistema com logs objetivos e informativos
Usar logs para acompanhar o ciclo de vida de cada messageId.
* [ ] Iniciar testes automatizados (depois da estabilização)
Começar com testes unitários de funções puras, e depois simular o fluxo de conversa completo.


—--


**Resumo Contextualizado para Fase 2:**


### **Problemas Críticos Identificados:**
1. **Duplicação de IDs**  
   - Dois padrões coexistem: `user_...` (frontend) e `msg-...` (backend).  
   - Mensagens do usuário e respostas da IA são tratadas como entidades separadas, causando duplicação visual.


2. **Falta de Sincronia entre Frontend/Backend**  
   - O backend não reutiliza o `messageId` enviado pelo frontend.  
   - Eventos Socket.IO (`process_message`, `message_chunk`) não estão alinhados, gerando conflitos.


3. **Comandos `/youtube` e `/youtube_resumo`**  
   - Não seguem o pipeline do chat (ex: salvam chunks intermediários).  
   - Usam `userMessageId` em vez de `msg-...`, quebrando a consistência.


4. **Gerenciamento de Estado Frágil**  
   - `messageRegistry` é um singleton, mas não limpa registros de conversas antigas.  
   - `cleanupOrphan()` remove containers vazios, mas não trata mensagens recebidas após troca de conversa.


5. **Feedback Visual Inconsistente**  
   - Placeholder ("três pontinhos") não é removido após o primeiro chunk.  
   - Código antigo comentado ainda interfere na renderização.


---


### **Prioridades para Fase 2:**
1. **Unificar a Geração de IDs**  
   - Eliminar `user_...` e usar **exclusivamente** `msg-...` em todo o sistema.  
   - Centralizar a geração em `messageRegistry.js` e remover código duplicado em `chatActions.js`.


2. **Alinhar Comunicação Frontend/Backend**  
   - Garantir que o backend **reutilize** o `messageId` recebido do frontend em todos os eventos.  
   - Validar IDs no backend para evitar duplicações.


3. **Reestruturar Comandos `/youtube` e `/youtube_resumo`**  
   - Integrar esses comandos ao pipeline do chat (mesmo fluxo de `messageId` e streaming).  
   - Remover salvamento intermediário de chunks no backend.


4. **Melhorar Gerenciamento de Estado**  
   - Implementar limpeza automática de registros antigos no `messageRegistry`.  
   - Tratar mensagens recebidas após a troca de conversa como inválidas.


5. **Ajustar Feedback Visual**  
   - Remover código residual do placeholder antigo.  
   - Atualizar o indicador de carregamento para desaparecer no primeiro chunk.


---


### **Passos Imediatos:**
1. **Remover Código Duplicado**  
   - Eliminar `userMessageId` e usar `messageRegistry.generateMessageId()` em todo o frontend.  
   - Atualizar `chatActions.js` e `youtubeHandler.js` para usar o mesmo gerador.


2. **Validar Fluxo de IDs**  
   - Adicionar logs em ambas as camadas para rastrear `messageId` desde o envio até a resposta.  
   - Garantir que o backend **nunca** gere um novo ID.


3. **Testar Comandos do YouTube**  
   - Verificar se `/youtube` e `/youtube_resumo` usam o mesmo `messageId` do chat.  
   - Corrigir a renderização para seguir o padrão de chunks incrementais.


4. **Revisar `cleanupOrphan()`**  
   - Ajustar a função para remover mensagens órfãs mesmo após troca de conversa.  
   - Adicionar logs para monitorar remoções.


---


**Próximo passo sugerido:**  
Implementar a **centralização do `messageId`** e testar o fluxo completo de uma mensagem (envio, processamento, streaming, resposta). Isso resolverá a maioria das duplicações e preparará o sistema para ajustes nos comandos do YouTube.




—-------


**Relatório Resumido das Tentativas na Fase 2**  
*(Problemas enfrentados, soluções propostas, falhas identificadas e lições aprendidas)*  


---


### **Contexto da Fase 2**  
O objetivo era **alinhar os comandos `/youtube` e `/youtube_resumo` ao fluxo padrão do chat com IA**, garantindo:  
- Geração única de `messageId` pelo frontend.  
- Streaming de respostas em tempo real (chunks).  
- Renderização consistente no DOM.  
- Eliminação de duplicações e containers órfãos.  


---


### **Tentativas Realizadas**  


#### **1. Padronização de `messageId`**  
- **O que foi feito:**  
  Tentou-se centralizar a geração de IDs no `messageRegistry.js`, substituindo códigos redundantes em `youtubeHandler.js` e `chatActions.js`.  
- **Falha identificada:**  
  O backend (`app.py`) não estava validando se o `messageId` recebido era único ou consistente, permitindo que IDs duplicados ou mal formatados fossem processados.  
- **Causa raiz:**  
  Falta de comunicação clara entre frontend e backend sobre o ciclo de vida do ID (ex: o backend não rejeitava IDs já em uso).  


---


#### **2. Sincronização de Eventos Socket.IO**  
- **O que foi feito:**  
  Implementaram-se eventos como `message_chunk` e `response_complete` para replicar o padrão do chat com IA.  
- **Falha identificada:**  
  Mensagens do usuário não apareciam imediatamente após o envio, e chunks da IA não eram renderizados.  
- **Causa raiz:**  
  Eventos do frontend (ex: `user_message`) não estavam alinhados com os eventos esperados pelo backend (ex: `process_message`). O frontend emitia dados com nomes de eventos inconsistentes.  


---


#### **3. Renderização de Mensagens do Usuário**  
- **O que foi feito:**  
  Tentou-se renderizar a mensagem do usuário imediatamente após o envio, usando `createMessageContainer`.  
- **Falha identificada:**  
  A mensagem do usuário não aparecia até o backend processar a resposta, causando a impressão de "mensagem perdida".  
- **Causa raiz:**  
  A função de renderização do usuário estava condicionada ao retorno do backend, em vez de ser executada imediatamente após o envio.  


---


#### **4. Gerenciamento de Estado (`messageRegistry`)**  
- **O que foi feito:**  
  Adicionou-se uma verificação de duplicidade no `messageRegistry` para evitar múltiplas mensagens com o mesmo conteúdo.  
- **Falha identificada:**  
  A verificação não era eficaz, pois dependia de timestamps (2 segundos), o que não cobria casos de latência ou processamento lento.  
- **Causa raiz:**  
  A lógica de validação era baseada em tempo, não em IDs ou estados transacionais.  


---


#### **5. Comandos `/youtube` e `/youtube_resumo`**  
- **O que foi feito:**  
  Tentou-se replicar a lógica do chat com IA para os comandos do YouTube, incluindo streaming de transcrições e resumos.  
- **Falha identificada:**  
  - `/youtube`: A mensagem do usuário só aparecia após o processamento completo.  
  - `/youtube_resumo`: A resposta final era duplicada.  
- **Causa raiz:**  
  - O frontend não renderizava a mensagem do usuário imediatamente.  
  - O backend emitia múltiplos eventos `response_complete` para o mesmo `messageId`.  


---


#### **6. Logs e Diagnóstico**  
- **O que foi feito:**  
  Adicionaram-se logs detalhados em frontend e backend para rastrear o fluxo de `messageId`.  
- **Falha identificada:**  
  Os logs não mostravam erros claros, mas revelaram que IDs diferentes eram usados para a mesma interação.  
- **Causa raiz:**  
  Logs estavam desconectados entre frontend e backend (ex: o frontend usava `messageId`, mas o backend registrava `message_id`).  


---


### **Lições Aprendidas**  
1. **Eventos Socket.IO devem ter nomes rigorosamente padronizados** (ex: `process_message` em vez de `user_message`).  
2. **O `messageId` deve ser validado em todas as camadas** (frontend/backend) para garantir unicidade.  
3. **Renderização imediata da mensagem do usuário** é essencial para feedback visual (não esperar o backend).  
4. **Verificações de duplicidade** devem usar IDs, não conteúdo ou timestamps.  
5. **Logs precisam ser estruturados e compartilhados** entre frontend e backend para diagnóstico eficaz.  


---


### **Recomendações para a Próxima Abordagem**  
1. **Começar pela base:**  
   - Garantir que frontend e backend usem os **mesmos nomes de eventos** e **formato de `messageId`**.  
   - Validar IDs no backend antes de processar qualquer mensagem.  


2. **Simplificar o fluxo:**  
   - Renderizar a mensagem do usuário **imediatamente** no frontend, usando o `messageId` gerado.  
   - Usar um único handler para todos os eventos de streaming (evitar código duplicado para `/youtube` e chat normal).  


3. **Centralizar o estado:**  
   - Criar um `MessageManager` no frontend para controlar todas as interações (evitar múltiplos registros).  
   - Garantir que o backend use um cache de IDs ativos para evitar processamento duplicado.  


4. **Testes manuais rigorosos:**  
   - Verificar se o `messageId` aparece em **todos os logs** (frontend/backend) durante uma interação.  
   - Testar troca de conversas durante o streaming para confirmar isolamento por `conversationId`.  


---


### **Conclusão**  
A Fase 2 enfrentou falhas principalmente devido a **inconsistências de nomenclatura**, **falta de validação de IDs** e **sincronia frágil entre frontend/backend**. A próxima tentativa deve priorizar a **padronização rigorosa de eventos**, **gerenciamento centralizado de estado** e **validação transacional de IDs** antes de avançar para funcionalidades complexas como streaming.  


Se desejar, podemos iniciar a nova fase com um checklist simplificado, focando em resolver esses pontos críticos primeiro.


—------------


Por favor, leia atentamente o arquivo "arvore de funcoes.md" por completo, integrando as informações com a linha de raciocínio apresentada. Em seguida, analise todo o sistema também em conjunto com essa linha de raciocínio.
leia a pasta interira linha de  raciocinio

==========================================
Conteúdo de README.md (caminho: linha_de_raciocinio\README.md):
==========================================
# Documentação do Projeto - Sistema de Chat com IA

## 1. Visão Geral do Projeto

### Descrição Geral
O projeto é um sistema de chat interativo que utiliza inteligência artificial para gerar respostas contextualizadas. É baseado em uma arquitetura cliente-servidor usando Flask como backend e uma interface web responsiva.'

### Objetivo e Funcionalidades Principais
- Fornecer uma interface de chat intuitiva para interação com IA
- Gerenciar histórico de conversas
- Permitir criação de novas conversas
- Suportar temas claro/escuro
- Salvar conversas em arquivos JSON para persistência

### Tecnologias Utilizadas
- **Backend**: Python/Flask
- **Frontend**: HTML, CSS, JavaScript
- **Armazenamento**: Sistema de arquivos (JSON)
- **IA**: Integração com modelo de linguagem

## 2. Árvore de Diretórios

```
Projeto/
├── app.py                     # Aplicação principal Flask
├── static/
│   ├── css/                  # Estilos da aplicação
│   │   ├── styles.css       # Estilos principais
│   │   ├── base/           # Estilos base
│   │   ├── components/     # Estilos de componentes
│   │   ├── layout/        # Estilos de layout
│   │   └── themes/        # Temas claro/escuro
│   │
│   └── js/                   # Scripts JavaScript
│       ├── main.js          # Script principal
│       ├── chat.js         # Lógica do chat
│       ├── sidebar.js      # Controle da barra lateral
│       ├── theme.js        # Controle de tema
│       ├── events.js       # Gerenciamento de eventos
│       ├── init.js         # Inicialização
│       └── utils.js        # Funções utilitárias
│
├── templates/
│   └── index.html            # Template principal
│
├── utils/
│   ├── chat_storage.py      # Gerenciamento de armazenamento
│   ├── chat_history.py      # Manipulação do histórico
│   └── text_processor.py    # Processamento de texto
│
└── data/                     # Diretório de dados
    └── conversations/        # Armazenamento de conversas

```

## 3. Descrição Detalhada das Funções

### Backend (app.py)

#### Rotas Principais:
- `@app.route('/')`: Renderiza a página inicial
- `@app.route('/send_message')`: Processa mensagens e retorna respostas da IA
- `@app.route('/get_conversation_history')`: Retorna histórico de conversas
- `@app.route('/get_conversation/<conversation_id>')`: Obtém conversa específica

#### Funções de Processamento:
- `process_with_ai(text)`: Processa texto com IA
- `process_with_ai_stream(text)`: Versão streaming do processamento

### Utilitários (utils/)

#### chat_storage.py:
- `ensure_directories()`: Garante existência dos diretórios necessários
- `create_new_conversation()`: Cria nova conversa
- `save_conversation()`: Salva conversa em arquivo
- `get_conversation_by_id()`: Recupera conversa por ID

#### chat_history.py:
- `get_conversation_history()`: Obtém histórico completo
- `save_conversation()`: Salva conversa no histórico
- `get_conversation_by_id()`: Busca conversa específica

### Frontend (static/js/)

#### main.js:
- Inicialização da aplicação
- Gerenciamento de estado global
- Configuração de event listeners

#### chat.js:
- `iniciarChat()`: Inicia nova sessão de chat
- `enviarMensagem()`: Envia mensagem para o backend
- `adicionarMensagem()`: Adiciona mensagem na interface
- `carregarConversa()`: Carrega conversa existente

## 4. Fluxo de Execução

1. **Inicialização**:
   - Servidor Flask inicia (app.py)
   - Diretórios são verificados/criados
   - Interface web é carregada

2. **Interação do Usuário**:
   - Usuário inicia nova conversa ou carrega existente
   - Mensagens são enviadas via interface
   - Backend processa com IA
   - Respostas são exibidas em tempo real

3. **Armazenamento**:
   - Conversas são salvas automaticamente
   - Histórico é mantido em arquivos JSON
   - Dados persistem entre sessões

## 5. Estrutura do Código

O projeto segue uma arquitetura MVC simplificada:
- **Modelo**: Gerenciamento de dados em JSON
- **Visão**: Templates HTML e estilos CSS
- **Controlador**: Rotas Flask e lógica JavaScript

### Boas Práticas:
- Separação de responsabilidades
- Modularização do código
- Armazenamento persistente
- Tratamento de erros

## 6. Instruções de Instalação

1. **Preparação do Ambiente**:
```bash
# Criar ambiente virtual
python -m venv venv

# Ativar ambiente
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Instalar dependências
pip install -r requirements.txt
```

2. **Configuração**:
- Garantir que Python 3.6+ está instalado
- Verificar permissões de escrita no diretório data/

3. **Execução**:
```bash
python app.py
```
- Acessar http://localhost:5000 no navegador

## 7. Evolução do Projeto e Linha de Raciocínio

### Problema Inicial: Duplicação de Mensagens no Streaming
Nosso principal desafio foi a duplicação de mensagens no DOM durante o streaming de respostas da IA. Após análise detalhada, identificamos duas causas principais:

1. **Sistemas Concorrentes de Renderização:**
   - Streaming em tempo real via `message_chunk`
   - Renderização final completa via `response_complete`
   - Estes sistemas criavam containers independentes para a mesma mensagem

2. **Inconsistência de IDs:**
   - O `messageId` gerado no streaming não era reutilizado na renderização final
   - Após reiniciar o servidor, os containers antigos permaneciam órfãos no DOM

### Evolução da Solução

#### Fase 1: Diagnóstico e Primeira Abordagem
Inicialmente, tentamos resolver o problema implementando um sistema de cache simples:
```javascript
const messageCache = new Map();

export const renderMessageChunk = (messageId, chunk) => {
    // Busca container existente ou cria novo
    // Acumula chunks no cache
    // Renderiza conteúdo acumulado
};
```

Esta abordagem funcionava em sessões contínuas, mas falhava após reinícios do servidor, pois o estado do cache era perdido.

#### Fase 2: Gerenciamento de Estado Global
Evoluímos para um sistema mais robusto com estas características:
1. **Registro Global de Mensagens:** Um Map central para controlar todas as mensagens ativas
2. **Identificadores Únicos:** Uso consistente do mesmo `messageId` em todo o ciclo da mensagem
3. **Limpeza Automática:** Sistema para detectar e remover containers órfãos
4. **Monitoramento:** Logs detalhados do ciclo de vida das mensagens

#### Fase 3: Arquitetura Unificada
Nossa solução atual visa uma abordagem completamente unificada:
1. **Fluxo Único:** Um único sistema de renderização do início ao fim da mensagem
2. **Estado Compartilhado:** `messageRegistry` compartilhado entre módulos
3. **Limpeza Preventiva:** Remoção automática de containers vazios a cada 5 segundos
4. **Resistência a Reinícios:** Mecanismos para lidar com estado entre reinicializações

### Lições Aprendidas

1. **Importância da Consistência de IDs:**
   - O mesmo identificador deve ser usado em todo o ciclo de vida da mensagem
   - A geração de IDs deve ser determinística ou persistente entre reinícios

2. **Desafios do Streaming em Tempo Real:**
   - Eventos assíncronos podem chegar fora de ordem ou duplicados
   - É necessário um mecanismo robusto para detectar e ignorar duplicações

3. **Gerenciamento de Estado:**
   - Estado global deve ser compartilhado entre módulos relevantes
   - Mecanismos de limpeza automática são essenciais para evitar vazamentos de memória

4. **Importância da Depuração:**
   - Logs detalhados são cruciais para identificar problemas sutis
   - Um sistema centralizado de logs facilita o diagnóstico

### Próximos Passos

1. **Resolução de Problemas Pendentes:**
   - Corrigir o erro de referência: `messageRegistry is not defined`
   - Implementar um sistema de log centralizado e mais detalhado
   - Garantir limpeza consistente de estado entre reinicializações

2. **Melhorias Planejadas:**
   - Refatorar o código para uma arquitetura mais modular
   - Implementar testes automatizados para validar comportamento
   - Melhorar a experiência do usuário com feedback visual durante o streaming
   - Implementar mecanismos de recuperação de falhas

3. **Documentação e Manutenção:**
   - Atualizar a documentação com decisões de design e lições aprendidas
   - Implementar um sistema de versionamento mais rigoroso
   - Melhorar a colaboração entre diferentes inteligências artificiais e desenvolvedores humanos

## 8. Considerações Finais

### Melhorias Sugeridas:
1. Implementar autenticação de usuários
2. Adicionar suporte a múltiplos modelos de IA
3. Melhorar sistema de backup de conversas
4. Implementar busca no histórico
5. Adicionar suporte a markdown nas mensagens

### Funcionalidades Futuras:
1. Exportação de conversas em diferentes formatos
2. Compartilhamento de conversas
3. Personalização avançada da interface
4. Integração com APIs externas
5. Sistema de tags para organização


==========================================
Conteúdo de resolucao-problemas-limpeza-mensagens.md (caminho: linha_de_raciocinio\resolucao-problemas-limpeza-mensagens.md):
==========================================
# Resolução de Problemas: Limpeza Indevida de Mensagens

## Problema Identificado

Após a implementação do sistema de streaming contínuo durante a troca de chat, identificamos um problema crítico: o sistema estava removendo indevidamente containers de mensagens completas da IA durante a limpeza de containers órfãos. Isso acontecia porque:

1. A lógica de `cleanOrphanContainers` no `messageRegistry.js` não distinguia adequadamente entre diferentes tipos de containers
2. Containers válidos com respostas completas da IA eram removidos durante operações de limpeza
3. Ocorriam erros durante o processamento de `marked()` com conteúdo potencialmente indefinido

## Solução Implementada

### 1. Flags Adicionais no MessageRegistry

Introduzimos duas novas flags para gerenciar o ciclo de vida dos containers:

- `isCursor`: Marca containers temporários usados apenas para animação
- `isComplete`: Flag explícita que indica se uma mensagem foi finalizada com sucesso

Estas flags são mais robustas que a anterior `isStreaming`, permitindo distinguir entre:
- Containers de cursor temporário
- Mensagens em processo de streaming
- Mensagens completas que nunca devem ser removidas

### 2. Nova Lógica de Limpeza

A função `cleanOrphanContainers` foi completamente reescrita seguindo as seguintes regras:

1. NUNCA remover containers com `isComplete=true`
2. Remover cursores inativos (`isCursor=true` e `isStreaming=false`)
3. Remover containers vazios não completos e não em streaming
4. Para containers não registrados, verificar classes para determinar se são temporários

### 3. Sistema de Cursor Independente

Criamos um sistema de cursor completamente separado do `messageRegistry`:

- Novo módulo `cursorManager.js` para gerenciar cursores de digitação
- Cursor removido automaticamente quando o primeiro chunk real é recebido
- CSS animado em arquivo separado `cursor.css`
- Evita conflitos com o sistema de mensagens real

### 4. Tratamento de Erros

Adicionamos tratamento robusto de erros e fallbacks:

- Verificação explícita de `content` vazio antes de renderizar Markdown
- Garantia que `isComplete=true` é definido mesmo em caso de erro de renderização
- Registro de logs para facilitar depuração em caso de problemas futuros

## Benefícios da Implementação

1. **Preservação de Mensagens**: Respostas da IA nunca são removidas indevidamente
2. **Clareza Visual**: Cursores temporários são claramente separados do conteúdo real
3. **Robustez**: Tratamento adequado de erros e estados inconsistentes
4. **Melhor UX**: Feedback visual imediato quando o usuário envia uma mensagem
5. **Base para Evolução**: Estrutura modular que permite refinar a animação de digitação na fase 3

## Teste e Validação

Para testar estas mudanças:

1. Inicie uma conversação e envie uma mensagem
2. Observe o cursor de "três pontinhos" enquanto aguarda resposta
3. Quando o primeiro chunk chegar, verifique se o cursor desaparece e a resposta começa a ser renderizada
4. Troque de conversa durante o streaming e depois volte
5. Verifique se a resposta completa permanece visível e não é removida

## Próximos Passos

1. Refinar a animação do cursor na fase 3
2. Aplicar a mesma separação de responsabilidades no processamento do YouTube
3. Continuar a modularização do código em arquivos mais específicos
4. Melhorar as transições visuais entre cursor e conteúdo real 


==========================================
Conteúdo de README.md (caminho: README.md):
==========================================
# Documentação do Projeto - Sistema de Chat com IA

## 1. Visão Geral do Projeto

### Descrição Geral
O projeto é um sistema de chat interativo que utiliza inteligência artificial para gerar respostas contextualizadas. É baseado em uma arquitetura cliente-servidor usando Flask como backend e uma interface web responsiva.

### Objetivo e Funcionalidades Principais
- Fornecer uma interface de chat intuitiva para interação com IA
- Gerenciar histórico de conversas
- Permitir criação de novas conversas
- Suportar temas claro/escuro
- Salvar conversas em arquivos JSON para persistência

### Tecnologias Utilizadas
- **Backend**: Python/Flask
- **Frontend**: HTML, CSS, JavaScript
- **Armazenamento**: Sistema de arquivos (JSON)
- **IA**: Integração com modelo de linguagem

## 2. Árvore de Diretórios

```
Projeto/
├── app.py                     # Aplicação principal Flask
├── static/
│   ├── css/                  # Estilos da aplicação
│   │   ├── styles.css       # Estilos principais
│   │   ├── base/           # Estilos base
│   │   ├── components/     # Estilos de componentes
│   │   ├── layout/        # Estilos de layout
│   │   └── themes/        # Temas claro/escuro
│   │
│   └── js/                   # Scripts JavaScript
│       ├── main.js          # Script principal
│       ├── chat.js         # Lógica do chat
│       ├── sidebar.js      # Controle da barra lateral
│       ├── theme.js        # Controle de tema
│       ├── events.js       # Gerenciamento de eventos
│       ├── init.js         # Inicialização
│       └── utils.js        # Funções utilitárias
│
├── templates/
│   └── index.html            # Template principal
│
├── utils/
│   ├── chat_storage.py      # Gerenciamento de armazenamento
│   ├── chat_history.py      # Manipulação do histórico
│   └── text_processor.py    # Processamento de texto
│
└── data/                     # Diretório de dados
    └── conversations/        # Armazenamento de conversas

```

## 3. Descrição Detalhada das Funções

### Backend (app.py)

#### Rotas Principais:
- `@app.route('/')`: Renderiza a página inicial
- `@app.route('/send_message')`: Processa mensagens e retorna respostas da IA
- `@app.route('/get_conversation_history')`: Retorna histórico de conversas
- `@app.route('/get_conversation/<conversation_id>')`: Obtém conversa específica

#### Funções de Processamento:
- `process_with_ai(text)`: Processa texto com IA
- `process_with_ai_stream(text)`: Versão streaming do processamento

### Utilitários (utils/)

#### chat_storage.py:
- `ensure_directories()`: Garante existência dos diretórios necessários
- `create_new_conversation()`: Cria nova conversa
- `save_conversation()`: Salva conversa em arquivo
- `get_conversation_by_id()`: Recupera conversa por ID

#### chat_history.py:
- `get_conversation_history()`: Obtém histórico completo
- `save_conversation()`: Salva conversa no histórico
- `get_conversation_by_id()`: Busca conversa específica

### Frontend (static/js/)

#### main.js:
- Inicialização da aplicação
- Gerenciamento de estado global
- Configuração de event listeners

#### chat.js:
- `iniciarChat()`: Inicia nova sessão de chat
- `enviarMensagem()`: Envia mensagem para o backend
- `adicionarMensagem()`: Adiciona mensagem na interface
- `carregarConversa()`: Carrega conversa existente

## 4. Fluxo de Execução

1. **Inicialização**:
   - Servidor Flask inicia (app.py)
   - Diretórios são verificados/criados
   - Interface web é carregada

2. **Interação do Usuário**:
   - Usuário inicia nova conversa ou carrega existente
   - Mensagens são enviadas via interface
   - Backend processa com IA
   - Respostas são exibidas em tempo real

3. **Armazenamento**:
   - Conversas são salvas automaticamente
   - Histórico é mantido em arquivos JSON
   - Dados persistem entre sessões

## 5. Estrutura do Código

O projeto segue uma arquitetura MVC simplificada:
- **Modelo**: Gerenciamento de dados em JSON
- **Visão**: Templates HTML e estilos CSS
- **Controlador**: Rotas Flask e lógica JavaScript

### Boas Práticas:
- Separação de responsabilidades
- Modularização do código
- Armazenamento persistente
- Tratamento de erros

## 6. Instruções de Instalação

1. **Preparação do Ambiente**:
```bash
# Criar ambiente virtual
python -m venv venv

# Ativar ambiente
# Windows:
venv\Scripts\activate
# Linux/Mac:
source venv/bin/activate

# Instalar dependências
pip install -r requirements.txt
```

2. **Configuração**:
- Garantir que Python 3.6+ está instalado
- Verificar permissões de escrita no diretório data/

3. **Execução**:
```bash
python app.py
```
- Acessar http://localhost:5000 no navegador

## 7. Evolução do Projeto e Linha de Raciocínio

### Problema Inicial: Duplicação de Mensagens no Streaming
Nosso principal desafio foi a duplicação de mensagens no DOM durante o streaming de respostas da IA. Após análise detalhada, identificamos duas causas principais:

1. **Sistemas Concorrentes de Renderização:**
   - Streaming em tempo real via `message_chunk`
   - Renderização final completa via `response_complete`
   - Estes sistemas criavam containers independentes para a mesma mensagem

2. **Inconsistência de IDs:**
   - O `messageId` gerado no streaming não era reutilizado na renderização final
   - Após reiniciar o servidor, os containers antigos permaneciam órfãos no DOM

### Evolução da Solução

#### Fase 1: Diagnóstico e Primeira Abordagem
Inicialmente, tentamos resolver o problema implementando um sistema de cache simples:
```javascript
const messageCache = new Map();

export const renderMessageChunk = (messageId, chunk) => {
    // Busca container existente ou cria novo
    // Acumula chunks no cache
    // Renderiza conteúdo acumulado
};
```

Esta abordagem funcionava em sessões contínuas, mas falhava após reinícios do servidor, pois o estado do cache era perdido.

#### Fase 2: Gerenciamento de Estado Global
Evoluímos para um sistema mais robusto com estas características:
1. **Registro Global de Mensagens:** Um Map central para controlar todas as mensagens ativas
2. **Identificadores Únicos:** Uso consistente do mesmo `messageId` em todo o ciclo da mensagem
3. **Limpeza Automática:** Sistema para detectar e remover containers órfãos
4. **Monitoramento:** Logs detalhados do ciclo de vida das mensagens

#### Fase 3: Arquitetura Unificada
Nossa solução atual visa uma abordagem completamente unificada:
1. **Fluxo Único:** Um único sistema de renderização do início ao fim da mensagem
2. **Estado Compartilhado:** `messageRegistry` compartilhado entre módulos
3. **Limpeza Preventiva:** Remoção automática de containers vazios a cada 5 segundos
4. **Resistência a Reinícios:** Mecanismos para lidar com estado entre reinicializações

### Lições Aprendidas

1. **Importância da Consistência de IDs:**
   - O mesmo identificador deve ser usado em todo o ciclo de vida da mensagem
   - A geração de IDs deve ser determinística ou persistente entre reinícios

2. **Desafios do Streaming em Tempo Real:**
   - Eventos assíncronos podem chegar fora de ordem ou duplicados
   - É necessário um mecanismo robusto para detectar e ignorar duplicações

3. **Gerenciamento de Estado:**
   - Estado global deve ser compartilhado entre módulos relevantes
   - Mecanismos de limpeza automática são essenciais para evitar vazamentos de memória

4. **Importância da Depuração:**
   - Logs detalhados são cruciais para identificar problemas sutis
   - Um sistema centralizado de logs facilita o diagnóstico

### Próximos Passos

1. **Resolução de Problemas Pendentes:**
   - Corrigir o erro de referência: `messageRegistry is not defined`
   - Implementar um sistema de log centralizado e mais detalhado
   - Garantir limpeza consistente de estado entre reinicializações

2. **Melhorias Planejadas:**
   - Refatorar o código para uma arquitetura mais modular
   - Implementar testes automatizados para validar comportamento
   - Melhorar a experiência do usuário com feedback visual durante o streaming
   - Implementar mecanismos de recuperação de falhas

3. **Documentação e Manutenção:**
   - Atualizar a documentação com decisões de design e lições aprendidas
   - Implementar um sistema de versionamento mais rigoroso
   - Melhorar a colaboração entre diferentes inteligências artificiais e desenvolvedores humanos

## 8. Considerações Finais

### Melhorias Sugeridas:
1. Implementar autenticação de usuários
2. Adicionar suporte a múltiplos modelos de IA
3. Melhorar sistema de backup de conversas
4. Implementar busca no histórico
5. Adicionar suporte a markdown nas mensagens

### Funcionalidades Futuras:
1. Exportação de conversas em diferentes formatos
2. Compartilhamento de conversas
3. Personalização avançada da interface
4. Integração com APIs externas
5. Sistema de tags para organização



==========================================
Conteúdo de reset.css (caminho: static\css\base\reset.css):
==========================================
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    transition: background-color 0.2s, color 0.2s;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
}

==========================================
Conteúdo de typography.css (caminho: static\css\base\typography.css):
==========================================
body {
    font-family: 'Inter', sans-serif;
    color: var(--text-primary);
}

h1, h2, h3, h4, h5, h6 {
    color: var(--text-primary);
}

==========================================
Conteúdo de variables.css (caminho: static\css\base\variables.css):
==========================================

:root {
    /* Cores primárias */
    --bg-primary: #f9f9fb;
    --text-primary: #202123;
    --text-secondary: rgba(32, 33, 35, 0.75);
    --text-disabled: rgba(32, 33, 35, 0.5);
    
    /* Cores de ação */
    --action-active: #202123;
    --action-hover: rgba(0, 0, 0, 0.05);
    --action-selected: rgba(0, 0, 0, 0.08);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    
    /* Cores de mensagem */
    --msg-user: #f0f0f0;
    --msg-bot: #e6e6e6;
    
    /* Cores de UI */
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: #ebebeb;
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    
    /* Cor de acento e status */
    --accent-color: #6B7280;
    --accent-color-rgb: 107, 114, 128;
    --accent-hover: #374151;
    --accent-text: #ffffff;
    --color-success: #4CAF50;
    
    /* Efeitos - removidos */
    --box-shadow: none;
    --box-shadow-hover: none;
    --transition-speed: 0.2s;
    
    /* Arredondamento */
    --border-radius-sm: 6px;
    --border-radius-md: 8px;
    --border-radius-lg: 12px;
}

[data-theme="dark"] {
    /* Cores primárias */
    --bg-primary: #1A1A1A;
    --text-primary: #FFFFFF;
    --text-secondary: rgba(255, 255, 255, 0.75);
    --text-disabled: rgba(255, 255, 255, 0.5);
    
    /* Cores de ação */
    --action-active: #ffffff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.12);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    
    /* Cores de mensagem */
    --msg-user: #2c2c30;
    --msg-bot: #27272b;
    
    /* Cores de UI */
    --sidebar-bg: #151517;
    --input-bg: #2c2c30;
    --border-color: #2c2c30;
    --code-bg: #27272b;
    --code-header-bg: #2c2c30;
    
    /* Cor de acento e status */
    --accent-color: #00FF99;
    --accent-color-rgb: 0, 255, 153;
    --accent-hover: #00E589;
    --accent-text: #000000;
    --color-success: #4CAF50;
    
    /* Efeitos - removidos */
    --box-shadow: none;
    --box-shadow-hover: none;
}


==========================================
Conteúdo de buttons.css (caminho: static\css\components\buttons.css):
==========================================
.new-chat-btn {
    background-color: #333333;
    color: #ffffff;
    border: none;
    padding: 12px 16px;
    border-radius: 8px;
    cursor: pointer;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    font-weight: 500;
    transition: background-color 0.2s, transform 0.1s;
    box-shadow: none;
}

.new-chat-btn:hover {
    background-color: #444444;
}

.new-chat-btn:active {
    transform: none;
}

.settings-btn {
    margin-top: auto;
    padding: 12px;
    border: none;
    border-radius: 8px;
    background-color: transparent;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    transition: background-color 0.2s;
    font-weight: 500;
}

.settings-btn:hover {
    background-color: var(--action-hover);
}

.theme-toggle, .header-sidebar-toggle {
    width: 38px;
    height: 38px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: var(--text-primary);
    cursor: pointer;
    transition: background-color 0.2s;
}

.theme-toggle:hover, .header-sidebar-toggle:hover {
    background: var(--action-hover);
    transform: none;
}

.theme-toggle:active, .header-sidebar-toggle:active {
    transform: none;
}

.quick-action-btn {
    padding: 1rem 1.25rem;
    border: none;
    border-radius: 10px;
    background-color: #444444;
    color: #ffffff;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    transition: all 0.2s;
    font-weight: 500;
    box-shadow: none;
}

.quick-action-btn:hover {
    background-color: #555555;
}

.quick-action-btn:active {
    transform: none;
}

.quick-action-btn i {
    color: #ffffff;
    font-size: 1.1rem;
}

/* Estilo para botões de ação nas mensagens */
.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    opacity: 0.7;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
    opacity: 1;
}

/* Estilo para botão de envio - modificado para circular com seta para cima */
.send-btn {
    background-color: #ffffff;
    color: #000000;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: none;
    padding: 0;
    transition: background-color 0.2s;
}

.send-btn:hover {
    background-color: #f0f0f0;
}

[data-theme="dark"] .send-btn {
    background-color: #ffffff;
    color: #000000;
}

[data-theme="dark"] .send-btn:hover {
    background-color: #f0f0f0;
}

/* Estilo para botão de parar */
.stop-btn {
    color: var(--text-secondary);
    background: transparent;
    border: none;
}

.stop-btn:hover {
    color: var(--text-primary);
}

/* Estilo para botões de ação específicos */
.copy-btn:hover {
    color: var(--accent-color);
}

.regenerate-btn:hover {
    color: var(--accent-color);
}

/* Estilo para menu de três pontos nos chats */
.chat-item .more-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    opacity: 0;
    transition: opacity 0.2s;
    padding: 4px;
    cursor: pointer;
}

.chat-item:hover .more-btn {
    opacity: 1;
}

/* Menu dropdown para os três pontos */
.chat-options-menu {
    position: absolute;
    right: 10px;
    background-color: var(--input-bg);
    border-radius: var(--border-radius-md);
    border: 1px solid var(--border-color);
    z-index: 100;
    display: none;
    min-width: 150px;
    box-shadow: none;
}

.chat-options-menu.visible {
    display: block;
}

.chat-option-item {
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-primary);
}

.chat-option-item:hover {
    background-color: var(--action-hover);
}

.chat-option-icon {
    color: var(--text-secondary);
    width: 16px;
}


==========================================
Conteúdo de code-highlight.css (caminho: static\css\components\code-highlight.css):
==========================================

/* Container para blocos de código */
.code-container {
    position: relative;
    margin: 1rem 0;
    border-radius: 6px;
    overflow: hidden;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    border: 1px solid var(--border-color);
}

/* Cabeçalho do bloco de código */
.code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background-color: #2d2d2d !important; /* Cabeçalho um pouco mais claro que o fundo */
    color: #d4d4d4;
    font-family: monospace;
    font-size: 0.875rem;
}

/* Rótulo de linguagem */
.language-label {
    font-weight: 500;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
}

/* Botão de copiar código */
.code-copy-btn {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    padding: 0.25rem 0.5rem;
    transition: color 0.2s;
    font-size: 0.875rem;
}

.code-copy-btn:hover {
    color: #ffffff;
}

.code-copy-btn.copied {
    color: var(--color-success);
}

/* Bloco de código */
.code-block {
    margin: 0;
    padding: 1rem;
    background-color: #1e1e1e !important; /* Fundo fixo escuro */
    overflow-x: auto;
}

.code-block code {
    display: block;
    background-color: transparent !important; /* Remover fundo do <code> para usar o do .code-block */
    font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    color: #d4d4d4;
}

/* Forçar o tema de cores highlight.js para os blocos de código */
.hljs {
    background: transparent !important; /* O fundo vem do .code-block */
    color: #d4d4d4 !important; /* Cor base do texto para fundo escuro */
}

/* Forçar fundo escuro em ambos os temas */
[data-theme="light"] .code-container,
[data-theme="light"] .code-block,
[data-theme="light"] pre code,
[data-theme="dark"] .code-container,
[data-theme="dark"] .code-block,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Cores de sintaxe para highlight.js - sempre usar cores para tema escuro */
.hljs-keyword { color: #569cd6 !important; }
.hljs-string { color: #ce9178 !important; }
.hljs-comment { color: #6a9955 !important; }
.hljs-function { color: #dcdcaa !important; }
.hljs-number { color: #b5cea8 !important; }


==========================================
Conteúdo de command-menu.css (caminho: static\css\components\command-menu.css):
==========================================

.command-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    display: none;
    z-index: 1000;
}

.command-menu.show {
    display: block;
}

.command-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    transition: background-color 0.2s;
}

.command-menu-item:hover {
    background-color: var(--hover-color);
}

.chat-item {
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    pointer-events: all;
}

.chat-item * {
    pointer-events: none;
}

.chat-item:hover {
    background-color: var(--hover-color);
}

.chat-item.active {
    background-color: var(--selected-color);
}


==========================================
Conteúdo de forms.css (caminho: static\css\components\forms.css):
==========================================
.search-box {
    position: relative;
    margin-bottom: 1rem;
}

.search-box input {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--input-bg);
    color: var(--text-primary);
}

.input-container {
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
    padding: 10px;
}

.input-box {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    width: 100%;
    max-width: 800px;
    margin-bottom: 1rem;
    position: relative;
    border-radius: 16px;
    background-color: var(--input-bg);
    padding: 0.5rem;
    border: 1px solid transparent;
    transition: border-color 0.2s;
}

.input-box:focus-within {
    border-color: var(--border-color);
}

.input-box textarea {
    width: 100%;
    padding: 0.5rem 0.75rem;
    border: none;
    background-color: var(--input-bg);
    color: var(--text-primary);
    font-size: 1rem;
    resize: none;
    min-height: 24px;
    max-height: 120px;
    line-height: 1.5;
    scrollbar-width: none;
    -ms-overflow-style: none;
    transition: border-color 0.2s;
    border-radius: 12px;
    outline: none;
}

.input-box textarea:focus {
    outline: none;
    border: none;
}

.input-box textarea::-webkit-scrollbar {
    display: none;
}

.input-box .send-btn,
.input-box .stop-btn {
    position: relative;
    right: 0;
    background: transparent;
    cursor: pointer;
    border-radius: 50%;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 0.5rem;
}

.input-box .send-btn {
    background-color: var(--accent-color);
    color: var(--accent-text);
}

.input-box .stop-btn {
    background: transparent;
    color: var(--text-secondary);
    margin-right: 0.5rem;
}

.input-box .stop-btn:hover {
    color: var(--text-primary);
}

.quick-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    width: 100%;
    max-width: 600px;
}

.model-select {
    padding: 0.6rem 0.8rem;
    border-radius: 8px;
    border: none;
    background-color: transparent;
    color: var(--text-primary);
    font-size: 0.9rem;
    transition: all 0.2s;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 0.75rem center;
    padding-right: 2rem;
}

.model-select:hover {
    background-color: var(--action-hover);
}



==========================================
Conteúdo de messages.css (caminho: static\css\components\messages.css):
==========================================
/* Botões de ação nas mensagens */
.message .action-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.message .action-btn:hover {
    background-color: var(--action-hover);
    color: var(--text-primary);
}

.message .action-btn.copied {
    color: #4CAF50;
    background-color: rgba(76, 175, 80, 0.1);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

/* Estilos para formatação de mensagens com Markdown */
.message-content {
    line-height: 1.6;
}

.message-content h1, 
.message-content h2, 
.message-content h3 {
    margin: 1rem 0 0.5rem 0;
    line-height: 1.2;
}

.message-content h1 {
    font-size: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.5rem;
}

.message-content h2 {
    font-size: 1.3rem;
}

.message-content h3 {
    font-size: 1.1rem;
}

.message-content code {
    background-color: var(--action-hover);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}

/* Container para o bloco de código com cabeçalho */
.code-container {
    position: relative;
    margin: 1em 0;
    border-radius: 5px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 0; /* Remove padding extra */
}

.code-header {
    background-color: #2d2d2d !important;
    color: #ffffff;
    padding: 5px 10px;
    font-size: 0.9em;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 0; /* Remove margens */
    border-bottom: none; /* Remove borda para colar com o bloco */
}

.language-label {
    text-transform: uppercase;
    font-size: 0.8em;
    letter-spacing: 1px;
    flex: 1; /* Expande para empurrar o botão */
}

/* Blocos de código estilo terminal */
.message-content .code-block {
    background-color: #1e1e1e !important; /* Fundo preto estilo terminal */
    color: #f8f8f2; /* Texto branco */
    padding: 15px;
    border-radius: 0; /* Remove bordas arredondadas para colar com o header */
    font-family: 'Consolas', 'Courier New', monospace;
    position: relative;
    overflow-x: auto; /* Para códigos longos */
    border: 1px solid #333;
    margin: 0; /* Remove margem para alinhar com o cabeçalho */
    border-top: none; /* Remove borda superior para colar com o header */
}

.message-content .code-block code {
    background: none !important;
    padding: 0;
    color: #f8f8f2 !important;
    display: block;
    white-space: pre;
}

/* Botão de copiar código */
.code-copy-btn {
    background: transparent;
    color: white;
    border: none;
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 0.8rem;
    transition: background-color 0.2s;
    margin-left: auto; /* Alinha o botão à direita */
}

.code-copy-btn:hover {
    background: #666;
}

.code-copy-btn.copied {
    background: #4CAF50;
}

/* Estilos para tabelas Markdown */
.chat-container .message-content table {
    width: 100%; /* Ocupa toda a largura disponível */
    border-collapse: collapse; /* Une as bordas das células */
    margin: 0.5rem 0; /* Espaço reduzido acima e abaixo */
    padding: 0;
    table-layout: fixed; /* Evita células desproporcionais */
}

.chat-container .message-content th,
.chat-container .message-content td {
    border: 1px solid var(--border-color); /* Bordas visíveis */
    padding: 0.5rem; /* Espaço interno reduzido */
    text-align: left; /* Alinhamento à esquerda */
    vertical-align: top; /* Evita alinhamentos estranhos */
    word-wrap: break-word; /* Quebra palavras longas */
    overflow-wrap: break-word;
}

.chat-container .message-content th {
    background-color: var(--action-hover); /* Fundo leve para cabeçalhos */
    font-weight: bold; /* Cabeçalhos em negrito */
}

.chat-container .message-content tr:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.05); /* Efeito zebrado nas linhas pares */
}

/* Ajuste para tema escuro, se necessário */
[data-theme="dark"] .chat-container .message-content th {
    background-color: var(--action-hover);
}

[data-theme="dark"] .chat-container .message-content tr:nth-child(even) {
    background-color: rgba(255, 255, 255, 0.05);
}

/* Estilos para citações */
.message-content blockquote {
    border-left: 4px solid var(--text-secondary);
    margin: 0.5rem 0;
    padding: 0.5rem 0 0.5rem 1rem;
    color: var(--text-secondary);
    background-color: rgba(125, 125, 125, 0.1);
    border-radius: 0 4px 4px 0;
}

/* Estilos para listas */
.message-content ul, 
.message-content ol {
    padding-left: 1.5rem;
    margin: 0.5rem 0;
}

.message-content ul li, 
.message-content ol li {
    margin-bottom: 0.25rem;
}

/* Estilos para links */
.message-content a {
    color: #3498db;
    text-decoration: none;
}

.message-content a:hover {
    text-decoration: underline;
}

/* Estilos para mensagens específicas */
.message.assistant .message-content {
    color: var(--text-primary);
}

.message.user .message-content {
    color: var(--text-primary);
}

/* Estilos para highlight.js */
.hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
    font-family: 'Consolas', 'Courier New', monospace !important;
    line-height: 1.6 !important;
    tab-size: 4 !important;
}

/* Ajustes para temas claro/escuro */
[data-theme="dark"] .hljs {
    background: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Forçar tema claro para o highlight.js */
[data-theme="light"] .hljs {
    background: #f8f8f8 !important;
    color: #333;
}

/* Força o fundo escuro para os blocos de código em ambos os temas */
[data-theme="light"] pre code,
[data-theme="dark"] pre code {
    background-color: #1e1e1e !important;
    color: #d4d4d4 !important;
}

/* Estilos para scroll suave e comportamento de scroll */
.chat-container {
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    padding: 1rem;
    height: 100%;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

/* Estilos para mensagens em streaming */
.message.streaming-message {
    opacity: 0.95;
    transition: opacity 0.3s ease;
    position: relative;
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
    border-radius: 1rem 1rem 1rem 0;
    padding: 1rem;
    margin-bottom: 1.5rem;
    max-width: 80%;
}

.message.streaming-message .message-content {
    position: relative;
    min-height: 24px;
    display: flex;
    align-items: center;
    gap: 4px;
    color: var(--text-secondary);
}

.message.streaming-message .message-content::after {
    content: '';
    display: inline-block;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background-color: currentColor;
    animation: typing 1.4s infinite;
}

.message.streaming-message .message-content::before {
    content: '';
    display: inline-block;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background-color: currentColor;
    animation: typing 1.4s infinite;
    animation-delay: 0.7s;
}

/* Animação de digitação */
@keyframes typing {
    0%, 100% { opacity: 0.2; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1); }
}

/* Estilos para mensagens */
.message {
    position: relative;
    max-width: 80%;
    margin-bottom: 1.5rem;
    padding: 1rem;
    border-radius: 0.5rem;
    line-height: 1.5;
    opacity: 1;
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.message.user {
    background-color: var(--msg-user);
    margin-left: auto;
    color: var(--text-primary);
    border-radius: 1rem 1rem 0 1rem;
}

.message.assistant {
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
    border-radius: 1rem 1rem 1rem 0;
}

/* Estilos para mensagem de carregamento */
.message.loading {
    opacity: 0.8;
}

.message.loading .message-content {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 2rem;
}

/* Estilos para mensagens de erro */
.message.error {
    background-color: var(--error-bg);
    color: var(--error);
}

/* Estilos para conteúdo Markdown */
.message-content {
    line-height: 1.6;
    word-wrap: break-word;
    overflow-wrap: break-word;
}

.message-content p {
    margin: 0.5rem 0;
}

.message-content pre {
    margin: 1rem 0;
    padding: 1rem;
    border-radius: 4px;
    background-color: var(--code-bg);
    overflow-x: auto;
}

.message-content code {
    font-family: 'Consolas', 'Courier New', monospace;
    font-size: 0.9em;
}

.message-content ul,
.message-content ol {
    margin: 0.5rem 0;
    padding-left: 1.5rem;
}

.message-content blockquote {
    margin: 0.5rem 0;
    padding-left: 1rem;
    border-left: 4px solid var(--border-color);
    color: var(--text-secondary);
}

/* Botões de ação */
.message-actions {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.message:hover .message-actions {
    opacity: 1;
}

.action-btn {
    background: none;
    border: none;
    padding: 0.25rem;
    cursor: pointer;
    color: var(--text-secondary);
    transition: color 0.2s ease;
}

.action-btn:hover {
    color: var(--text-primary);
}

/* Indicador de scroll */
.scroll-indicator {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: var(--primary-color);
    color: white;
    padding: 8px 12px;
    border-radius: 20px;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 1000;
}

.scroll-indicator.visible {
    opacity: 1;
}

.scroll-indicator:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}


==========================================
Conteúdo de container.css (caminho: static\css\layout\container.css):
==========================================

.container {
    display: flex;
    height: 100vh;
    position: relative;
    width: 100%;
    overflow: hidden;
    background-color: var(--bg-primary);
}

.input-container {
    padding: 1.5rem;
    border-top: 1px solid var(--border-color);
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
    background-color: var(--bg-primary);
}

/* Loading Animation */
.loading {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    padding: 1rem;
}

.loading span {
    width: 8px;
    height: 8px;
    background-color: var(--text-primary);
    border-radius: 50%;
    animation: bounce 0.5s alternate infinite;
}

.loading span:nth-child(2) {
    animation-delay: 0.1s;
}

.loading span:nth-child(3) {
    animation-delay: 0.2s;
}

@keyframes bounce {
    to {
        transform: translateY(-4px);
    }
}

/* Menu de Comandos */
.command-menu {
    position: absolute;
    bottom: 100%;
    left: 0;
    width: 100%;
    max-height: 300px;
    overflow-y: auto;
    background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-md);
    box-shadow: var(--box-shadow);
    z-index: 1000;
    display: none;
    margin-bottom: 8px;
}

.command-menu.visible {
    display: block;
}

.command-item {
    padding: 10px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    color: var(--text-primary);
    transition: background-color var(--transition-speed);
}

.command-item:hover {
    background-color: var(--action-hover);
}

.command-icon {
    color: var(--accent-color);
    width: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.command-text {
    font-weight: 500;
}

.command-description {
    font-size: 0.875rem;
    color: var(--text-secondary);
    margin-left: auto;
}

/* Responsividade */
@media (max-width: 768px) {
    .main-content {
        width: 100%;
        margin-left: 0;
    }

    .sidebar {
        transform: translateX(-260px);
    }

    .sidebar.visible {
        transform: translateX(0);
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
    }
    
    .input-container,
    .welcome-screen {
        padding: 1rem;
    }
    
    .quick-actions {
        grid-template-columns: 1fr;
    }
}


==========================================
Conteúdo de main-content.css (caminho: static\css\layout\main-content.css):
==========================================
.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
    overflow: hidden;
    margin-left: 260px; /* Largura da barra lateral */
    transition: margin-left 0.3s ease, width 0.3s ease;
    width: calc(100% - 260px); /* Ajusta a largura para considerar a barra lateral */
}

/* Quando a barra lateral está recolhida */
.main-content.expanded {
    margin-left: 0;
    width: 100%; /* Quando expandido, ocupa toda a largura */
}

/* Novo contêiner de rolagem */
.scroll-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    position: relative;
    width: 100%;
    height: calc(100vh - 70px); /* Altura total menos a altura da top-bar */
    overflow-anchor: none; /* Previne ajuste automático de scroll */
    scroll-behavior: smooth; /* Rolagem suave */
    contain: paint; /* Melhora performance */
}

/* Novo contêiner centralizado */
.content-wrapper {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    min-height: 100%;
    display: flex;
    flex-direction: column;
}

/* Ajuste do chat-container */
.chat-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    margin-bottom: 20px;
    overflow-y: auto; /* Habilita scroll apenas no container de mensagens */
    scrollbar-width: thin;
    -ms-overflow-style: none;
    overflow-anchor: none;
    scroll-behavior: smooth;
    contain: paint;
}

/* Esconde a barra de rolagem no Chrome/Safari */
.chat-container::-webkit-scrollbar {
    width: 8px;
}

.chat-container::-webkit-scrollbar-track {
    background: var(--bg-secondary, #f1f1f1);
    border-radius: 4px;
}

.chat-container::-webkit-scrollbar-thumb {
    background: var(--text-secondary, #888);
    border-radius: 4px;
}

.chat-container::-webkit-scrollbar-thumb:hover {
    background: var(--text-primary, #555);
}

/* Para Firefox */
.chat-container {
    scrollbar-width: thin;
    scrollbar-color: var(--text-secondary, #888) var(--bg-secondary, #f1f1f1);
}

/* Ajuste do input-container */
.input-container {
    position: sticky;
    bottom: 0;
    background: var(--bg-primary);
    padding: 20px;
    z-index: 10;
    backdrop-filter: blur(8px);
}

.message {
    position: relative;
    max-width: 85%;
    margin-bottom: 1.5rem;
    padding: 1rem 1.2rem;
    border-radius: 12px;
    line-height: 1.5;
    box-shadow: none;
}

.message.user {
    background-color: var(--msg-user);
    margin-left: auto;
    color: var(--text-primary);
}

.message.assistant {
    background-color: var(--msg-bot);
    margin-right: auto;
    color: var(--text-primary);
}

.message .message-actions {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    display: none;
    gap: 0.5rem;
}

.message:hover .message-actions {
    display: flex;
}

/* Top Bar */
.top-bar {
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--bg-primary);
    box-shadow: none;
    height: 70px;
}

.program-name {
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--text-primary);
}

.top-bar-actions {
    display: flex;
    align-items: center;
    gap: 1rem;
}

/* Welcome Screen */
.welcome-screen {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    text-align: center;
    padding: 20px;
}

.welcome-screen h1 {
    margin-bottom: 20px;
    font-size: 2rem;
    color: var(--text-primary);
}

.welcome-screen .input-box {
    width: 100%;
    max-width: 600px;
    margin-bottom: 20px;
}

.welcome-screen .quick-actions {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
    width: 100%;
    max-width: 600px;
}

/* Animação de digitação para mensagens em streaming */
.typing-animation {
    display: inline-block;
    animation: blink 1s infinite;
}

@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}

/* Estilo específico para mensagens em streaming */
.streaming-message .message-content {
    min-height: 24px;
}


==========================================
Conteúdo de sidebar.css (caminho: static\css\layout\sidebar.css):
==========================================
.sidebar {
    width: 260px;
    height: 100vh;
    background-color: var(--sidebar-bg);
    padding: 1rem;
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--border-color);
    position: fixed;
    left: 0;
    top: 0;
    transition: transform 0.3s ease;
    z-index: 100;
    box-shadow: none;
    overflow-y: auto;
    overflow-x: hidden;
}

.sidebar.collapsed {
    transform: translateX(-260px);
}

.chat-list {
    flex: 1;
    overflow-y: auto;
    margin-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.chat-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px;
    cursor: pointer;
    position: relative;
    border-radius: 8px;
    transition: background-color 0.2s;
}

.chat-item:hover {
    background-color: var(--action-hover);
}

.chat-item.active {
    background-color: var(--action-selected);
    font-weight: 500;
}

.chat-item-content {
    flex-grow: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: 10px;
}

.more-btn {
    background: none;
    border: none;
    padding: 5px;
    cursor: pointer;
    color: var(--text-secondary);
    opacity: 0.7;
    transition: opacity 0.2s;
}

.more-btn:hover {
    opacity: 1;
}

.chat-options-menu {
    display: none;
    position: absolute;
    right: 10px;
    top: 100%;
    background: var(--input-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    z-index: 10;
    min-width: 150px;
}

.chat-options-menu.visible {
    display: block;
}

.chat-option-item {
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    color: var(--text-primary);
    transition: background-color 0.2s;
}

.chat-option-item:hover {
    background-color: var(--action-hover);
}

.chat-option-icon {
    color: var(--text-secondary);
    width: 16px;
}

/* Estilos para o scroll da barra lateral */
.sidebar::-webkit-scrollbar {
    width: 6px;
}

.sidebar::-webkit-scrollbar-track {
    background: transparent;
}

.sidebar::-webkit-scrollbar-thumb {
    background: var(--text-disabled);
    border-radius: 3px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
    background: var(--text-secondary);
}

@media (max-width: 768px) {
    .sidebar {
        transform: translateX(-260px);
    }

    .sidebar.visible {
        transform: translateX(0);
    }
}


==========================================
Conteúdo de messages.css (caminho: static\css\messages.css):
==========================================
/* Estilos para o container do chat */
.chat-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    position: relative;
    padding: 1rem;
    gap: 1rem;
    scroll-behavior: smooth;
    will-change: scroll-position;
    -webkit-overflow-scrolling: touch;
    contain: paint;
}

/* Estilos base para mensagens */
.message {
    display: flex;
    flex-direction: column;
    max-width: 85%;
    margin: 0.5rem 0;
    position: relative;
    opacity: 1;
    transform: translateY(0);
    transition: 
        opacity 0.2s ease-out,
        transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity, transform;
    contain: content;
}

/* Animação de entrada para novas mensagens */
.message.fade-in {
    animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
    from { 
        opacity: 0;
        transform: translateY(10px);
    }
    to { 
        opacity: 1;
        transform: translateY(0);
    }
}

/* Mensagens do usuário */
.message.user {
    align-self: flex-end;
    background-color: var(--msg-user-bg, #007bff);
    color: var(--msg-user-text, #ffffff);
    border-radius: 1rem 1rem 0 1rem;
    padding: 0.8rem 1rem;
    margin-left: auto;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    z-index: 2;
    transform-origin: bottom right;
}

/* Mensagens do assistente */
.message.assistant {
    align-self: flex-start;
    background-color: var(--msg-assistant-bg, #f8f9fa);
    color: var(--msg-assistant-text, #212529);
    border-radius: 1rem 1rem 1rem 0;
    padding: 1rem;
    margin-right: auto;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    z-index: 1;
    transform-origin: bottom left;
}

/* Conteúdo da mensagem */
.message-content {
    display: block;
    width: 100%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    min-width: 0;
}

/* Animação para indicação de digitação */
.typing-indicator {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 4px 8px;
    height: 24px;
}

.typing-indicator span {
    display: inline-block;
    width: 8px;
    height: 8px;
    margin: 0 2px;
    background-color: var(--text-secondary);
    border-radius: 50%;
    opacity: 0.6;
    animation: typingPulse 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) {
    animation-delay: 0s;
}

.typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
}

.typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typingPulse {
    0%, 100% { 
        transform: scale(1);
        opacity: 0.6;
    }
    50% { 
        transform: scale(1.2);
        opacity: 1;
    }
}

/* Animação de carregamento */
.loading-indicator {
    display: flex;
    justify-content: center;
    padding: 0.5rem;
}

.loading-indicator span {
    display: inline-block;
    width: 8px;
    height: 8px;
    margin: 0 4px;
    border-radius: 50%;
    background-color: var(--text-secondary);
    opacity: 0.6;
    animation: loadingDots 1.4s infinite ease-in-out;
}

.loading-indicator span:nth-child(1) {
    animation-delay: 0s;
}

.loading-indicator span:nth-child(2) {
    animation-delay: 0.2s;
}

.loading-indicator span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes loadingDots {
    0%, 100% { 
        transform: translateY(0);
        opacity: 0.6;
    }
    50% { 
        transform: translateY(-5px);
        opacity: 1;
    }
}

/* Mensagens de erro */
.message.error {
    background-color: var(--msg-error-bg, #dc3545);
    color: var(--msg-error-text, #ffffff);
    animation: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
}

@keyframes shake {
    10%, 90% { transform: translate3d(-1px, 0, 0); }
    20%, 80% { transform: translate3d(2px, 0, 0); }
    30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
    40%, 60% { transform: translate3d(4px, 0, 0); }
}

/* Otimizações de performance */
.chat-container,
.message {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    backface-visibility: hidden;
    perspective: 1000px;
    transform: translate3d(0,0,0);
}

/* Botões de ação nas mensagens */
.message-actions {
    display: flex;
    justify-content: flex-end;
    opacity: 0;
    transition: opacity 0.2s ease;
    padding-top: 0.5rem;
}

.message:hover .message-actions {
    opacity: 1;
}

.action-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    color: var(--text-secondary);
    padding: 4px 8px;
    border-radius: 4px;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.action-btn:hover {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--text-primary);
}

/* Melhorar formatação de código durante streaming */
.message pre {
    background-color: var(--code-bg, rgba(0, 0, 0, 0.05));
    border-radius: 4px;
    padding: 1em;
    margin: 0.5em 0;
    overflow-x: auto;
    font-family: 'Fira Code', monospace, Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 0.9em;
    line-height: 1.5;
}

.message code {
    font-family: 'Fira Code', monospace, Consolas, Monaco, 'Andale Mono', monospace;
    font-size: 0.9em;
    background-color: var(--inline-code-bg, rgba(0, 0, 0, 0.05));
    padding: 0.2em 0.4em;
    border-radius: 3px;
}

/* Estilo para tabelas em mensagens */
.message table {
    border-collapse: collapse;
    width: 100%;
    margin: 1em 0;
    overflow-x: auto;
    display: block;
}

.message th, 
.message td {
    border: 1px solid var(--border-color, #ddd);
    padding: 8px 12px;
    text-align: left;
}

.message th {
    background-color: var(--table-header-bg, rgba(0, 0, 0, 0.03));
    font-weight: bold;
}

.message tr:nth-child(even) {
    background-color: var(--table-row-alt, rgba(0, 0, 0, 0.02));
}

/* Estilo para mensagens do YouTube */
.message.youtube {
    border-left: 3px solid var(--accent-color);
}

.message.youtube .message-content {
    padding-left: 1rem;
} 

==========================================
Conteúdo de streaming.css (caminho: static\css\streaming.css):
==========================================
/* Estilos para o sistema de streaming */

/* Cursor piscante */
.cursor {
    display: inline-block;
    width: 0.5em;
    height: 1.2em;
    background-color: currentColor;
    margin-left: 2px;
    animation: blink 1s steps(2) infinite;
    vertical-align: text-bottom;
    opacity: 0.7;
}

@keyframes blink {
    0% { opacity: 0.7; }
    50% { opacity: 0; }
    100% { opacity: 0.7; }
}

/* 
 * CÓDIGO PARA REVISÃO FUTURA [INÍCIO] 
 * ----------------------------------------
 * Animação de carregamento de três pontinhos 
 * Esta implementação apresenta problemas e não funciona corretamente
 * Precisa ser revisada ou substituída em uma implementação futura
 * Issue #XX: Revisar feedback visual durante carregamento
 * ----------------------------------------
 */
.loading-dots {
    display: inline-block;
}

/* Animação base para todos os pontinhos */
.loading-dots span {
    animation: blink 1.4s infinite both;
}

/* Aplicar delay para segundo pontinho */
.loading-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

/* Aplicar delay para terceiro pontinho */
.loading-dots span:nth-child(3) {
    animation-delay: 0.4s;
}
/* 
 * CÓDIGO PARA REVISÃO FUTURA [FIM]
 * ----------------------------------------
 */

/* 
 * Nova implementação de animação de carregamento centralizada
 * Esta solução substitui a abordagem anterior dos "três pontinhos"
 */
#loading-animation {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    background: rgba(0, 0, 0, 0.7);
    padding: 15px 25px;
    border-radius: 8px;
    color: #fff;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.loading-spinner {
    display: flex;
    align-items: center;
    gap: 10px;
}

.loading-spinner i {
    font-size: 1.5rem;
}

.loading-spinner span {
    font-family: 'Inter', sans-serif;
    font-size: 1rem;
}

/* Placeholder para mensagens em carregamento */
.placeholder {
    color: #666;
    font-style: italic;
}

/* Container de mensagem durante streaming */
.message.assistant {
    position: relative;
    animation: fadeIn 0.3s ease-in-out;
}

/* Mensagem de erro */
.error-message {
    color: #dc3545;
    padding: 8px;
    border-radius: 4px;
    background-color: rgba(220, 53, 69, 0.1);
    margin: 8px 0;
}

/* Animação de fade in */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Estilos para garantir que o cursor fique na mesma linha do texto */
.message.assistant p:last-child {
    display: inline;
    margin: 0;
}

/* Ajuste para markdown dentro da mensagem */
.message.assistant pre {
    margin: 1em 0;
    white-space: pre-wrap;
}

.message.assistant code {
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.05);
    padding: 2px 4px;
    border-radius: 3px;
}

/* Ajustes para garantir que o cursor fique alinhado com o texto */
.message.assistant .cursor {
    position: relative;
    top: 2px;
} 

==========================================
Conteúdo de style.css (caminho: static\css\style.css):
==========================================
#loading-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
}

#loading-indicator .spinner-border {
    width: 3rem;
    height: 3rem;
}

#error-message, #success-message {
    margin: 1rem 0;
    padding: 1rem;
    border-radius: 0.25rem;
}

#subtitles-container {
    background-color: #f8f9fa;
    padding: 1.5rem;
    border-radius: 0.5rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.alert {
    margin-top: 1rem;
    margin-bottom: 1rem;
    padding: 1rem;
    border-radius: 0.25rem;
}

.alert-danger {
    color: #721c24;
    background-color: #f8d7da;
    border: 1px solid #f5c6cb;
}

.alert-success {
    color: #155724;
    background-color: #d4edda;
    border: 1px solid #c3e6cb;
}

.test-btn {
    background: none;
    border: none;
    color: var(--text-color);
    cursor: pointer;
    padding: 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.2s;
}

.test-btn:hover {
    color: var(--accent-color);
}

.test-btn:active {
    transform: scale(0.95);
} 

==========================================
Conteúdo de styles.css (caminho: static\css\styles.css):
==========================================
@import './components/command-menu.css';

/* Reset e variáveis base */
@import './base/variables.css';

@import './base/reset.css';
@import './base/typography.css';

/* Layouts principais */
@import './layout/container.css';
@import './layout/sidebar.css';
@import './layout/main-content.css';

/* Componentes */
@import './components/buttons.css';
@import './components/forms.css';
@import './components/messages.css';
@import './components/code-highlight.css';

/* Temas */
@import './themes/light-theme.css';
@import './themes/dark-theme.css';

/* Importando tema do highlight.js */
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css');
@import url('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css') (prefers-color-scheme: dark);

.chat-container table {
  width: 100%; /* Faz a tabela ocupar toda a largura disponível */
  border-collapse: collapse; /* Une as bordas das células */
  margin: 1rem 0; /* Adiciona espaço acima e abaixo da tabela */
}

.chat-container th,
.chat-container td {
  border: 1px solid #ccc; /* Adiciona bordas visíveis às células */
  padding: 0.75rem; /* Dá espaço interno às células */
  text-align: left; /* Alinha o texto à esquerda */
}

.chat-container th {
  background-color: #f5f5f5; /* Fundo leve para os cabeçalhos */
  font-weight: bold; /* Deixa os cabeçalhos em negrito */
}

.chat-container tr:nth-child(even) {
  background-color: #fafafa; /* Efeito zebrado nas linhas pares */
}


.command-menu.visible {
    display: block !important;
}

.command-item {
    padding: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
}

.command-item:hover {
    background-color: var(--action-hover);
}

.command-icon {
    color: var(--text-secondary);
    width: 20px;
}

.command-text {
    font-weight: 500;
}

.command-description {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.command-menu {
    display: none;
    position: absolute;
    /* outras propriedades de estilo */
}
.command-menu.visible {
    display: block;
}

/* Estilos para o YouTube Resumo */
.message.youtube-resumo .progress-container {
    margin-top: 15px;
    padding: 10px;
    background-color: var(--message-background);
    border-radius: 8px;
}

.message.youtube-resumo .progress {
    height: 10px;
    border-radius: 5px;
    background-color: var(--border-color);
    margin-bottom: 8px;
    overflow: hidden;
}

.message.youtube-resumo .progress-bar {
    height: 100%;
    background-color: var(--primary-color);
    transition: width 0.3s ease;
}

.message.youtube-resumo .progress-text {
    font-size: 0.85rem;
    color: var(--text-color-secondary);
    text-align: center;
}

.message.youtube-resumo .current-block,
.message.youtube-resumo .total-blocks {
    font-weight: bold;
}


==========================================
Conteúdo de dark-theme.css (caminho: static\css\themes\dark-theme.css):
==========================================
[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
}

==========================================
Conteúdo de light-theme.css (caminho: static\css\themes\light-theme.css):
==========================================
:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
}

==========================================
Conteúdo de variables.css (caminho: static\css\variables.css):
==========================================

:root {
    --bg-primary: #f7f7f8;
    --text-primary: #000000;
    --text-secondary: rgba(0, 0, 0, 0.7);
    --text-disabled: rgba(0, 0, 0, 0.5);
    --action-active: #000000;
    --action-hover: rgba(0, 0, 0, 0.08);
    --action-selected: rgba(0, 0, 0, 0.16);
    --action-disabled: rgba(0, 0, 0, 0.3);
    --action-disabled-background: rgba(0, 0, 0, 0.12);
    --msg-user: #e6e6e6;
    --msg-bot: #d9d9d9;
    --sidebar-bg: #ffffff;
    --input-bg: #ffffff;
    --border-color: rgba(0, 0, 0, 0.12);
    --code-bg: #f8f8f8;
    --code-header-bg: #f1f1f1;
    --color-success: #4CAF50;
}

[data-theme="dark"] {
    --bg-primary: #343541;
    --text-primary: #fff;
    --text-secondary: rgba(255, 255, 255, 0.7);
    --text-disabled: rgba(255, 255, 255, 0.5);
    --action-active: #fff;
    --action-hover: rgba(255, 255, 255, 0.08);
    --action-selected: rgba(255, 255, 255, 0.16);
    --action-disabled: rgba(255, 255, 255, 0.3);
    --action-disabled-background: rgba(255, 255, 255, 0.12);
    --msg-user: #444654;
    --msg-bot: #444654;
    --sidebar-bg: #202123;
    --input-bg: #40414f;
    --border-color: rgba(255, 255, 255, 0.12);
    --code-bg: #1e1e1e;
    --code-header-bg: #2d2d2d;
    --color-success: #4CAF50;
}


==========================================
Conteúdo de chatUI.js (caminho: static\js\backup\chatUI.js):
==========================================
import { escapeHTML } from './chat/chatUtils.js';
import { renderMarkdown, renderMessageContainer, setCurrentConversation } from './messageRenderer.js';
import { melhorarBlocosCodigo } from './chat/chatUtils.js';
import { streamingManager } from './modules/streamingManager.js';
import { logger } from './utils/logger.js';

export function iniciarChat(welcomeScreen, chatContainer, inputContainer) {
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
    
    // Verificar se há uma conversa carregada na estrutura global
    const conversationId = window.conversaAtual?.id;
    if (conversationId && window.conversations && window.conversations[conversationId]) {
        // Definir a conversa atual no renderizador de mensagens
        setCurrentConversation(conversationId);
    } else {
        // Limpar a referência da conversa atual
        setCurrentConversation(null);
    }
}

export function mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput) {
    welcomeScreen.style.display = 'flex';
    chatContainer.style.display = 'none';
    inputContainer.style.display = 'none';
    welcomeInput.value = '';
    if (chatInput) chatInput.value = '';
    
    // Limpar referência da conversa atual para evitar mistura de contextos
    window.conversaAtual = null;
    setCurrentConversation(null);
    
    // Remover qualquer listener de scroll
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
}

export function adicionarMensagem(chatContainer, texto, tipo) {
    // Verificar se o contêiner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Contêiner de chat não encontrado ao adicionar mensagem');
        return;
    }
    
    // Verificar se há uma conversa ativa
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando adicionar mensagem sem conversa ativa');
    }

    // Gerar um ID único para a mensagem - evitando caracteres especiais
    const messageId = `${Date.now()}_${tipo}`;
    
    // Usar a nova função de renderização com containers individuais
    renderMessageContainer({
        content: texto,
        conversationId,
        role: tipo,
        messageId,
        isStreaming: false
    });
}

// Adicionando uma nova função para lidar com chunks de streaming
export function atualizarMensagemStreaming(messageId, chunk, conversationId) {
    // Verificar se há uma conversa ativa
    if (!conversationId) {
        console.warn('[AVISO] Tentando atualizar mensagem sem conversa ativa');
        return;
    }
    
    // Obter a mensagem existente do DOM
    const messageDiv = document.getElementById(`message-${messageId}`);
    
    // Se a mensagem não existir, criar uma nova
    if (!messageDiv) {
        return renderMessageContainer({
            content: chunk,
            conversationId,
            role: 'assistant',
            messageId,
            isStreaming: true
        });
    }
    
    // Se a mensagem existir, atualizar seu conteúdo
    const contentDiv = messageDiv.querySelector('.message-content');
    if (contentDiv) {
        const renderedChunk = renderMarkdown(chunk);
        contentDiv.innerHTML = renderedChunk;
    }
}

export function mostrarCarregamento(chatContainer) {
    // Verificar se o contêiner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Contêiner de chat não encontrado ao mostrar carregamento');
        return document.createElement('div'); // Retorna um div vazio como fallback
    }
    
    const loadingId = `loading_${Date.now()}`;
    
    // Associar ID da conversa para garantir isolamento
    const conversationId = window.conversaAtual?.id;
    
    // Criar o indicador de carregamento como uma mensagem com ID único
    return renderMessageContainer({
        content: `<div class="loading-indicator"><span></span><span></span><span></span></div>`,
        conversationId,
        role: 'assistant',
        messageId: loadingId,
        isStreaming: false
    });
}

// Handler para processar chunks de mensagem recebidos via Socket.IO
export function handleMessageChunk(data) {
    const { content, conversation_id: conversationId, message_id: messageId, role } = data;
    
    // Verificar se esta mensagem corresponde à conversa ativa
    if (conversationId !== window.conversaAtual?.id) {
        return;
    }
    
    // ID da mensagem (usar o fornecido ou gerar um novo)
    const uniqueMessageId = messageId || `msg_${Date.now()}`;
    
    // Renderizar ou atualizar o container da mensagem
    renderMessageContainer({
        content,
        conversationId,
        role: role || 'assistant',
        messageId: uniqueMessageId,
        isStreaming: true
    });
}

// Adicionar CSS para os novos elementos
const style = document.createElement('style');
style.textContent = `
.loading-indicator {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

.error-message {
    padding: 1rem;
    text-align: center;
    color: var(--error);
    font-weight: bold;
}

.empty-message {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
`;
document.head.appendChild(style);

class ChatUI {
    constructor() {
        logger.info('Inicializando ChatUI', 'chatUI.js/root');
        this.currentConversationId = null;
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        // Verificar se os elementos existem antes de adicionar listeners
        const sendButton = document.getElementById('send-btn');
        const messageInput = document.getElementById('chat-input');
        
        if (sendButton) {
            sendButton.addEventListener('click', () => this.sendMessage());
        }
        
        if (messageInput) {
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendMessage();
                }
            });
        }

        // Listener para mudança de conversa
        document.addEventListener('conversation-selected', (e) => {
            this.handleConversationChange(e.detail.conversationId);
        });
    }

    async sendMessage() {
        const messageInput = document.getElementById('chat-input');
        const message = messageInput.value.trim();
        
        if (!message) return;
        
        // Limpar input
        messageInput.value = '';
        
        try {
            // Adicionar mensagem do usuário ao chat
            this.appendUserMessage(message);
            
            // Enviar mensagem para o backend
            const response = await fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    conversation_id: this.currentConversationId
                })
            });
            
            if (!response.ok) {
                throw new Error('Falha ao enviar mensagem');
            }
            
            // O streaming será gerenciado pelo StreamingManager
            
        } catch (error) {
            console.error('Erro ao enviar mensagem:', error);
            this.showError('Erro ao enviar mensagem. Por favor, tente novamente.');
        }
    }

    appendUserMessage(message) {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) {
            console.error('[ERRO] Container de chat não encontrado para adicionar mensagem do usuário');
            return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message user';
        messageDiv.innerHTML = `<p>${this.escapeHtml(message)}</p>`;
        chatContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }

    handleConversationChange(conversationId) {
        this.currentConversationId = conversationId;
        
        // Limpar chat atual
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) {
            console.error('[ERRO] Container de chat não encontrado para mudança de conversa');
            return;
        }
        
        chatContainer.innerHTML = '';
        
        if (conversationId) {
            // Carregar histórico da conversa
            this.loadConversationHistory(conversationId);
            // Restaurar estado do streaming, se houver
            streamingManager.restoreStreamingState(conversationId);
        }
    }

    async loadConversationHistory(conversationId) {
        try {
            const response = await fetch(`/get_conversation/${conversationId}`);
            if (!response.ok) {
                throw new Error('Falha ao carregar histórico');
            }
            
            const conversation = await response.json();
            this.displayConversationHistory(conversation.messages);
            
        } catch (error) {
            console.error('Erro ao carregar histórico:', error);
            this.showError('Erro ao carregar histórico da conversa.');
        }
    }

    displayConversationHistory(messages) {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) {
            console.error('[ERRO] Container de chat não encontrado para exibir histórico de conversas');
            return;
        }
        
        messages.forEach(message => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.role}`;
            
            if (message.role === 'assistant') {
                messageDiv.innerHTML = marked.parse(message.content);
                messageDiv.innerHTML = DOMPurify.sanitize(messageDiv.innerHTML);
            } else {
                messageDiv.innerHTML = `<p>${this.escapeHtml(message.content)}</p>`;
            }
            
            chatContainer.appendChild(messageDiv);
        });
        
        this.scrollToBottom();
    }

    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) {
            console.error('[ERRO] Container de chat não encontrado para mostrar erro:', message);
            return;
        }
        
        chatContainer.appendChild(errorDiv);
        this.scrollToBottom();
    }

    scrollToBottom() {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) {
            console.error('[ERRO] Container de chat não encontrado para rolagem');
            return;
        }
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
}

// Exportar instância única
export const chatUI = new ChatUI();


==========================================
Conteúdo de messageRegistry.js (caminho: static\js\backup\messageRegistry.js):
==========================================
/**
 * messageRegistry.js
 * 
 * Sistema centralizado para gerenciamento de mensagens em streaming.
 * Este módulo exporta uma instância única do messageRegistry que
 * deve ser usada por toda a aplicação para evitar duplicação de mensagens.
 */

import { logger } from '../utils/logger.js';

/**
 * Classe para gerenciar o registro de mensagens
 */
class MessageRegistry {
    constructor() {
        logger.info('Inicializando MessageRegistry', 'messageRegistry.js/root');
        this.messages = new Map();
        this.debug = false; // Configurar como true para habilitar logs adicionais
        
        // Criar global para garantir acesso em todos os módulos
        if (!window.messageRegistry) {
            window.messageRegistry = this.messages;
            logger.info('Inicializando messageRegistry global');
        } else {
            this.messages = window.messageRegistry;
            logger.debug('Usando messageRegistry global existente');
        }
        
        // Monitoramento periódico para limpeza e depuração
        this.setupPeriodicCheck();
    }
    
    /**
     * Configura verificação periódica para limpeza e logs
     */
    setupPeriodicCheck() {
        setInterval(() => {
            if (this.debug) {
                logger.debug('Estado atual do messageRegistry', {
                    totalEntries: this.messages.size,
                    entries: Array.from(this.messages.keys())
                });
            }
            
            // Limpar containers órfãos
            this.cleanOrphanContainers();
        }, 5000);
    }
    
    /**
     * Gera um ID único para mensagens
     * @returns {string} ID único para mensagem
     */
    generateMessageId() {
        const messageId = `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
        logger.trackMessage('generated', messageId);
        return messageId;
    }
    
    /**
     * Registra uma nova mensagem
     * @param {string} messageId - ID único da mensagem
     * @param {Object} data - Dados da mensagem
     * @returns {Object} Entrada criada no registry
     */
    registerMessage(messageId, data = {}) {
        logger.debug(`Adicionando mensagem ${messageId}`, 'messageRegistry.js/root');
        if (!messageId) {
            logger.error('Tentativa de registrar mensagem sem ID');
            return null;
        }
        
        if (this.messages.has(messageId)) {
            logger.debug(`Mensagem ${messageId} já registrada, atualizando`);
            const entry = this.messages.get(messageId);
            
            // Atualizar dados existentes
            Object.assign(entry, data);
            return entry;
        }
        
        // Criar nova entrada
        const entry = {
            id: messageId,
            content: data.content || '',
            container: data.container || null,
            timestamp: Date.now(),
            conversationId: data.conversationId || null,
            complete: false,
            ...data
        };
        
        this.messages.set(messageId, entry);
        logger.trackMessage('registered', messageId, entry.conversationId, {
            contentLength: entry.content?.length || 0
        });
        
        return entry;
    }
    
    /**
     * Obtém uma mensagem do registro
     * @param {string} messageId - ID da mensagem
     * @returns {Object|null} Dados da mensagem ou null se não existir
     */
    getMessage(messageId) {
        logger.debug(`Buscando mensagem ${messageId}`, 'messageRegistry.js/root');
        if (!messageId) return null;
        return this.messages.get(messageId) || null;
    }
    
    /**
     * Atualiza dados de uma mensagem existente
     * @param {string} messageId - ID da mensagem
     * @param {Object} data - Novos dados a serem mesclados
     * @returns {boolean} Sucesso da operação
     */
    updateMessage(messageId, data) {
        if (!messageId || !this.messages.has(messageId)) {
            return false;
        }
        
        const entry = this.messages.get(messageId);
        Object.assign(entry, data);
        
        logger.trackMessage('updated', messageId, entry.conversationId, {
            contentLength: entry.content?.length || 0,
            updatedFields: Object.keys(data)
        });
        
        return true;
    }
    
    /**
     * Adiciona conteúdo a uma mensagem existente
     * @param {string} messageId - ID da mensagem
     * @param {string} chunk - Chunk de conteúdo a ser adicionado
     * @returns {boolean} Sucesso da operação
     */
    addChunk(messageId, chunk) {
        if (!messageId) return false;
        
        let entry = this.getMessage(messageId);
        if (!entry) {
            entry = this.registerMessage(messageId, { content: '' });
        }
        
        entry.content += chunk;
        entry.lastUpdated = Date.now();
        
        logger.trackMessage('chunk_added', messageId, entry.conversationId, {
            chunkSize: chunk.length,
            totalSize: entry.content.length
        });
        
        return true;
    }
    
    /**
     * Marca uma mensagem como completa
     * @param {string} messageId - ID da mensagem
     * @param {string} conversationId - ID da conversa
     * @returns {boolean} Sucesso da operação
     */
    completeMessage(messageId, conversationId) {
        logger.debug(`Completando mensagem ${messageId}`, 'messageRegistry.js/root');
        const entry = this.messages.get(messageId);
        if (!entry) {
            logger.warn(`Tentativa de completar mensagem inexistente: ${messageId}`);
            return false;
        }
        
        entry.complete = true;
        entry.conversationId = conversationId || entry.conversationId;
        
        logger.trackMessage('completed', messageId, entry.conversationId, {
            contentLength: entry.content?.length || 0
        });
        
        // Emitir evento de mensagem completa
        document.dispatchEvent(new CustomEvent('message:complete', {
            detail: { messageId, conversationId: entry.conversationId }
        }));
        
        return true;
    }
    
    /**
     * Remove uma mensagem do registro
     * @param {string} messageId - ID da mensagem
     * @returns {boolean} Sucesso da operação
     */
    removeMessage(messageId) {
        if (!messageId || !this.messages.has(messageId)) {
            return false;
        }
        
        const entry = this.messages.get(messageId);
        const result = this.messages.delete(messageId);
        
        if (result) {
            logger.trackMessage('removed', messageId, entry.conversationId);
        }
        
        return result;
    }
    
    /**
     * Verifica se uma mensagem existe no registro
     * @param {string} messageId - ID da mensagem
     * @returns {boolean} Se a mensagem existe
     */
    hasMessage(messageId) {
        return this.messages.has(messageId);
    }
    
    /**
     * Obtém todas as mensagens de uma conversa
     * @param {string} conversationId - ID da conversa
     * @returns {Array} Lista de mensagens da conversa
     */
    getMessagesByConversation(conversationId) {
        if (!conversationId) return [];
        
        return Array.from(this.messages.values())
            .filter(msg => msg.conversationId === conversationId);
    }
    
    /**
     * Limpa containers órfãos
     */
    cleanOrphanContainers() {
        const now = Date.now();
        let orphansRemoved = 0;
        
        for (const [messageId, entry] of this.messages.entries()) {
            // Remover mensagens antigas (mais de 2 horas)
            if (now - entry.timestamp > 7200000) {
                this.messages.delete(messageId);
                orphansRemoved++;
                logger.trackMessage('auto_removed', messageId, entry.conversationId, {
                    reason: 'timeout'
                });
            }
        }
        
        if (orphansRemoved > 0 && this.debug) {
            logger.debug(`Limpeza: ${orphansRemoved} mensagens removidas`);
        }
    }
}

// Exportar uma instância única
export const messageRegistry = new MessageRegistry();
export default messageRegistry;

==========================================
Conteúdo de chatActions.js (caminho: static\js\chat\chatActions.js):
==========================================
import { chatUI } from './chatUI.js';
import { adicionarMensagemAoHistorico, criarNovaConversa, atualizarListaConversas } from './chatStorage.js';
import { renderMessage, renderMessageChunk, completeMessage } from '../messageRenderer.js';
import { messageRegistry } from '../modules/messageRegistry.js';
import { melhorarBlocosCodigo } from './chatUtils.js';
import { handleYoutubeCommand } from '../youtube-system/youtubeHandler.js';
import { handleYoutubeResumoCommand } from '../youtube-system/youtubeResumoHandler.js';
import { logger } from '../utils/logger.js';
import { marked } from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js';
import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js';

// Verificar se o messageRegistry global está disponível
if (!window.messageRegistry) {
    logger.info('Definindo messageRegistry global a partir do módulo importado');
    window.messageRegistry = messageRegistry.messages || new Map();
} else {
    logger.debug('messageRegistry global já estava disponível');
}

// Mapa para controlar o estado de streaming por conversa
const streamingStates = new Map();

// Mapa para rastrear messageIds de streaming
const streamingMessageIds = new Map();

// Mapa para acumular chunks por conversa
const streamingChunks = new Map();

// Mapa para rastrear chunks já processados
const processedChunks = new Map();

// Mapa para rastrear o último chunk recebido por conversa
const lastReceivedChunks = new Map();

// Mapa para rastrear mensagens já enviadas
const sentMessages = new Map();

// Gerenciar estado de streaming
const streamingMessages = new Set();

// Monitoramento de streams ativos
let activeStreams = new Set();

/**
 * Variáveis globais para controle do fluxo de troca de conversas
 * Estas variáveis garantem que não percamos chunks durante a transição entre conversas
 */
// Armazena o ID da conversa atual para controle de fluxo
let currentConversationId = null;
// Armazena o ID da mensagem em streaming para controle de saída da sala
let currentStreamingMessageId = null;

// Inicializa o socket apenas uma vez
let socket;
if (!window.socket) {
    window.socket = io();
    socket = window.socket;
    
    // Adicionar log de conexão
    socket.on('connect', () => {
        logger.debug('WebSocket conectado com sucesso');
    });

    socket.on('connect_error', (error) => {
        logger.error('Falha na conexão WebSocket', error);
    });

    // Remove listeners existentes para evitar duplicação
    socket.off('message_chunk');
    socket.off('response_complete');
    socket.off('conversation_updated');

    // Listener para chunks da mensagem
    socket.on('message_chunk', (data) => {
        const { content, conversation_id, chunk_number, message_id } = data;
        
        // Verificar duplicação de mensagem
        if (isDuplicateMessage(conversation_id, content)) {
            logger.debug('Chunk ignorado por ser duplicado', {
                conversationId: conversation_id,
                chunkNumber: chunk_number
            });
            return;
        }
        
        logger.debug('Recebido chunk', { 
            conversationId: conversation_id,
            messageId: message_id,
            chunkNumber: chunk_number,
            chunkSize: content?.length,
            timestamp: Date.now()
        });

        if (!content || !conversation_id || content === '[DONE]') {
            logger.debug('Chunk vazio ou marcador de fim recebido', { content, conversation_id });
            return;
        }
        
        // Verificar se é a conversa atual
        if (window.conversaAtual?.id !== conversation_id) {
            logger.debug('Ignorando chunk de outra conversa', {
                atual: window.conversaAtual?.id,
                recebido: conversation_id
            });
            return;
        }

        // Ocultar a animação de carregamento ao receber o primeiro chunk
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation && loadingAnimation.style.display === 'block') {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após receber o primeiro chunk');
        }

        // Verificar duplicação de chunks
        const lastChunk = lastReceivedChunks.get(conversation_id);
        if (lastChunk === content) {
            logger.debug('Chunk duplicado ignorado', {
                conversationId: conversation_id,
                chunkNumber: chunk_number,
                content: content.substring(0, 20) + '...'
            });
            return;
        }
        lastReceivedChunks.set(conversation_id, content);
        
        // Verificar se o chunk já foi processado
        if (!processedChunks.has(conversation_id)) {
            processedChunks.set(conversation_id, new Set());
        }
        
        if (processedChunks.get(conversation_id).has(chunk_number)) {
            logger.debug('Chunk já processado, ignorando', {
                conversationId: conversation_id,
                chunkNumber: chunk_number
            });
            return;
        }
        
        // Marcar chunk como processado
        processedChunks.get(conversation_id).add(chunk_number);
        
        // Marca conversa como em streaming
        streamingStates.set(conversation_id, true);
        
        // Acumular chunk apenas para renderização final
        if (!streamingChunks.has(conversation_id)) {
            streamingChunks.set(conversation_id, '');
        }
        streamingChunks.set(conversation_id, streamingChunks.get(conversation_id) + content);
        
        // Verificar se há um ID de mensagem
        const messageId = message_id || streamingMessageIds.get(conversation_id) || `streaming_${conversation_id}_${Date.now()}`;
        
        // Atualizar o ID da mensagem em streaming para esta conversa
        streamingMessageIds.set(conversation_id, messageId);

        // Usar o sistema unificado de renderização com messageRegistry
        renderMessageChunk(messageId, content, conversation_id);
    });

    // Listener para resposta completa
    socket.on('response_complete', (data) => {
        logger.debug('Evento response_complete recebido', {
            messageId: data.message_id,
            conversaAtual: window.conversaAtual?.id,
            conversationId: data.conversation_id,
            finalMessageId: streamingMessageIds.get(data.conversation_id) 
        });

        const { conversation_id, total_chunks, message_id, complete_response } = data;
        if (!conversation_id) {
            logger.error('ID da conversa não fornecido na resposta completa');
            return;
        }

        // Verifica se é a conversa atual
        if (window.conversaAtual?.id !== conversation_id) {
            logger.debug('Ignorando resposta de outra conversa', {
                atual: window.conversaAtual?.id,
                recebido: conversation_id
            });
            return;
        }

        // ID da mensagem de streaming que foi gerado no enviarMensagem
        const streamingId = streamingMessageIds.get(conversation_id);
        
        // ID da mensagem recebido do servidor
        const serverId = message_id;
        
        // Usar o ID consistente durante todo o ciclo
        const finalMessageId = streamingId || serverId;
        
        logger.info('IDs de mensagem envolvidos na conclusão:', {
            streamingId: streamingId,
            serverId: serverId,
            finalMessageId: finalMessageId
        });
        
        // Verificar se existem elementos com esses IDs
        const streamingElement = document.querySelector(`[data-message-id="${streamingId}"]`);
        const serverElement = document.querySelector(`[data-message-id="${serverId}"]`);
        
        logger.debug('Elementos existentes:', {
            streamingElement: streamingElement ? true : false,
            serverElement: serverElement ? true : false
        });

        // Remove estado de streaming
        const wasStreaming = streamingStates.delete(conversation_id);
        streamingMessageIds.delete(conversation_id);
        processedChunks.delete(conversation_id);
        lastReceivedChunks.delete(conversation_id);
        
        logger.debug('Estado de streaming removido', {
            conversationId: conversation_id,
            messageId: finalMessageId,
            wasStreaming: wasStreaming
        });
        
        // Verificar se já existe uma mensagem completa para evitar duplicação
        const existingCompleteMessage = document.querySelector(`.message.assistant:not(.streaming)[data-conversation-id="${conversation_id}"]:last-child`);
        
        if (existingCompleteMessage && existingCompleteMessage.dataset.messageId !== finalMessageId) {
            logger.warn('Mensagem completa já existe, evitando duplicação', {
                existingId: existingCompleteMessage.dataset.messageId,
                finalMessageId: finalMessageId
            });
            
            // Se temos um elemento de streaming, vamos removê-lo para evitar duplicação
            if (streamingElement) {
                logger.info('Removendo elemento de streaming redundante', {
                    streamingId: streamingId
                });
                streamingElement.remove();
            }
            
            return;
        }
        
        // Finalizar a mensagem usando o messageRegistry
        if (finalMessageId) {
            // Obter o conteúdo completo acumulado para esta conversa
            const completeContent = complete_response || streamingChunks.get(conversation_id) || '';
            
            logger.debug('Completando mensagem com conteúdo final', {
                messageId: finalMessageId,
                contentLength: completeContent.length,
                hasCompleteResponse: !!complete_response
            });
            
            // Finalizar a mensagem transformando o container de streaming em um container completo
            try {
                // Finalizar a mensagem passando os parâmetros corretos
                completeMessage(finalMessageId, conversation_id, completeContent);
                
                // Limpar o conteúdo acumulado
                streamingChunks.delete(conversation_id);
            } catch (error) {
                logger.error('Erro ao completar mensagem', {
                    error: error.message,
                    stack: error.stack,
                    messageId: finalMessageId
                });
            }
        }
    });
} else {
    socket = window.socket;
}

/**
 * Entra na sala de uma conversa específica
 * Esta função implementa um comportamento crucial:
 * 1. Entra imediatamente na nova sala
 * 2. Só sai da sala anterior APÓS o evento response_complete, se houver streaming ativo
 * 3. Sai imediatamente da sala anterior se não houver streaming
 * 
 * Este comportamento impede a perda de chunks durante a troca de conversas
 * 
 * @param {string} conversationId - ID da conversa
 * @return {Promise} Promessa resolvida após entrar na sala
 */
export function entrarNaSala(conversationId) {
    // Armazenar conversa anterior para controle de fluxo
    const previousConversationId = currentConversationId;
    currentConversationId = conversationId;
    
    return new Promise((resolve, reject) => {
        if (!socket) {
            logger.error('Socket não disponível para entrar na sala');
            reject(new Error('Socket não disponível'));
            return;
        }

        // PASSO 1: Entrar na nova sala imediatamente
        socket.emit('join_conversation', { conversation_id: conversationId });
        logger.info(`Entrou na sala da nova conversa: ${conversationId}`);
        
        // PASSO 2: Processar saída da sala anterior dependendo se há streaming
        if (previousConversationId && currentStreamingMessageId) {
            // Se há streaming ativo, adiar a saída até resposta estar completa
            socket.once('response_complete', (data) => {
                if (data.conversation_id === previousConversationId && 
                    data.message_id === currentStreamingMessageId) {
                    socket.emit('leave_conversation', { conversation_id: previousConversationId });
                    logger.info(`Saiu da sala anterior: ${previousConversationId} após response_complete`);
                    currentStreamingMessageId = null; // Resetar o ID da mensagem
                }
            });
        } else if (previousConversationId) {
            // Se não houver mensagem em andamento, sair imediatamente
            socket.emit('leave_conversation', { conversation_id: previousConversationId });
            logger.info(`Saiu da sala anterior: ${previousConversationId} imediatamente`);
        }
        
        resolve();
    });
}

/**
 * Sai da sala de uma conversa específica
 * Implementa comportamento complementar à função entrarNaSala:
 * - Se houver streaming ativo, adia a saída para evitar perda de dados
 * - Se não houver streaming, sai imediatamente
 * 
 * @param {string} conversationId - ID da conversa
 * @return {Promise} Promessa resolvida após sair da sala
 */
export function sairDaSala(conversationId) {
    // Se for a conversa atual com streaming, não sair ainda
    if (conversationId === currentConversationId && currentStreamingMessageId) {
        logger.info(`Adiando saída da sala: ${conversationId} devido a streaming ativo`);
        return Promise.resolve(); // Não sai agora, será tratado no response_complete
    }

    return new Promise((resolve, reject) => {
        if (!socket) {
            logger.error('Socket não disponível para sair da sala');
            reject(new Error('Socket não disponível'));
            return;
        }

        socket.emit('leave_conversation', { conversation_id: conversationId });
        logger.info(`Saiu da sala: ${conversationId}`);
        
        // Limpar currentConversationId se estiver saindo da conversa atual
        if (conversationId === currentConversationId) {
            currentConversationId = null;
        }
        
        resolve();
    });
}

function inicializarConversa(conversationId) {
    if (!window.conversations[conversationId]) {
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null
        };
    }
    return window.conversations[conversationId];
}

// Função para atualizar os botões com base na conversa atual
export function atualizarBotoes(sendBtn, stopBtn) {
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        // Se não houver conversa ativa, mostrar apenas o botão de enviar
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation && conversation.streaming) {
        sendBtn.style.display = 'none';
        stopBtn.style.display = 'flex';
    } else {
        sendBtn.style.display = 'flex';
        stopBtn.style.display = 'none';
    }
}

// Função para verificar se o usuário está no final do chat
function isUserAtBottom(container) {
    const threshold = 50; // pixels de tolerância
    return container.scrollHeight - container.scrollTop <= container.clientHeight + threshold;
}

// Função para rolar suavemente para o final
function scrollToBottom(container) {
    requestAnimationFrame(() => {
        container.scrollTo({
            top: container.scrollHeight,
            behavior: 'smooth'
        });
    });
}

// Função para gerenciar scroll durante streaming
function handleStreamingScroll(container, content) {
    let userScrolledUp = false;
    let scrollTimeout = null;
    
    const scrollListener = () => {
        userScrolledUp = !isUserAtBottom(container);
        
        // Limpar timeout anterior
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
        
        // Se o usuário rolar para baixo até o final, resetar o estado
        if (userScrolledUp && isUserAtBottom(container)) {
            userScrolledUp = false;
        }
    };
    
    // Adicionar listener de scroll
    container.addEventListener('scroll', scrollListener);
    
    // Retornar função para limpar o listener
    return () => {
        container.removeEventListener('scroll', scrollListener);
        if (scrollTimeout) {
            clearTimeout(scrollTimeout);
        }
    };
}

// Função auxiliar para forçar renderização
function forcarRenderizacao(elemento) {
    // Forçar reflow
    void elemento.offsetHeight;
    
    // Usar requestAnimationFrame para garantir a renderização
    requestAnimationFrame(() => {
        elemento.style.opacity = '1';
        elemento.style.transform = 'translateY(0)';
        
        // Segundo frame para garantir que a transição seja aplicada
        requestAnimationFrame(() => {
            if (elemento.parentElement) {
                elemento.parentElement.scrollTop = elemento.parentElement.scrollHeight;
            }
        });
    });
}

// Função para verificar se uma mensagem é duplicada
function isDuplicateMessage(conversationId, content) {
    const key = `${conversationId}:${content}`;
    const lastSentTime = sentMessages.get(key);
    const now = Date.now();
    
    // Se a mensagem foi enviada nos últimos 2 segundos, é considerada duplicata
    if (lastSentTime && (now - lastSentTime) < 2000) {
        logger.debug('Mensagem duplicada detectada', {
            conversationId,
            content: content.substring(0, 20) + '...',
            timeDiff: now - lastSentTime
        });
        return true;
    }
    
    sentMessages.set(key, now);
    return false;
}

// Função para enviar mensagem
export async function enviarMensagem(mensagem, input, chatContainer, sendBtn, stopBtn) {
    logger.info('Iniciando envio de mensagem', { 
        mensagemTamanho: mensagem?.length || 0,
        conversaAtual: window.conversaAtual?.id
    });
    
    if (!mensagem || !chatContainer) {
        logger.warn('Parâmetros inválidos para envio de mensagem', { 
            mensagemValida: !!mensagem, 
            chatContainerValido: !!chatContainer 
        });
        return;
    }

    if (!window.conversaAtual) {
        logger.info('Nenhuma conversa ativa, criando nova');
        criarNovaConversa();
    }

    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        logger.error('ID da conversa não definido após tentativa de criação');
        return;
    }

    // Gerar um messageId único
    // Usando função local para evitar dependência direta do messageRegistry
    const messageId = gerarMessageId();
    
    logger.trackMessage('enviando', messageId, conversationId, {
        mensagemTamanho: mensagem?.length || 0,
        timestamp: new Date().toISOString()
    });

    // Verificar se é um comando para resumir YouTube
    if (mensagem.toLowerCase().startsWith('/youtube_resumo')) {
        logger.trackMessage('comando_youtube_resumo', messageId, conversationId, { mensagem });
        try {
            await handleYoutubeResumoCommand(mensagem, conversationId, chatContainer);
            logger.trackMessage('comando_youtube_resumo_success', messageId, conversationId);
        } catch (error) {
            logger.trackMessage('comando_youtube_resumo_error', messageId, conversationId, { 
                error: error.message,
                stack: error.stack
            });
        }
        return;
    }
    
    // Verificar se é um comando de YouTube
    if (mensagem.toLowerCase().startsWith('/youtube')) {
        logger.trackMessage('comando_youtube', messageId, conversationId, { mensagem });
        try {
            await handleYoutubeCommand(mensagem, conversationId, chatContainer);
            logger.trackMessage('comando_youtube_success', messageId, conversationId);
        } catch (error) {
            logger.trackMessage('comando_youtube_error', messageId, conversationId, { 
                error: error.message,
                stack: error.stack
            });
        }
        return;
    }

    // Verificar duplicação de mensagem
    if (isDuplicateMessage(conversationId, mensagem)) {
        logger.trackMessage('duplicada', messageId, conversationId, {
            mensagemPreview: mensagem.substring(0, 30)
        });
        return;
    }

    try {
        logger.debug('Desabilitando interface durante envio', {
            sendBtnState: sendBtn ? 'disabled' : 'not-found',
            stopBtnState: stopBtn ? 'visible' : 'not-found'
        });
        
        // Desabilitar a interface durante o envio
        if (sendBtn) sendBtn.disabled = true;
        if (stopBtn) stopBtn.style.display = 'flex';

        // Limpar o input
        if (input) {
            input.value = '';
            input.style.height = 'auto';
        }

        // Adicionar mensagem do usuário ao chat
        const userTimestamp = new Date().toISOString();
        const userMessageId = `user_${conversationId}_${Date.now()}`;
        logger.debug('Adicionando mensagem do usuário ao DOM', { userMessageId });
        
        const userMessageDiv = document.createElement('div');
        userMessageDiv.className = 'message user';
        userMessageDiv.dataset.messageId = userMessageId;
        userMessageDiv.dataset.conversationId = conversationId;
        userMessageDiv.innerHTML = `
            <div class="message-content">${renderMessage(mensagem)}</div>
            <div class="message-actions">
                <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                    <i class="fas fa-copy"></i>
                </button>
            </div>
        `;
        chatContainer.appendChild(userMessageDiv);
        
        // Mostrar carregamento usando chatUI
        const loadingDiv = chatUI.mostrarCarregamento();
        
        // Remover placeholders existentes para evitar duplicação
        logger.debug('Removendo placeholders de mensagens existentes');
        const existingPlaceholders = chatContainer.querySelectorAll('.message.assistant:not([data-message-id])');
        existingPlaceholders.forEach(placeholder => placeholder.remove());
        
        // Gerar ID único para a mensagem e registrar como mensagem em streaming atual
        // Isso permite que o sistema saiba qual mensagem está sendo processada
        const messageId = `msg_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
        currentStreamingMessageId = messageId;
        
        // Verificar se já existe alguma mensagem com este ID
        const existingElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (existingElement) {
            logger.warn('Detectado elemento existente com mesmo ID (improvável)', {
                messageId,
                element: existingElement.outerHTML.substring(0, 100)
            });
        }
        
        // Adicionar mensagem em streaming usando chatUI
        const messageElement = chatUI.adicionarMensagemStreaming(messageId, conversationId);
        
        // Ativar estado de streaming para esta conversa
        streamingStates.set(conversationId, true);
        
        // Entrar na sala Socket.IO para esta conversa
        entrarNaSala(conversationId);
        
        // Rolar para o final
        chatContainer.scrollTo({
            top: chatContainer.scrollHeight,
            behavior: 'smooth'
        });
        
        // Salvar a mensagem do usuário no histórico local
        adicionarMensagemAoHistorico(mensagem, 'user', conversationId);
        
        // Marcar mensagem como enviada para evitar duplicação
        sentMessages.set(`${conversationId}-${mensagem}`, Date.now());
        
        logger.info('Enviando mensagem para o backend', { 
            conversationId,
            endpoint: '/send_message'
        });
        
        // Enviar a mensagem para o servidor
        const response = await fetch('/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: mensagem,
                conversation_id: conversationId,
                timestamp: userTimestamp
            })
        });
        
        if (!response.ok) {
            throw new Error(`Erro na resposta do servidor: ${response.status}`);
        }
        
        logger.info('Mensagem enviada com sucesso, aguardando resposta streaming', { conversationId });
        
        // Indicar que este stream está ativo
        activeStreams.add(conversationId);
        
        // A resposta é processada assincronamente pelos listeners de Socket.IO
        
    } catch (error) {
        logger.error('Falha ao enviar mensagem', { 
            error: error.message,
            stack: error.stack,
            conversationId
        });
        
        // Ocultar a animação de carregamento em caso de erro
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation) {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após erro');
        }
        
        // Remover estado de streaming em caso de erro
        streamingStates.delete(conversationId);
        
        // Mostrar mensagem de erro no chat
        const errorDiv = document.createElement('div');
        errorDiv.className = 'message assistant error';
        errorDiv.innerHTML = '<div class="message-content">Erro ao processar a mensagem. Por favor, tente novamente.</div>';
        chatContainer.appendChild(errorDiv);
        
    } finally {
        logger.debug('Restaurando estado da interface após envio');
        // Restaurar a interface após o envio (bem-sucedido ou não)
        if (sendBtn) sendBtn.disabled = false;
        if (stopBtn) stopBtn.style.display = 'none';
    }
}

// Função local para gerar messageId
function gerarMessageId() {
    return `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
}

// Adicionar MutationObserver para garantir renderização
const chatContainer = document.querySelector('.chat-container');
if (chatContainer) {
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
            }
        });
    });

    observer.observe(chatContainer, { 
        childList: true, 
        subtree: true 
    });
}

// Adicionar listener para atualização de conversa
socket.on('conversation_updated', (data) => {
    // console.log('[DEBUG] Evento conversation_updated recebido:', {
    //     data,
    //     conversaAtual: window.conversaAtual?.id,
    //     streamingStates: Array.from(streamingStates.entries())
    // });

    const { conversation_id } = data;
    if (window.conversaAtual?.id === conversation_id) {
        // console.log('[DEBUG] Atualizando conversa atual:', conversation_id);
        const chatContainer = document.querySelector('.chat-container');
        if (!chatContainer) {
            // console.warn('[DEBUG] Container do chat não encontrado');
            return;
        }

        // Remove mensagens de carregamento antigas
        const loadingMessages = chatContainer.querySelectorAll('.message.assistant.loading');
        loadingMessages.forEach(msg => {
            // console.log('[DEBUG] Removendo mensagem de carregamento antiga:', {
            //     id: msg.dataset.conversationId,
            //     classes: msg.className
            // });
            msg.remove();
        });

        // Mapeia mensagens existentes
        const existingMessages = new Map(
            Array.from(chatContainer.querySelectorAll('.message')).map(msg => [
                msg.dataset.messageId,
                msg
            ])
        );

        // console.log('[DEBUG] Mensagens existentes:', {
        //     total: existingMessages.size,
        //     ids: Array.from(existingMessages.keys())
        // });

        fetch(`/get_conversation/${conversation_id}/0/20`)
            .then(response => response.json())
            .then(data => {
                if (data.messages) {
                    data.messages.forEach(msg => {
                        const messageId = msg.timestamp;
                        let existingMsg = existingMessages.get(messageId);

                        // Se for uma nova mensagem do assistente, remover o placeholder de carregamento
                        if (msg.role === 'assistant' && !existingMsg) {
                            // console.log('[DEBUG] Nova mensagem do assistente detectada, removendo placeholder');
                            // Ao receber uma nova mensagem do assistente, esconder a animação centralizada
                            const loadingAnimation = document.getElementById('loading-animation');
                            if (loadingAnimation && loadingAnimation.style.display === 'block') {
                                loadingAnimation.style.display = 'none';
                                logger.debug('Animação de carregamento ocultada após receber nova mensagem');
                            }
                            
                            // Remover estado de streaming
                            streamingStates.delete(conversation_id);
                        }

                        if (!existingMsg) {
                            // Procurar por uma mensagem com conteúdo idêntico
                            for (const [id, elem] of existingMessages) {
                                const content = elem.querySelector('.message-content').innerHTML;
                                if (content === renderMessage(msg.content) && elem.classList.contains(msg.role)) {
                                    existingMsg = elem;
                                    // console.log('[DEBUG] Encontrada mensagem correspondente por conteúdo:', {
                                    //     oldId: id,
                                    //     newId: messageId,
                                    //     role: msg.role
                                    // });
                                    elem.dataset.messageId = messageId;
                                    existingMessages.delete(id);
                                    existingMessages.set(messageId, elem);
                                    break;
                                }
                            }
                        }

                        if (existingMsg) {
                            // console.log('[DEBUG] Atualizando mensagem existente:', {
                            //     messageId,
                            //     role: msg.role
                            // });
                            const currentContent = existingMsg.querySelector('.message-content').innerHTML;
                            const newContent = renderMessage(msg.content);
                            if (currentContent !== newContent) {
                                existingMsg.querySelector('.message-content').innerHTML = newContent;
                            }
                        } else {
                            // console.log('[DEBUG] Adicionando nova mensagem:', {
                            //     messageId,
                            //     role: msg.role
                            // });
                            const messageDiv = document.createElement('div');
                            messageDiv.className = `message ${msg.role}`;
                            messageDiv.dataset.messageId = messageId;
                            messageDiv.dataset.conversationId = conversation_id;
                            messageDiv.innerHTML = `
                                <div class="message-content">${renderMessage(msg.content)}</div>
                                <div class="message-actions">
                                    <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                    ${msg.role === 'assistant' ? `
                                        <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                                            <i class="fas fa-redo"></i>
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                            chatContainer.appendChild(messageDiv);
                            forcarRenderizacao(messageDiv);
                        }
                        existingMessages.delete(messageId);
                    });

                    // Verifica se ainda há placeholders após atualizar
                    const remainingPlaceholders = chatContainer.querySelectorAll('.message.assistant:not([data-message-id])');
                    if (remainingPlaceholders.length > 0) {
                        // console.warn('[DEBUG] Placeholders encontrados após atualização:', {
                        //     quantidade: remainingPlaceholders.length,
                        //     elementos: Array.from(remainingPlaceholders).map(p => ({
                        //         id: p.dataset.conversationId,
                        //         classes: p.className,
                        //         content: p.textContent
                        //     }))
                        // });

                        // Remove placeholders se a conversa não estiver mais em streaming
                        if (!streamingStates.has(conversation_id)) {
                            // console.log('[DEBUG] Removendo placeholders pois conversa não está mais em streaming');
                            remainingPlaceholders.forEach(p => p.remove());
                        }
                    }
                    
                    // Esconder animação centralizada se a conversa não estiver mais em streaming
                    if (!streamingStates.has(conversation_id)) {
                        const loadingAnimation = document.getElementById('loading-animation');
                        if (loadingAnimation && loadingAnimation.style.display === 'block') {
                            loadingAnimation.style.display = 'none';
                            logger.debug('Animação de carregamento ocultada após atualização da conversa');
                        }
                    }
                }

                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
            })
            .catch(error => console.error('[ERRO] Falha ao atualizar conversa:', error));
    }
});

// Função para interromper resposta atual
export function interromperResposta() {
    logger.info('Iniciando interrupção de resposta');
    const conversationId = window.conversaAtual?.id;
    
    if (!conversationId) {
        logger.warn('Tentativa de interromper resposta sem conversa ativa');
        return;
    }
    
    if (!streamingStates.has(conversationId)) {
        logger.warn('Nenhum streaming ativo para interromper', { conversationId });
        return;
    }
    
    // Ocultar a animação de carregamento
    const loadingAnimation = document.getElementById('loading-animation');
    if (loadingAnimation) {
        loadingAnimation.style.display = 'none';
        logger.debug('Animação de carregamento ocultada após interrupção');
    }
    
    logger.debug('Removendo estado de streaming', { conversationId });
    streamingStates.delete(conversationId);
    
    // Limpar estado acumulado
    clearAccumulatedResponse(conversationId);
    
    // Remover da lista de streams ativos
    activeStreams.delete(conversationId);
    
    logger.debug('Removendo mensagens de streaming do DOM');
    const chatContainer = document.querySelector('.chat-container');
    if (chatContainer) {
        // Remover apenas mensagens de loading antigas (se houver)
        chatContainer.querySelectorAll('.message.assistant.loading')
            .forEach(msg => {
                logger.debug('Removendo mensagem loading', { 
                    id: msg.dataset.messageId, 
                    conversationId: msg.dataset.conversationId 
                });
                msg.remove();
            });
    }
    
    logger.info('Resposta interrompida com sucesso', { conversationId });
}

export function carregarConversa(conversationId) {
    // console.log('[DEBUG] Carregando conversa:', conversationId);
    window.conversaAtual = { id: conversationId };
    
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) {
        // console.warn('[DEBUG] Container do chat não encontrado ao carregar conversa');
        return;
    }

    // Limpa o container
    chatContainer.innerHTML = '';

    // Carrega mensagens existentes
    fetch(`/get_conversation/${conversationId}/0/20`)
        .then(response => response.json())
        .then(data => {
            if (data.messages) {
                data.messages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.role}`;
                    messageDiv.dataset.messageId = msg.timestamp;
                    messageDiv.dataset.conversationId = conversationId;
                    messageDiv.innerHTML = `
                        <div class="message-content">${renderMessage(msg.content)}</div>
                        <div class="message-actions">
                            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                                <i class="fas fa-copy"></i>
                            </button>
                            ${msg.role === 'assistant' ? `
                                <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                                    <i class="fas fa-redo"></i>
                                </button>
                            ` : ''}
                        </div>
                    `;
                    chatContainer.appendChild(messageDiv);
                });
            }

            // Verifica se a conversa está em streaming
            const isStreaming = streamingStates.has(conversationId);
            // console.log('[DEBUG] Verificando estado de streaming:', {
            //     conversationId,
            //     isStreaming,
            //     allStates: Array.from(streamingStates.entries())
            // });

            if (isStreaming) {
                // console.log('[DEBUG] Conversa em streaming detectada, recriando placeholder');
                // Mostrar a animação de carregamento centralizada em vez do placeholder antigo
                const loadingAnimation = document.getElementById('loading-animation');
                if (loadingAnimation) {
                    loadingAnimation.style.display = 'block';
                    logger.debug('Animação de carregamento exibida ao carregar conversa em streaming');
                }
                
                // Rolar para o final suavemente
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }
        })
        .catch(error => {
            console.error('[ERRO] Falha ao carregar conversa:', error);
            chatContainer.innerHTML = '<div class="error-message">Erro ao carregar a conversa. Por favor, tente novamente.</div>';
        });
}

// Monitoramento periódico de streams ativos
setInterval(() => {
    try {
        logger.debug('Monitorando streams ativos', {
            streamingMessages: Array.from(streamingMessages),
            messageRegistry: Array.from(messageRegistry.messages.keys())
        });
        
        // Verificar mensagens órfãs
        document.querySelectorAll('.message-content:empty').forEach(container => {
            const messageElement = container.closest('.message');
            if (messageElement) {
                const messageId = messageElement.dataset.messageId;
                if (messageId) {
                    logger.warn('Container órfão detectado', { messageId });
                    cleanupOrphan(messageId);
                }
            }
        });
        
    } catch (error) {
        logger.error('Erro no monitoramento de streams', { 
            error: error.message,
            stack: error.stack 
        });
    }
}, 10000);


==========================================
Conteúdo de chatStorage.js (caminho: static\js\chat\chatStorage.js):
==========================================
import { chatUI } from './chatUI.js';
import { atualizarBotoes } from './chatActions.js';
import { entrarNaSalaDeConversa } from './chatSync.js';
import { melhorarBlocosCodigo, escapeHTML } from './chatUtils.js';
import { renderMessage } from '../messageRenderer.js';

// Cache para conversas já carregadas
const conversationCache = {};

// Controle de carregamento de conversas
const loadingConversations = new Set();

export function carregarConversa(id) {
    // Evita carregar a mesma conversa múltiplas vezes
    if (loadingConversations.has(id)) {
        // console.log(`[INFO] Conversa ${id} já está sendo carregada`);
        return;
    }
    
    console.log(`[DEBUG-JS] carregarConversa em chatStorage.js chamada para conversa ID: ${id}`);
    loadingConversations.add(id);
    
    // Reset the current view
    const chatContainer = document.querySelector('.chat-container');
    const welcomeScreen = document.querySelector('.welcome-screen');
    const inputContainer = document.querySelector('.input-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        loadingConversations.delete(id);
        return;
    }
    
    // Show loading indicator
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '<div class="loading-indicator">Carregando conversa...</div>';
    
    // Primeiro, carregamos apenas os metadados da conversa
    fetch(`/get_conversation/${id}`)
        .then(response => {
            if (!response.ok) throw new Error('HTTP error: ' + response.status);
            return response.json();
        })
        .then(conversa => {
            console.log(`[DEBUG-JS] Dados da conversa ${id} recebidos com sucesso do backend`);
            if (conversa.error) {
                console.error('Erro ao carregar conversa:', conversa.error);
                chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
                return;
            }
            
            // Normalizar estrutura da conversa
            if (!conversa.messages) {
                conversa.messages = conversa.mensagens || [];
                delete conversa.mensagens;
            }
            
            if (!Array.isArray(conversa.messages)) {
                console.error('[ERRO] Messages não é um array, corrigindo...');
                conversa.messages = [];
            }
            
            if (conversa.titulo) {
                conversa.title = conversa.titulo;
                delete conversa.titulo;
            }
            
            // Armazenar conversa atual e atualizar cache de conversas
            window.conversaAtual = {
                ...conversa,
                messages: [] // Inicialmente vazio, será carregado por lotes
            };
            
            if (!window.conversas) window.conversas = [];
            window.conversas = window.conversas.map(c => 
                c.id === conversa.id ? conversa : c
            );

            // Adicionar à estrutura de conversas global por ID
            if (!window.conversations) window.conversations = {};
            
            // Preservar o estado de streaming se já existir
            const existingConversation = window.conversations[id];
            window.conversations[id] = {
                data: conversa,
                streaming: existingConversation ? existingConversation.streaming : false,
                currentResponse: existingConversation ? existingConversation.currentResponse : '',
                eventSource: existingConversation ? existingConversation.eventSource : null,
                abortController: existingConversation ? existingConversation.abortController : null,
                pendingUpdates: false,
                totalMessages: conversa.messages.length,
                loadedMessages: new Set(), // Limpar o conjunto de mensagens carregadas
                isLoading: false // Controle de estado de carregamento
            };
            
            // Limpar o container e preparar para lazy loading
            chatContainer.innerHTML = '';
            
            // console.log(`[DEBUG] Iniciando carregamento da conversa ${id}`);
            
            // Iniciar o carregamento assíncrono das mensagens em lotes
            carregarMensagensEmLotes(id, 0, 20);  // Carrega as primeiras 20 mensagens

            // Entrar na sala de WebSocket para esta conversa
            entrarNaSalaDeConversa(id);
            
            // Atualizar lista de conversas para refletir o chat ativo
            atualizarListaConversas();
            
            window.dispatchEvent(new CustomEvent('conversaCarregada'));
            window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        })
        .catch(error => {
            console.error('Erro ao carregar conversa:', error);
            chatContainer.innerHTML = '<div class="error-message">Erro ao carregar conversa</div>';
        })
        .finally(() => {
            loadingConversations.delete(id);
        });
}

// Nova função para carregar mensagens em lotes
function carregarMensagensEmLotes(conversationId, offset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        return;
    }
    
    if (!window.conversations || !window.conversations[conversationId]) {
        console.error('[ERRO] Conversa não encontrada na estrutura global');
        return;
    }
    
    const conversation = window.conversations[conversationId];
    if (conversation.isLoading) {
        // console.log('[INFO] Carregamento já em andamento, ignorando');
        return;
    }
    
    conversation.isLoading = true;
    
    // Mostrar indicador apenas no primeiro lote
    if (offset === 0) {
        chatContainer.innerHTML = ''; // Limpa o container ao iniciar novo carregamento
        if (!chatContainer.querySelector('.loading-indicator')) {
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.textContent = 'Carregando mensagens...';
            loadingIndicator.id = 'loading-indicator';
            chatContainer.appendChild(loadingIndicator);
        }
    }
    
    // console.log(`[DEBUG] Carregando lote: offset=${offset}, limit=${limit}`);
    
    fetch(`/get_conversation/${conversationId}/${offset}/${limit}`)
        .then(response => response.json())
        .then(data => {
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                chatContainer.removeChild(loadingIndicator);
            }
            
            if (data.error) {
                console.error('Erro ao carregar mensagens:', data.error);
                conversation.isLoading = false;
                return;
            }
            
            const messages = data.messages || [];
            const hasMore = data.hasMore || false;
            const total = data.total || 0;
            
            if (offset === 0 && messages.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'Nenhuma mensagem nesta conversa.';
                chatContainer.appendChild(emptyMessage);
                conversation.isLoading = false;
                return;
            }
            
            const fragment = document.createDocumentFragment();
            const loadedMessages = conversation.loadedMessages || new Set();
            
            messages.forEach((msg) => {
                const messageId = msg.timestamp || `${conversationId}_${Date.now()}_${msg.content.slice(0, 20)}`;
                
                // Verifica se a mensagem já foi carregada
                if (!loadedMessages.has(messageId) && 
                    !document.querySelector(`.message[data-message-id="${messageId}"]`)) {
                    loadedMessages.add(messageId);
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.role}`;
                    messageDiv.dataset.messageId = messageId;
                    messageDiv.dataset.conversationId = conversationId;
                    
                    const messageContent = document.createElement('div');
                    messageContent.className = 'message-content';
                    messageContent.innerHTML = msg.role === 'assistant' ? 
                        renderMessage(msg.content) : 
                        `<p>${escapeHTML(msg.content).replace(/\n/g, '<br>')}</p>`;
                    
                    const messageActions = document.createElement('div');
                    messageActions.className = 'message-actions';
                    messageActions.innerHTML = `
                        <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                            <i class="fas fa-copy"></i>
                        </button>
                        ${msg.role === 'assistant' ? `
                            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                                <i class="fas fa-redo"></i>
                            </button>
                        ` : ''}
                    `;
                    
                    messageDiv.appendChild(messageContent);
                    messageDiv.appendChild(messageActions);
                    
                    if (offset === 0) {
                        fragment.appendChild(messageDiv);
                    } else {
                        fragment.insertBefore(messageDiv, fragment.firstChild);
                    }
                }
            });
            
            if (fragment.children.length > 0) {
                if (offset === 0) {
                    chatContainer.appendChild(fragment);
                } else {
                    chatContainer.insertBefore(fragment, chatContainer.firstChild);
                }
                
                setTimeout(() => melhorarBlocosCodigo(), 100);
            }
            
            conversation.isLoading = false;
            
            if (hasMore && loadedMessages.size < total) {
                configureScrollListener(conversationId, offset + limit, limit);
            } else if (chatContainer._scrollListener) {
                chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
                chatContainer._scrollListener = null;
            }
        })
        .catch(error => {
            console.error('Erro ao carregar mensagens:', error);
            conversation.isLoading = false;
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        });
}

// Configurar detector de scroll para lazy loading
function configureScrollListener(conversationId, nextOffset, limit) {
    const chatContainer = document.querySelector('.chat-container');
    
    if (!chatContainer) {
        console.error('[ERRO] Chat container não encontrado');
        return;
    }
    
    // Remover listener anterior se existir
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
    
    const scrollListener = function() {
        const conversation = window.conversations[conversationId];
        if (!conversation) {
            console.error('[ERRO] Conversa não encontrada na estrutura global');
            return;
        }
        
        if (conversation.isLoading) {
            // console.log('[DEBUG] Carregamento em andamento, ignorando scroll');
            return;
        }
        
        // Verificar se estamos próximos do topo e não estamos carregando
        if (chatContainer.scrollTop < 100) {
            // console.log(`[DEBUG] Scroll no topo, carregando mais mensagens de offset ${nextOffset}`);
            
            // Remover listener antes de carregar para evitar chamadas múltiplas
            chatContainer.removeEventListener('scroll', scrollListener);
            chatContainer._scrollListener = null;
            
            // Carregar próximo lote
            carregarMensagensEmLotes(conversationId, nextOffset, limit);
        }
    };
    
    // Adicionar novo listener
    chatContainer.addEventListener('scroll', scrollListener);
    chatContainer._scrollListener = scrollListener;
    
    // console.log(`[DEBUG] Scroll listener configurado para offset ${nextOffset}`);
}

export function atualizarListaConversas() {
    console.log('[DEBUG-JS] atualizarListaConversas em chatStorage.js chamada');
    
    const chatList = document.querySelector('.chat-list');
    if (!chatList) {
        console.error('[ERRO] Chat list não encontrada');
        return;
    }

    // Limpar qualquer listener existente para evitar duplicação
    if (chatList._clickListener) {
        chatList.removeEventListener('click', chatList._clickListener);
    }

    fetch('/get_conversation_history')
        .then(response => response.json())
        .then(conversas => {
            console.log(`[DEBUG-JS] Recebidas ${conversas.length} conversas do histórico via /get_conversation_history`);
            chatList.innerHTML = '';
            conversas.forEach(conversa => {
                const conversaElement = document.createElement('div');
                conversaElement.className = 'chat-item';
                if (window.conversaAtual && window.conversaAtual.id === conversa.id) {
                    conversaElement.classList.add('active');
                }
                
                conversaElement.dataset.id = conversa.id;
                
                const titulo = conversa.title || conversa.titulo || 'Nova conversa';
                
                const spanTitulo = document.createElement('span');
                spanTitulo.className = 'chat-title';
                spanTitulo.textContent = titulo;
                conversaElement.appendChild(spanTitulo);
                
                const actionButtons = document.createElement('div');
                actionButtons.className = 'action-buttons';
                actionButtons.style.position = 'relative';
                actionButtons.style.zIndex = '100';
                
                // Botão Renomear com ícone
                const renameBtn = document.createElement('button');
                renameBtn.className = 'action-btn rename-btn';
                renameBtn.dataset.id = conversa.id;
                renameBtn.title = 'Renomear conversa';
                renameBtn.innerHTML = '<i class="fas fa-edit"></i>'; // Ícone de lápis para editar
                renameBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao botão
                renameBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // // console.log('[DEBUG] Rename clicked diretamente para ID:', conversa.id);
                    renomearConversa(conversa.id);
                });
                
                // Botão Excluir com ícone
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'action-btn delete-btn';
                deleteBtn.dataset.id = conversa.id;
                deleteBtn.title = 'Excluir conversa';
                deleteBtn.innerHTML = '<i class="fas fa-trash"></i>'; // Ícone de lixeira para excluir
                deleteBtn.style.pointerEvents = 'auto';
                
                // Adicionar listener direto ao botão
                deleteBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    // // console.log('[DEBUG] Delete clicked diretamente para ID:', conversa.id);
                    excluirConversa(conversa.id);
                });
                
                actionButtons.appendChild(renameBtn);
                actionButtons.appendChild(deleteBtn);
                conversaElement.appendChild(actionButtons);
                
                // Evitar que cliques nos botões disparem o carregamento da conversa
                actionButtons.addEventListener('click', function(e) {
                    e.stopPropagation();
                    // // console.log('[DEBUG] Clique capturado em action-buttons');
                });
                
                chatList.appendChild(conversaElement);
            });
            
            // Adicionar listener de delegação também como fallback
            const clickListener = function(e) {
                // // console.log('[DEBUG] Clique detectado em:', e.target);
                
                // Se clicar nos botões, não carrega a conversa
                if (e.target.closest('.action-buttons')) {
                    // // console.log('[DEBUG] Clique em botões, interrompendo propagação');
                    e.stopPropagation();
                    return;
                }
                
                // Verificar se clicou em um botão de renomear
                const renameBtn = e.target.closest('.rename-btn');
                if (renameBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = renameBtn.dataset.id;
                    // // console.log('[DEBUG] Botão renomear clicado para ID:', id);
                    renomearConversa(id);
                    return;
                }
                
                // Verificar se clicou em um botão de excluir
                const deleteBtn = e.target.closest('.delete-btn');
                if (deleteBtn) {
                    e.preventDefault();
                    e.stopPropagation();
                    const id = deleteBtn.dataset.id;
                    // // console.log('[DEBUG] Botão excluir clicado para ID:', id);
                    excluirConversa(id);
                    return;
                }
                
                // Se não clicou em nenhum botão, carrega a conversa
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    const id = chatItem.dataset.id;
                    // // console.log('[DEBUG] Carregando conversa pelo clique:', id);
                    carregarConversa(id);
                }
            };
            
            chatList.addEventListener('click', clickListener);
            chatList._clickListener = clickListener; // Salva a referência para poder remover depois
            
            window.dispatchEvent(new CustomEvent('listaAtualizada'));
        })
        .catch(error => console.error('Erro ao atualizar lista de conversas:', error));
}

export function criarNovaConversa() {
    console.log('[DEBUG-JS] criarNovaConversa em chatStorage.js chamada');
    const novaConversa = {
        id: Date.now().toString(),
        title: "Nova Conversa",
        messages: []
    };
    
    window.conversas = window.conversas || [];
    window.conversas.unshift(novaConversa);
    window.conversaAtual = novaConversa;
    
    // Adicionar à estrutura de conversas global
    if (!window.conversations) window.conversations = {};
    window.conversations[novaConversa.id] = {
        data: novaConversa,
        streaming: false,
        currentResponse: ''
    };
    
    // Atualizar lista de conversas instantaneamente ao criar nova conversa
    atualizarListaConversas();
    window.dispatchEvent(new CustomEvent('historicoAtualizado'));
    console.log(`[DEBUG-JS] Nova conversa criada com ID: ${novaConversa.id}`);
    
    return novaConversa;
}

export function adicionarMensagemAoHistorico(mensagem, tipo, conversationId = null) {
    // Se não especificado, usa a conversa atual
    conversationId = conversationId || (window.conversaAtual ? window.conversaAtual.id : null);
    
    console.log(`[DEBUG-JS] adicionarMensagemAoHistorico em chatStorage.js chamada para conversa ${conversationId}, tipo: ${tipo}`);
    
    if (!conversationId) {
        console.log('[DEBUG-JS] Não há conversa atual, criando uma nova');
        const novaConversa = criarNovaConversa();
        conversationId = novaConversa.id;
    }
    
    // Referência à conversa na estrutura global de conversas
    let conversation = window.conversations[conversationId];
    
    if (!conversation) {
        console.log(`[ERRO-JS] Conversa ${conversationId} não encontrada na estrutura global`);
        return;
    }
    
    // Verificar se a estrutura da conversa no estado global está correta
    if (!window.conversaAtual || !Array.isArray(window.conversaAtual.messages)) {
        // // console.log('[CORREÇÃO] Estado da conversa atual inválido, corrigindo');
        window.conversaAtual = {
            id: conversationId,
            title: window.conversations[conversationId].data.title || "Nova conversa",
            messages: []
        };
        
        // Atualizar na estrutura global
        window.conversations[conversationId].data = window.conversaAtual;
    }
    
    try {
        const message = {
            content: mensagem,
            role: tipo,
            timestamp: new Date().toISOString()
        };
        
        // Adicionar mensagem à UI usando chatUI
        chatUI.adicionarMensagem(message);
        
        // Adicionar mensagem ao histórico da conversa atual
        if (window.conversaAtual && window.conversaAtual.id === conversationId) {
            window.conversaAtual.messages.push(message);
        }
        
        // Adicionar também à estrutura de dados de conversas global
        if (!Array.isArray(window.conversations[conversationId].data.messages)) {
            window.conversations[conversationId].data.messages = [];
        }
        
        window.conversations[conversationId].data.messages.push(message);
        
        // // console.log(`[DEBUG] Mensagem adicionada com sucesso à conversa ${conversationId}`);
        
        window.dispatchEvent(new CustomEvent('historicoAtualizado'));
        window.dispatchEvent(new CustomEvent('mensagemAdicionada'));
        
    } catch (err) {
        console.error(`[ERRO CRÍTICO] Falha ao adicionar mensagem à conversa ${conversationId}:`, err);
    }
    
    // IMPORTANTE: Removido a chamada fetch para /save_message aqui para evitar duplicação
    // O backend já salva a mensagem ao final do streaming
}

export function renomearConversa(id) {
    // // console.log('[DEBUG] Tentando renomear conversa:', id);
    
    const novoTitulo = prompt('Digite o novo título da conversa:');
    if (!novoTitulo || !novoTitulo.trim()) {
        // // console.log('[DEBUG] Operação cancelada pelo usuário');
        return;
    }

    fetch(`/rename_conversation/${id}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: novoTitulo.trim() })
    })
    .then(response => {
        // // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // // console.log('[DEBUG] Conversa renomeada com sucesso');
            
            // Atualizar na conversa atual se for a mesma
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual.title = novoTitulo.trim();
            }
            
            // Atualizar na estrutura global de conversas
            if (window.conversations && window.conversations[id]) {
                window.conversations[id].data.title = novoTitulo.trim();
            }
            
            // Atualizar na lista de conversas em memória
            if (window.conversas) {
                window.conversas = window.conversas.map(c => 
                    c.id === id ? {...c, title: novoTitulo.trim()} : c
                );
            }
            
            // Atualizar a lista de conversas na UI
            atualizarListaConversas();
            
            // Notificar sistema sobre alteração
            window.dispatchEvent(new CustomEvent('conversaAtualizada', { 
                detail: { id, newTitle: novoTitulo.trim() } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha ao renomear:', error);
        alert('Erro ao renomear conversa: ' + error.message);
    });
}

export function excluirConversa(id) {
    // // console.log('[DEBUG] Tentando excluir conversa:', id);
    
    if (!confirm('Tem certeza que deseja excluir esta conversa?')) {
        // // console.log('[DEBUG] Operação cancelada pelo usuário');
        return;
    }

    fetch(`/delete_conversation/${id}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
    })
    .then(response => {
        // // console.log('[DEBUG] Status da resposta:', response.status);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // // console.log('[DEBUG] Resposta do servidor:', data);
        
        if (data.success) {
            // // console.log('[DEBUG] Conversa excluída com sucesso');
            
            // Remover da memória
            if (window.conversas) {
                window.conversas = window.conversas.filter(c => c.id !== id);
            }
            
            // Remover da estrutura global de conversas e finalizar qualquer streaming em andamento
            if (window.conversations && window.conversations[id]) {
                // Interromper streaming se existir
                if (window.conversations[id].abortController) {
                    window.conversations[id].abortController.abort();
                }
                if (window.conversations[id].eventSource) {
                    window.conversations[id].eventSource.close();
                }
                delete window.conversations[id];
            }
            
            // Se a conversa atual foi excluída, voltar para a tela inicial
            if (window.conversaAtual && window.conversaAtual.id === id) {
                window.conversaAtual = null;
                const welcomeScreen = document.querySelector('.welcome-screen');
                const chatContainer = document.querySelector('.chat-container');
                const inputContainer = document.querySelector('.input-container');
                
                welcomeScreen.style.display = 'flex';
                chatContainer.style.display = 'none';
                inputContainer.style.display = 'none';
                
                // Atualizar botões para estado inicial
                const sendBtn = document.getElementById('send-btn');
                const stopBtn = document.getElementById('stop-btn');
                if (sendBtn && stopBtn) {
                    sendBtn.style.display = 'flex';
                    stopBtn.style.display = 'none';
                }
            }
            
            // Atualizar a lista de conversas
            atualizarListaConversas();
            
            // Notificar sistema sobre exclusão
            window.dispatchEvent(new CustomEvent('conversaExcluida', { 
                detail: { id } 
            }));
        } else {
            throw new Error(data.error || 'Erro desconhecido');
        }
    })
    .catch(error => {
        console.error('[ERRO] Falha na requisição:', error);
        alert('Erro ao excluir conversa: ' + error.message);
    });
}


==========================================
Conteúdo de chatSync.js (caminho: static\js\chat\chatSync.js):
==========================================
/**
 * chatSync.js
 * Responsável pela sincronização entre sessões do chat via WebSockets
 */

let socket = null;
let isConnected = false;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 3000; // 3 segundos

/**
 * Inicializa a conexão com WebSocket e configura os listeners
 */
export function inicializarSync() {
    // Tentar obter uma sessionId do localStorage ou criar uma nova
    const sessionId = localStorage.getItem('sessionId') || gerarSessionId();
    localStorage.setItem('sessionId', sessionId);
    
    // Inicializar socket.io
    try {
        // URL atual do documento no navegador para evitar problemas de CORS
        const url = window.location.origin;
        socket = io(url);
        
        // Configurar listeners de conexão
        setupConnectionListeners(sessionId);
        
        // Configurar listeners de eventos
        setupEventListeners();
        
        return true;
    } catch (error) {
        console.error("Erro ao inicializar WebSocket:", error);
        return false;
    }
}

/**
 * Configura os listeners para eventos de conexão
 */
function setupConnectionListeners(sessionId) {
    if (!socket) return;
    
    socket.on('connect', () => {
        isConnected = true;
        reconnectAttempts = 0;
        // Registrar sessão do usuário para notificações
        socket.emit('register_session', { session_id: sessionId });
        
        // Registrar conversa atual (se existir)
        if (window.conversaAtual && window.conversaAtual.id) {
            entrarNaSalaDeConversa(window.conversaAtual.id);
        }
    });
    
    socket.on('disconnect', () => {
        isConnected = false;
    });
    
    socket.on('connect_error', (error) => {
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            reconnectAttempts++;
            setTimeout(() => {
                socket.connect();
            }, RECONNECT_DELAY);
        }
    });
}

/**
 * Configura os listeners para eventos específicos do chat
 */
function setupEventListeners() {
    if (!socket) return;
    
    // Receber fragmento de mensagem em tempo real
    socket.on('message_chunk', (data) => {
        if (!window.conversaAtual || window.conversaAtual.id !== data.conversation_id) {
            // Se não for a conversa atual, apenas atualizar o buffer da conversa
            atualizarBufferDaConversa(data.conversation_id, data.content);
            return;
        }
        
        // Se for a conversa atual e estiver visível, atualizar o buffer
        if (document.visibilityState === 'visible') {
            const conversation = window.conversations[data.conversation_id];
            if (!conversation) return;
            
            if (!conversation.currentResponse) conversation.currentResponse = '';
            conversation.currentResponse += data.content;
            
            // Não precisa mais criar o placeholder, usar a animação centralizada
            const loadingAnimation = document.getElementById('loading-animation');
            
            // Se este é o primeiro chunk, esconder a animação
            if (loadingAnimation && loadingAnimation.style.display === 'block') {
                loadingAnimation.style.display = 'none';
                console.log('[DEBUG] Animação de carregamento ocultada após receber chunk');
            }
            
            // Rolar para o final se o usuário estiver próximo
            const chatContainer = document.querySelector('.chat-container');
            if (!chatContainer) return;
            
            const isNearBottom = chatContainer.scrollHeight - chatContainer.scrollTop <= chatContainer.clientHeight + 100;
            if (isNearBottom) {
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }
        }
    });
    
    // Receber notificação de que uma conversa foi atualizada
    socket.on('conversation_updated', (data) => {
        console.log('[DEBUG] Evento conversation_updated recebido:', data);
        console.log('[DEBUG] Chat ativo:', window.conversaAtual?.id);
        
        // Atualizar lista de conversas
        atualizarListaConversas();
        
        // Se for a conversa atual, atualizar a UI
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            console.log('[DEBUG] Atualizando DOM para conversa atual');
            // Se a aba estiver inativa, recarregar a conversa quando se tornar ativa
            if (document.visibilityState !== 'visible') {
                console.log('[DEBUG] Aba inativa, marcando para recarregar');
                marcarParaRecarregar(data.conversation_id);
            }
        }
    });
    
    // Receber notificação de que uma conversa foi renomeada
    socket.on('conversation_renamed', (data) => {
        // Atualizar no estado local
        if (window.conversas) {
            window.conversas = window.conversas.map(c => 
                c.id === data.conversation_id ? {...c, title: data.new_title} : c
            );
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            window.conversations[data.conversation_id].data.title = data.new_title;
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });
    
    // Receber notificação de que uma conversa foi excluída
    socket.on('conversation_deleted', (data) => {
        // Remover do estado local
        if (window.conversas) {
            window.conversas = window.conversas.filter(c => c.id !== data.conversation_id);
        }
        
        if (window.conversations && window.conversations[data.conversation_id]) {
            delete window.conversations[data.conversation_id];
        }
        
        // Se for a conversa atual, voltar para a tela inicial
        if (window.conversaAtual && window.conversaAtual.id === data.conversation_id) {
            window.conversaAtual = null;
            mostrarTelaInicial();
        }
        
        // Atualizar lista de conversas
        atualizarListaConversas();
    });

    // Listener para evento de teste
    socket.on('test_event', (data) => {
        console.log('[DEBUG] Evento de teste recebido:', data);
        console.log('[DEBUG] Chat ativo:', window.conversaAtual?.id);
        console.log('[DEBUG] Sala atual:', window.salaAtual);
    });
}

/**
 * Entra na sala de uma conversa específica para receber atualizações
 */
export function entrarNaSalaDeConversa(conversationId) {
    if (!socket || !isConnected) {
        console.log('[DEBUG] Socket não disponível ou não conectado');
        return;
    }
    
    console.log(`[DEBUG] Entrando na sala da conversa: ${conversationId}`);
    
    // Sair de todas as salas anteriores primeiro
    if (window.salaAtual) {
        console.log(`[DEBUG] Saindo da sala anterior: ${window.salaAtual}`);
        socket.emit('leave_conversation', { conversation_id: window.salaAtual });
    }
    
    // Entrar na nova sala
    socket.emit('join_conversation', { conversation_id: conversationId });
    window.salaAtual = conversationId;
    console.log(`[DEBUG] Entrou na sala: ${conversationId}`);
}

/**
 * Atualiza o buffer de uma conversa com um novo fragmento de mensagem
 */
function atualizarBufferDaConversa(conversationId, fragmento) {
    if (!window.conversations) window.conversations = {};
    if (!window.conversations[conversationId]) {
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: true,
            currentResponse: fragmento,
            pendingUpdates: true
        };
    } else {
        window.conversations[conversationId].streaming = true;
        window.conversations[conversationId].currentResponse += fragmento;
        window.conversations[conversationId].pendingUpdates = true;
    }
}

/**
 * Marcar uma conversa para ser recarregada quando a aba ficar visível
 */
function marcarParaRecarregar(conversationId) {
    localStorage.setItem('conversaParaRecarregar', conversationId);
}

/**
 * Verificar se há conversas para recarregar quando a aba ficar visível
 */
function verificarRecarregamento() {
    const conversaParaRecarregar = localStorage.getItem('conversaParaRecarregar');
    if (conversaParaRecarregar) {
        localStorage.removeItem('conversaParaRecarregar');
        if (window.conversaAtual && window.conversaAtual.id === conversaParaRecarregar) {
            carregarConversa(conversaParaRecarregar);
        }
    }
}

/**
 * Gera um ID de sessão único
 */
function gerarSessionId() {
    return Date.now().toString() + '-' + Math.random().toString(36).substr(2, 9);
}

// Configurar o listener de visibilidade para sincronização
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        verificarRecarregamento();
        
        // Recarregar lista de conversas
        atualizarListaConversas();
        
        // Se houver uma conversa aberta com atualizações pendentes, recarregá-la
        if (window.conversaAtual && window.conversations && 
            window.conversations[window.conversaAtual.id] && 
            window.conversations[window.conversaAtual.id].pendingUpdates) {
            
            carregarConversa(window.conversaAtual.id);
            window.conversations[window.conversaAtual.id].pendingUpdates = false;
        }
    }
});

// Funções importadas de outros módulos que serão definidas no escopo global
const melhorarBlocosCodigo = window.melhorarBlocosCodigo || function() {};
const carregarConversa = window.carregarConversa || function() {};
const atualizarListaConversas = window.atualizarListaConversas || function() {};
const mostrarTelaInicial = window.mostrarTelaInicial || function() {};

/**
 * Testa a conectividade do Socket.IO
 */
export async function testSocketConnection() {
    if (!window.conversaAtual?.id) {
        console.log('[DEBUG] Nenhuma conversa ativa para testar');
        return;
    }
    
    try {
        console.log('[DEBUG] Testando conectividade do Socket.IO');
        const response = await fetch('/test_socket', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversation_id: window.conversaAtual.id })
        });
        
        const data = await response.json();
        console.log('[DEBUG] Resposta do teste:', data);
    } catch (error) {
        console.error('[ERRO] Falha ao testar conectividade:', error);
    }
}


==========================================
Conteúdo de chatUI.js (caminho: static\js\chat\chatUI.js):
==========================================
import { escapeHTML } from './chatUtils.js';
import { renderMessage, renderMessageChunk, messageRegistry } from '../messageRenderer.js';
import { melhorarBlocosCodigo } from './chatUtils.js';
import { logger } from '../utils/logger.js';

export class ChatUI {
    constructor() {
        logger.info('Inicializando ChatUI', 'chat/chatUI.js');
    }

    adicionarMensagem(message) {
        logger.debug('Chamada adicionarMensagem', 'chat/chatUI.js');
        const chatContainer = document.querySelector('.chat-container');
        return adicionarMensagem(chatContainer, message.content, message.role);
    }

    adicionarMensagemStreaming(messageId, conversationId) {
        logger.debug('Chamada adicionarMensagemStreaming', 'chat/chatUI.js');
        const chatContainer = document.querySelector('.chat-container');
        return adicionarMensagemStreaming(chatContainer, messageId, conversationId);
    }

    atualizarMensagemStreaming(messageId, chunk, renderMarkdown = true) {
        logger.debug('Chamada atualizarMensagemStreaming', 'chat/chatUI.js');
        return atualizarMensagemStreaming(messageId, chunk, renderMarkdown);
    }

    iniciarChat() {
        logger.debug('Chamada iniciarChat', 'chat/chatUI.js');
        const welcomeScreen = document.querySelector('.welcome-screen');
        const chatContainer = document.querySelector('.chat-container');
        const inputContainer = document.querySelector('.input-container');
        iniciarChat(welcomeScreen, chatContainer, inputContainer);
    }

    mostrarCarregamento() {
        logger.debug('Chamada mostrarCarregamento', 'chat/chatUI.js');
        const chatContainer = document.querySelector('.chat-container');
        return mostrarCarregamento(chatContainer);
    }

    mostrarTelaInicial() {
        logger.debug('Chamada mostrarTelaInicial', 'chat/chatUI.js');
        const welcomeScreen = document.querySelector('.welcome-screen');
        const chatContainer = document.querySelector('.chat-container');
        const inputContainer = document.querySelector('.input-container');
        const welcomeInput = document.querySelector('.welcome-input');
        const chatInput = document.querySelector('.chat-input');
        mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput);
    }

    scrollToBottom() {
        logger.debug('Chamada scrollToBottom', 'chat/chatUI.js');
        scrollToBottom();
    }

    updateStreamingMessage(messageId, content) {
        logger.debug('Chamada updateStreamingMessage', 'chat/chatUI.js');
        updateStreamingMessage(messageId, content);
    }

    updateStreamingScroll(messageElement) {
        logger.debug('Chamada updateStreamingScroll', 'chat/chatUI.js');
        updateStreamingScroll(messageElement);
    }
}

// Criar e exportar uma instância única do ChatUI
export const chatUI = new ChatUI();

export function iniciarChat(welcomeScreen, chatContainer, inputContainer) {
    welcomeScreen.style.display = 'none';
    chatContainer.style.display = 'block';
    inputContainer.style.display = 'block';
    chatContainer.innerHTML = '';
    
    // Verificar se há uma conversa carregada na estrutura global
    const conversationId = window.conversaAtual?.id;
    if (conversationId && window.conversations && window.conversations[conversationId]) {
        // console.log(`[DEBUG] Iniciando chat para conversa: ${conversationId}`);
    } else {
        // console.log('[DEBUG] Iniciando chat sem conversa ativa');
    }
}

export function mostrarTelaInicial(welcomeScreen, chatContainer, inputContainer, welcomeInput, chatInput) {
    welcomeScreen.style.display = 'flex';
    chatContainer.style.display = 'none';
    inputContainer.style.display = 'none';
    welcomeInput.value = '';
    if (chatInput) chatInput.value = '';
    
    // Limpar referência da conversa atual para evitar mistura de contextos
    window.conversaAtual = null;
    // console.log('[DEBUG] Retornando para tela inicial, conversa atual limpa');
    
    // Remover qualquer listener de scroll
    if (chatContainer._scrollListener) {
        chatContainer.removeEventListener('scroll', chatContainer._scrollListener);
        chatContainer._scrollListener = null;
    }
}

export function adicionarMensagem(chatContainer, texto, tipo) {
    console.log('[DEBUG] Iniciando adição de mensagem:', {
        tipo,
        tamanhoTexto: texto?.length,
        containerExiste: !!chatContainer
    });

    // Verificar se o contêiner de chat existe
    if (!chatContainer) {
        console.error('[ERRO] Contêiner de chat não encontrado ao adicionar mensagem');
        return;
    }
    
    // Verificar se há uma conversa ativa
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando adicionar mensagem sem conversa ativa');
    }

    console.log('[DEBUG] Contexto da conversa:', {
        conversationId,
        conversaAtual: window.conversaAtual
    });

    // Gerar um ID único para a mensagem
    const messageId = `${Date.now()}_${tipo}_${Math.random().toString(36).substr(2, 9)}`;
    
    // Verificar se a mensagem já existe
    const existingMessage = document.querySelector(`.message[data-message-id="${messageId}"]`);
    if (existingMessage) {
        console.warn('[DEBUG] Mensagem duplicada detectada:', messageId);
        return;
    }
    
    console.log('[DEBUG] Criando novo elemento de mensagem:', messageId);
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = `message ${tipo}`;
    mensagemDiv.dataset.messageId = messageId;
    
    // Associar ID da conversa para garantir isolamento
    if (conversationId) {
        mensagemDiv.dataset.conversationId = conversationId;
    }
    
    console.log('[DEBUG] Processando conteúdo da mensagem');
    // Processamento de Markdown para mensagens do assistente
    let conteudoHtml;
    try {
        if (tipo === 'assistant') {
            console.log('[DEBUG] Renderizando markdown para mensagem do assistente');
            conteudoHtml = renderMessage(texto);
        } else {
            console.log('[DEBUG] Processando texto simples para mensagem do usuário');
            conteudoHtml = `<p>${escapeHTML(texto).replace(/\n/g, '<br>')}</p>`;
        }
        
        console.log('[DEBUG] Conteúdo HTML gerado:', {
            tamanho: conteudoHtml.length,
            preview: conteudoHtml.substring(0, 50) + '...'
        });
    } catch (error) {
        console.error('[ERRO] Falha ao processar conteúdo da mensagem:', error);
        conteudoHtml = `<p>Erro ao processar mensagem</p>`;
    }

    // Criar estrutura da mensagem
    const messageContent = document.createElement('div');
    messageContent.className = 'message-content';
    messageContent.innerHTML = conteudoHtml;

    const messageActions = document.createElement('div');
    messageActions.className = 'message-actions';
    
    // Adicionar botões de ação
    if (tipo === 'assistant') {
        messageActions.innerHTML = `
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                <i class="fas fa-redo"></i>
            </button>
        `;
    } else {
        messageActions.innerHTML = `
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
        `;
    }

    // Montar a mensagem
    mensagemDiv.appendChild(messageContent);
    mensagemDiv.appendChild(messageActions);

    console.log('[DEBUG] Adicionando mensagem ao DOM');
    // Adicionar ao DOM com animação
    mensagemDiv.style.opacity = '0';
    mensagemDiv.style.transform = 'translateY(20px)';
    
    // Verificar novamente se o chatContainer existe antes de adicionar a mensagem
    if (!chatContainer) {
        console.error('[ERRO] Container de chat se tornou null durante o processamento da mensagem');
        return messageId;
    }
    
    chatContainer.appendChild(mensagemDiv);

    // Forçar reflow e aplicar transição
    void mensagemDiv.offsetHeight;
    
    requestAnimationFrame(() => {
        console.log('[DEBUG] Aplicando animação de entrada');
        mensagemDiv.style.opacity = '1';
        mensagemDiv.style.transform = 'translateY(0)';
        
        // Garantir que a mensagem seja visível
        requestAnimationFrame(() => {
            console.log('[DEBUG] Atualizando scroll');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        });
    });

    console.log('[DEBUG] Mensagem adicionada com sucesso:', messageId);
    return messageId;
}

export function mostrarCarregamento(chatContainer) {
    console.log('[DEBUG] Iniciando exibição de carregamento');
    
    if (!chatContainer) {
        console.error('[ERRO] Container não encontrado para mostrar carregamento');
        return null;
    }

    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando mostrar carregamento sem conversa ativa');
    }

    const loadingId = `loading_${Date.now()}`;
    console.log('[DEBUG] Criando elemento de carregamento:', loadingId);

    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message assistant loading';
    loadingDiv.dataset.messageId = loadingId;
    loadingDiv.setAttribute('data-no-markdown', 'true');
    if (conversationId) {
        loadingDiv.dataset.conversationId = conversationId;
    }
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;

    // Adicionar com animação
    loadingDiv.style.opacity = '0';
    
    // Verificar novamente se o chatContainer existe antes de adicionar o carregamento
    if (!chatContainer) {
        console.error('[ERRO] Container de chat se tornou null durante a criação do carregamento');
        return null;
    }
    
    chatContainer.appendChild(loadingDiv);

    // Forçar reflow e aplicar transição
    void loadingDiv.offsetHeight;
    
    requestAnimationFrame(() => {
        console.log('[DEBUG] Aplicando animação do carregamento');
        loadingDiv.style.opacity = '1';
        
        requestAnimationFrame(() => {
            console.log('[DEBUG] Atualizando scroll após carregamento');
            chatContainer.scrollTop = chatContainer.scrollHeight;
        });
    });

    console.log('[DEBUG] Carregamento exibido com sucesso');
    return loadingDiv;
}

export function adicionarMensagemStreaming(chatContainer, messageId, conversationId) {
    logger.debug('Iniciando mensagem de streaming', { messageId, conversationId });

    if (!chatContainer) {
        logger.error('Container de chat não encontrado');
        return null;
    }
    
    // Verificar se já existe um container com este ID
    let existingContainer = document.querySelector(`[data-message-id="${messageId}"]`);
    if (existingContainer) {
        logger.debug('Container com mesmo ID já existe, reutilizando', { messageId });
        return existingContainer;
    }

    // Verificar se já existe uma mensagem completa recente desta conversa
    const existingCompleteMessages = document.querySelectorAll(`.message.assistant.complete[data-conversation-id="${conversationId}"], .message.assistant:not(.streaming)[data-conversation-id="${conversationId}"]`);
    if (existingCompleteMessages.length > 0) {
        const lastMessage = existingCompleteMessages[existingCompleteMessages.length - 1];
        const lastCompletedAt = parseInt(lastMessage.dataset.completedAt || '0', 10);
        const now = Date.now();
        
        // Se a mensagem foi completada nos últimos 2 segundos
        if (now - lastCompletedAt < 2000) {
            logger.warn('Mensagem completa recente detectada, evitando criar nova mensagem de streaming', {
                messageId,
                existingId: lastMessage.dataset.messageId,
                age: now - lastCompletedAt + 'ms'
            });
            return lastMessage;
        }
    }

    // Verificar se já existe uma mensagem com este ID no registry
    const entry = messageRegistry.messages.get(messageId);
    if (entry && document.body.contains(entry.container)) {
        logger.debug('Mensagem já existe no registry, reutilizando container', { messageId });
        return entry.container;
    }

    // Criar novo container de mensagem
    const mensagemDiv = document.createElement('div');
    mensagemDiv.className = 'message assistant streaming fade-in';
    mensagemDiv.dataset.messageId = messageId;
    mensagemDiv.dataset.conversationId = conversationId;
    mensagemDiv.dataset.createdAt = Date.now().toString();
    
    // Estrutura interna da mensagem
    mensagemDiv.innerHTML = `
        <div class="message-content"></div>
        <div class="message-actions">
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                <i class="fas fa-redo"></i>
            </button>
        </div>
    `;

    chatContainer.appendChild(mensagemDiv);
    
    // Registrar no messageRegistry
    messageRegistry.registerMessage(messageId, {
        conversationId,
        content: '',
        container: mensagemDiv,
        created: Date.now()
    });
    
    // Forçar reflow e aplicar transição
    void mensagemDiv.offsetHeight;
    mensagemDiv.classList.add('visible');

    logger.debug('Mensagem de streaming criada com sucesso', {
        messageId,
        conversationId,
        timestamp: Date.now()
    });

    return mensagemDiv;
}

export function atualizarMensagemStreaming(messageId, chunk, renderMarkdown = true) {
    console.log('[DEBUG] Atualizando mensagem em streaming:', {
        messageId,
        chunkSize: chunk?.length,
        useMarkdown: renderMarkdown
    });
    
    if (!messageId || !chunk) {
        console.error('[ERRO] ID de mensagem ou chunk inválido');
        return false;
    }
    
    // Obter conversa atual
    const conversationId = window.conversaAtual?.id;
    if (!conversationId) {
        console.warn('[AVISO] Tentando atualizar streaming sem conversa ativa');
        return false;
    }
    
    // Verificar se a mensagem existe
    const messageDiv = document.querySelector(`.message[data-message-id="${messageId}"]`);
    if (!messageDiv) {
        console.error('[ERRO] Mensagem não encontrada para atualização:', messageId);
        return false;
    }
    
    // Verificar se pertence à conversa atual
    const messageConversationId = messageDiv.dataset.conversationId;
    if (messageConversationId && messageConversationId !== conversationId) {
        console.warn('[AVISO] Tentativa de atualizar mensagem de outra conversa', {
            messageConversationId,
            currentConversationId: conversationId
        });
        return false;
    }
    
    try {
        // Obter container de conteúdo
        const messageContent = messageDiv.querySelector('.message-content');
        if (!messageContent) {
            console.error('[ERRO] Container de conteúdo não encontrado');
            return false;
        }
        
        // Acumular conteúdo no registro
        const entry = messageRegistry.messages.get(messageId);
        if (!entry) {
            // Registrar no messageRegistry se ainda não estiver lá
            messageRegistry.registerMessage(messageId, {
                conversationId,
                content: chunk,
                container: messageDiv
            });
        } else {
            // Adicionar o novo chunk
            messageRegistry.addChunk(messageId, chunk);
        }
        
        // Obter conteúdo acumulado
        const newContent = messageRegistry.messages.get(messageId)?.content || '';
        
        // Renderizar com Markdown se necessário
        if (renderMarkdown) {
            // Usar diretamente renderMessageChunk para atualizar o conteúdo
            renderMessageChunk(messageId, chunk, conversationId);
        } else {
            // Atualização simples sem Markdown
            messageContent.textContent += chunk;
        }
        
        // Verificar scroll
        updateStreamingScroll(messageDiv);
        
        return true;
    } catch (error) {
        console.error('[ERRO] Falha ao atualizar mensagem streaming:', error);
        return false;
    }
}

// Adicionar CSS para os novos elementos
const style = document.createElement('style');
style.textContent = `
.loading-indicator {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

.error-message {
    padding: 1rem;
    text-align: center;
    color: var(--error);
    font-weight: bold;
}

.empty-message {
    padding: 1rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

/* Estilos para streaming e fade-in */
.streaming-message {
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
}

.streaming-message.visible {
    opacity: 1;
    transform: translateY(0);
}

.streaming-message .message-content {
    opacity: 0;
    transition: opacity 0.3s ease;
}

.streaming-message .message-content.visible {
    opacity: 1;
}

/* Animação de digitação */
.typing-animation {
    display: inline-block;
    animation: typing 1s infinite;
}

@keyframes typing {
    0% { opacity: 0.2; }
    20% { opacity: 1; }
    100% { opacity: 0.2; }
}

/* Indicador de streaming */
.streaming-message::after {
    content: '';
    display: inline-block;
    width: 4px;
    height: 1em;
    background-color: var(--text-secondary);
    margin-left: 4px;
    animation: blink 1s infinite;
}

@keyframes blink {
    0% { opacity: 0; }
    50% { opacity: 1; }
    100% { opacity: 0; }
}
`;
document.head.appendChild(style);

function scrollToBottom() {
    const scrollContainer = document.querySelector('.scroll-container');
    if (scrollContainer) {
        scrollContainer.scrollTo({
            top: scrollContainer.scrollHeight,
            behavior: 'smooth'
        });
    }
}

function updateStreamingMessage(messageId, content) {
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageElement) {
        console.error(`Elemento de mensagem não encontrado para ID: ${messageId}`);
        return;
    }

    const contentElement = messageElement.querySelector('.message-content');
    if (contentElement) {
        contentElement.innerHTML = content;
        scrollToBottom();
    }
}

// Função para gerenciar o scroll durante o streaming
export function updateStreamingScroll(messageElement) {
    if (!messageElement) return;
    
    // Verificar se o container de chat existe
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) return;
    
    // Calcular se o usuário está próximo do final
    const { scrollTop, scrollHeight, clientHeight } = chatContainer;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    
    // Se estiver próximo do final (200px), scroll automático
    if (distanceToBottom < 200) {
        // Usar scrollIntoView para scroll suave
        messageElement.scrollIntoView({
            behavior: 'smooth',
            block: 'end'
        });
        
        // Log para debug
        logger.debug('Rolagem automática aplicada', {
            messageId: messageElement.dataset?.messageId,
            distanceToBottom
        });
    } else {
        // Se o usuário está longe do final, podemos mostrar um indicador
        // de novas mensagens que o usuário pode clicar para rolar
        logger.debug('Usuário está longe do final, não rolando automaticamente', {
            distanceToBottom
        });
    }
}


==========================================
Conteúdo de chatUtils.js (caminho: static\js\chat\chatUtils.js):
==========================================
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function copiarMensagem(button) {
    // console.log('[DEBUG] Copiando mensagem...');
    const mensagem = button.closest('.message').querySelector('.message-content').innerText; // Usando innerText para preservar formatação
    navigator.clipboard.writeText(mensagem)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar mensagem:', err);
            alert('Não foi possível copiar a mensagem. Por favor, tente novamente.');
        });
}

export function regenerarResposta(button) {
    // console.log('[DEBUG] Regenerando resposta...');
    const mensagemOriginal = button.closest('.message').previousElementSibling;
    if (!mensagemOriginal) {
        console.error('Mensagem original não encontrada');
        return;
    }

    const texto = mensagemOriginal.querySelector('.message-content').textContent;
    const chatInput = document.getElementById('chat-input');
    const chatForm = document.getElementById('chat-form');

    if (chatInput && chatForm) {
        chatInput.value = texto;
        chatForm.dispatchEvent(new Event('submit'));
    } else {
        console.error('Elementos do formulário não encontrados');
    }
}

export function copiarCodigo(button) {
    // console.log('[DEBUG] Copiando código...');
    const codeContainer = button.closest('.code-container');
    if (!codeContainer) {
        console.error('[ERRO] Container de código não encontrado');
        return;
    }
    
    const codeBlock = codeContainer.querySelector('.code-block code') || codeContainer.querySelector('code');
    if (!codeBlock) {
        console.error('[ERRO] Bloco de código não encontrado');
        return;
    }
    
    const code = codeBlock.textContent
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
    
    navigator.clipboard.writeText(code)
        .then(() => {
            button.innerHTML = '<i class="fas fa-check"></i>';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '<i class="fas fa-copy"></i>';
                button.classList.remove('copied');
            }, 2000);
        })
        .catch(err => {
            console.error('[ERRO] Falha ao copiar código:', err);
            alert('Não foi possível copiar o código. Por favor, tente novamente.');
        });
}

/**
 * Adiciona barras de títulos e botões de copiar aos blocos de código
 */
export function melhorarBlocosCodigo() {
    // console.log('[DEBUG] Melhorando blocos de código...');
    const temaAtual = document.documentElement.getAttribute('data-theme');
    // console.log('[DEBUG] Tema atual:', temaAtual);
    
    document.querySelectorAll('pre code').forEach((block) => {
        // Evitar duplicação se já tiver sido processado
        if (block.parentElement.parentElement.classList.contains('code-container')) {
            return;
        }

        // Extrair a linguagem da classe - melhorada para capturar apenas letras/números
        // console.log('[DEBUG] Classes do bloco:', block.className);
        const langMatch = block.className.match(/language-([a-zA-Z0-9]+)/i);
        let language = langMatch ? langMatch[1] : 'plaintext';
        
        // Capitalizar apenas a primeira letra para exibição mais elegante
        language = language.charAt(0).toUpperCase() + language.slice(1).toLowerCase();
        // console.log('[DEBUG] Linguagem detectada:', language);

        // Criar container principal
        const container = document.createElement('div');
        container.className = 'code-container';

        // Criar barra de título com botão de copiar
        const header = document.createElement('div');
        header.className = 'code-header';
        header.innerHTML = `
            <span class="language-label">${language.toUpperCase()}</span>
            <button class="code-copy-btn" title="Copiar código">
                <i class="fas fa-copy"></i>
            </button>
        `;

        // Adicionar manipulador de eventos para o botão de copiar
        const copyBtn = header.querySelector('.code-copy-btn');
        copyBtn.addEventListener('click', function() {
            copiarCodigo(this);
        });

        // Reorganizar a estrutura do DOM
        const pre = block.parentElement;
        pre.classList.add('code-block');
        
        // Inserir elementos na DOM
        const parent = pre.parentElement;
        parent.insertBefore(container, pre);
        container.appendChild(header);
        container.appendChild(pre);
        
        // Reaplicar o highlight para garantir que o destaque de sintaxe seja mantido
        hljs.highlightElement(block);
    });
}

// Expor função globalmente para o onclick
window.copiarCodigo = copiarCodigo;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;


==========================================
Conteúdo de chat.js (caminho: static\js\chat.js):
==========================================

import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    mostrarCarregamento
} from './chat/chatUI.js';

import {
    enviarMensagem,
    interromperResposta,
    atualizarBotoes
} from './chat/chatActions.js';

import {
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';

import {
    copiarCodigo,
    copiarMensagem,
    melhorarBlocosCodigo
} from './chat/chatUtils.js';

import {
    inicializarSync,
    entrarNaSalaDeConversa
} from './chat/chatSync.js';

// Estado global das conversas
window.conversations = {};

// Função para inicializar uma conversa na estrutura global
window.inicializarConversa = function(conversationId) {
    if (!window.conversations[conversationId]) {
        // Inicializando estrutura para conversa
        window.conversations[conversationId] = {
            data: { 
                id: conversationId,
                title: "Nova Conversa",
                messages: []
            },
            streaming: false,
            currentResponse: '',
            eventSource: null,
            abortController: null,
            pendingUpdates: false
        };
    }
    return window.conversations[conversationId];
};

// Função para copiar código - melhorada para preservar indentação
window.copiarCodigo = function(button) {
    const codeContainer = button.closest('.code-container');
    const codeBlock = codeContainer.querySelector('.code-block code');
    const code = codeBlock.innerText; // Usa innerText para preservar indentação
    
    navigator.clipboard.writeText(code).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o ícone original após 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar código:', err);
        alert('Não foi possível copiar o código. Por favor, tente novamente.');
    });
};

// Função para copiar mensagem completa
window.copiarMensagem = function(button) {
    const messageDiv = button.closest('.message');
    const content = messageDiv.querySelector('.message-content').innerText; // Também usa innerText aqui
    
    navigator.clipboard.writeText(content).then(() => {
        // Feedback visual
        button.innerHTML = '<i class="fas fa-check"></i>';
        button.classList.add('copied');
        
        // Restaurar o ícone original após 2 segundos
        setTimeout(() => {
            button.innerHTML = '<i class="fas fa-copy"></i>';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Erro ao copiar mensagem:', err);
        alert('Não foi possível copiar a mensagem. Por favor, tente novamente.');
    });
};

// Função para regenerar resposta (útil para depuração)
window.regenerarResposta = function(button) {
    if (!window.conversaAtual) {
        console.error('[ERRO] Sem conversa ativa para regenerar resposta');
        return;
    }
    
    const messageDiv = button.closest('.message');
    const conversationId = window.conversaAtual.id;
    
    // Encontrar a última mensagem do usuário na conversa atual
    if (window.conversations[conversationId] && 
        window.conversations[conversationId].data && 
        window.conversations[conversationId].data.messages) {
        
        const messages = window.conversations[conversationId].data.messages;
        let lastUserMessage = null;
        
        // Percorrer mensagens de trás para frente para encontrar a última do usuário
        for (let i = messages.length - 1; i >= 0; i--) {
            if (messages[i].role === 'user') {
                lastUserMessage = messages[i].content;
                break;
            }
        }
        
        if (lastUserMessage) {
            // Remover a mensagem atual da IA
            messageDiv.remove();
            
            // Re-enviar a mensagem do usuário para gerar nova resposta
            const chatContainer = document.querySelector('.chat-container');
            const sendBtn = document.getElementById('send-btn');
            const stopBtn = document.getElementById('stop-btn');
            const dummyInput = { value: '' };
            
            enviarMensagem(lastUserMessage, dummyInput, chatContainer, sendBtn, stopBtn);
        } else {
            console.error('[ERRO] Não foi possível encontrar a última mensagem do usuário');
        }
    }
};

// Inicializar a sincronização via WebSockets quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', () => {
    // Inicializar WebSocket para sincronização entre abas
    inicializarSync();
    
    // Configurar o listener de visibilidade para sincronização
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar a lista de conversas quando a aba ficar visível
            atualizarListaConversas();
        }
    });
});

export {
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    enviarMensagem,
    interromperResposta,
    carregarConversa,
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa,
    melhorarBlocosCodigo,
    atualizarBotoes,
    inicializarSync,
    entrarNaSalaDeConversa
};


==========================================
Conteúdo de commandMenu.js (caminho: static\js\commandMenu.js):
==========================================
export function initCommandMenu(inputElement, menuElement, commands = ['/youtube', '/google', '/help', '/settings']) {
    let selectedIndex = -1;
    const items = [];

    // Garantir que o menu esteja no body para evitar problemas de posicionamento
    if (menuElement.parentNode !== document.body) {
        menuElement.parentNode.removeChild(menuElement);
        document.body.appendChild(menuElement);
    }

    // Resetar estilos inline que podem estar causando problemas
    menuElement.style.display = 'none';
    menuElement.style.visibility = 'hidden';
    menuElement.style.position = 'absolute';
    menuElement.classList.remove('visible');

    if (!inputElement || !menuElement) {
        console.error('Elementos de input ou menu não foram fornecidos.');
        return;
    }

    function updateMenuPosition() {
        requestAnimationFrame(() => {
            const rect = inputElement.getBoundingClientRect();
            const menuHeight = menuElement.offsetHeight || 200;
            const spaceAbove = rect.top - menuHeight;

            // Se não tem espaço acima, abre pra baixo
            if (spaceAbove < 10) {
                menuElement.style.bottom = 'auto';
                menuElement.style.top = `${rect.bottom + 5}px`;
            } else {
                menuElement.style.top = 'auto';
                menuElement.style.bottom = `${window.innerHeight - rect.top + 5}px`;
            }
            
            menuElement.style.left = `${rect.left}px`;
            menuElement.style.width = `${rect.width}px`;
            menuElement.style.visibility = 'visible';
        });
    }

    // Quando o usuário digitar, verifica se o texto começa com '/'
    inputElement.addEventListener('input', function() {
        const text = this.value;
        
        if (text.startsWith('/')) {
            const filtered = commands.filter(cmd => 
                cmd.toLowerCase().startsWith(text.toLowerCase())
            );

            if (filtered.length > 0) {
                menuElement.innerHTML = filtered.map(cmd => `
                    <div class="command-item" role="option" data-command="${cmd}">
                        <div>
                            <div class="command-text">${cmd}</div>
                            <div class="command-description">Descrição para ${cmd}</div>
                        </div>
                    </div>
                `).join('');

                menuElement.querySelectorAll('.command-item').forEach(item => {
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const command = this.dataset.command;
                        inputElement.value = command + ' ';
                        menuElement.classList.remove('visible');
                        menuElement.style.display = 'none';
                        inputElement.focus();
                        inputElement.selectionStart = inputElement.selectionEnd = inputElement.value.length;
                    });
                });

                menuElement.style.display = 'block';
                menuElement.classList.add('visible');
                updateMenuPosition();
            } else {
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
            }
        } else {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });

    // Atualizar posição do menu ao rolar a página
    window.addEventListener('scroll', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    // Atualizar posição do menu ao redimensionar a janela
    window.addEventListener('resize', () => {
        if (menuElement.classList.contains('visible')) {
            updateMenuPosition();
        }
    });

    function updateSelectedItem() {
        items.forEach((item, index) => {
            item.classList.toggle('selected', index === selectedIndex);
            item.setAttribute('aria-selected', index === selectedIndex);
        });
        
        if (items[selectedIndex]) {
            items[selectedIndex].scrollIntoView({
                block: 'nearest',
                behavior: 'auto'
            });
        }
    }

    inputElement.addEventListener('keydown', function(e) {
        if (!menuElement.classList.contains('visible')) return;

        switch(e.key) {
            case 'Escape':
                e.preventDefault();
                menuElement.classList.remove('visible');
                menuElement.style.display = 'none';
                selectedIndex = -1;
                updateSelectedItem();
                break;
                
            case 'Enter':
                e.preventDefault();
                if (selectedIndex > -1 && items[selectedIndex]) {
                    items[selectedIndex].click();
                }
                break;

            case 'ArrowDown':
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                if (selectedIndex === -1 && items.length > 0) selectedIndex = 0;
                updateSelectedItem();
                break;
                
            case 'ArrowUp':
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                updateSelectedItem();
                break;
        }
    });

    // Observer para atualizar itens quando o conteúdo do menu mudar
    const observer = new MutationObserver(() => {
        items.length = 0;
        menuElement.querySelectorAll('.command-item').forEach(item => items.push(item));
        selectedIndex = -1;
        updateSelectedItem();
    });

    observer.observe(menuElement, { childList: true, subtree: true });

    // Clicar fora fecha o menu
    document.addEventListener('click', (e) => {
        if (!menuElement.contains(e.target) && e.target !== inputElement) {
            menuElement.classList.remove('visible');
            menuElement.style.display = 'none';
        }
    });
}


==========================================
Conteúdo de events.js (caminho: static\js\events.js):
==========================================
// Importações necessárias
import { toggleTheme } from './theme.js';
import { toggleSidebar, initSidebar } from './sidebar.js';
import { configureTextarea } from './textarea.js';

export function configureEventListeners() {
    console.log('[DEBUG] Configurando event listeners para botões de tema e sidebar');
    
    const themeToggle = document.querySelector('.theme-toggle');
    const modelSelect = document.querySelector('.model-select');
    const headerSidebarToggle = document.querySelector('.header-sidebar-toggle');

    // Verifica se os elementos foram encontrados
    console.log('[DEBUG] Elementos encontrados:', {
        themeToggle: !!themeToggle,
        modelSelect: !!modelSelect,
        headerSidebarToggle: !!headerSidebarToggle
    });

    // Event Listeners
    themeToggle?.addEventListener('click', toggleTheme);
    headerSidebarToggle?.addEventListener('click', toggleSidebar);

    modelSelect?.addEventListener('change', (e) => {
        window.currentModel = e.target.value;
    });

    // Configurar textareas
    configureTextarea(document.querySelector('#chat-input'));
    configureTextarea(document.querySelector('#welcome-input'));
    
    // Inicializar a barra lateral
    initSidebar();
    
    // Configurar menu de opções do chat (três pontinhos)
    document.addEventListener('click', function(event) {
        // Fechar todos os menus abertos quando clicar fora
        if (!event.target.closest('.more-btn') && !event.target.closest('.chat-options-menu')) {
            document.querySelectorAll('.chat-options-menu.visible').forEach(menu => {
                menu.classList.remove('visible');
            });
        }
        
        // Abrir menu ao clicar no botão de três pontinhos
        if (event.target.closest('.more-btn')) {
            event.preventDefault();
            event.stopPropagation();
            
            const chatItem = event.target.closest('.chat-item');
            if (chatItem) {
                const chatId = chatItem.dataset.id;
                const menu = chatItem.querySelector('.chat-options-menu');
                
                // Fechar todos os outros menus abertos
                document.querySelectorAll('.chat-options-menu.visible').forEach(m => {
                    if (m !== menu) m.classList.remove('visible');
                });
                
                // Alternar visibilidade deste menu
                menu?.classList.toggle('visible');
            }
        }
        
        // Manipular cliques nos itens do menu
        if (event.target.closest('.chat-option-item')) {
            const option = event.target.closest('.chat-option-item');
            const chatItem = option.closest('.chat-item');
            
            if (chatItem && option.dataset.action === 'delete') {
                const chatId = chatItem.dataset.id;
                if (window.excluirConversa && chatId) {
                    window.excluirConversa(chatId);
                }
            } else if (chatItem && option.dataset.action === 'rename') {
                const chatId = chatItem.dataset.id;
                if (window.renomearConversa && chatId) {
                    const newName = prompt('Digite o novo nome para esta conversa:');
                    if (newName && newName.trim()) {
                        window.renomearConversa(chatId, newName.trim());
                    }
                }
            }
            
            // Fechar o menu após a ação
            option.closest('.chat-options-menu').classList.remove('visible');
        }
    });
}


==========================================
Conteúdo de init.js (caminho: static\js\init.js):
==========================================
import { chatUI } from './chat/chatUI.js';
import { streamingManager } from './modules/streamingManager.js';
import { logger } from './utils/logger.js';

logger.info('Iniciando sistema de chat', { timestamp: new Date().toISOString() });

// Garantir que o DOMPurify está disponível globalmente
if (typeof DOMPurify === 'undefined') {
    logger.error('DOMPurify não está carregado', { 
        error: 'Dependência crítica não disponível',
        details: 'Verifique se o script está incluído corretamente no HTML'
    });
}

// Garantir que o marked está disponível globalmente
if (typeof marked === 'undefined') {
    logger.error('Marked não está carregado', { 
        error: 'Dependência crítica não disponível',
        details: 'Verifique se o script está incluído corretamente no HTML'
    });
}

// Garantir que o Socket.IO está disponível globalmente
if (typeof io === 'undefined') {
    logger.error('Socket.IO não está carregado', { 
        error: 'Dependência crítica não disponível',
        details: 'Verifique se o script está incluído corretamente no HTML'
    });
}

// Inicializar a aplicação quando o DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    logger.info('DOM carregado, iniciando inicialização do sistema');
    
    // Verificar se todos os elementos necessários estão presentes
    const requiredElements = [
        'chat-container',
        'message-input',
        'send-button'
    ];

    const missingElements = requiredElements.filter(id => !document.getElementById(id));
    if (missingElements.length > 0) {
        logger.error('Elementos necessários não encontrados', { 
            missingElements,
            criticalError: true
        });
        return;
    }

    // Inicializar o sistema de chat
    try {
        // O chatUI e streamingManager já são inicializados automaticamente
        // quando importados, então não precisamos fazer nada aqui
        logger.info('Sistema de chat inicializado com sucesso', {
            initialState: {
                conversationId: window.conversaAtual?.id || 'nova conversa',
                screenWidth: window.innerWidth,
                screenHeight: window.innerHeight
            }
        });
    } catch (error) {
        logger.error('Erro ao inicializar o sistema de chat', { 
            error: error.message,
            stack: error.stack 
        });
    }
});

// Configurar socket global com instrumentação de logs
const socket = io();

// Monitorar eventos Socket.IO
const originalEmit = socket.emit;
socket.emit = function (event, ...args) {
    logger.debug('Socket emitindo evento', { event, args });
    return originalEmit.apply(this, [event, ...args]);
};

socket.onAny((event, ...args) => {
    logger.debug('Socket recebendo evento', { 
        event, 
        args: event === 'message_chunk' ? 
            { chunk_size: args[0]?.content?.length || 0, conversation_id: args[0]?.conversation_id } : 
            args 
    });
});

socket.on('connect', () => logger.info('Socket conectado ao servidor'));
socket.on('disconnect', () => logger.warn('Socket desconectado do servidor'));
socket.on('connect_error', (error) => logger.error('Erro de conexão do Socket', { error }));

export default socket;

==========================================
Conteúdo de main.js (caminho: static\js\main.js):
==========================================
import './init.js';
import { handleYoutubeCommand, setupYoutubeSocketListeners } from './youtube-system/youtubeHandler.js';
import { handleYoutubeResumoCommand } from './youtube-system/youtubeResumoHandler.js';
import { setupYoutubeEvents } from './youtube-system/youtubeEvents.js';
import { 
    iniciarChat,
    mostrarTelaInicial,
    adicionarMensagem,
    melhorarBlocosCodigo,
    inicializarSync
} from './chat.js';
import { enviarMensagem, interromperResposta, entrarNaSala, sairDaSala, carregarConversa } from './chat/chatActions.js';
import { 
    atualizarListaConversas,
    criarNovaConversa,
    adicionarMensagemAoHistorico,
    renomearConversa,
    excluirConversa
} from './chat/chatStorage.js';
import { initializeInputBar, destroyInputBar } from './modules/inputBar.js';
import { copiarMensagem, regenerarResposta } from './chat/chatUtils.js';
import { chatUI } from './chat/chatUI.js';
import { streamingManager } from './modules/streamingManager.js';
import { initializeTheme } from './theme.js';
import { initSidebar } from './sidebar.js';
import { initCommandMenu } from './commandMenu.js';
import { configureEventListeners } from './events.js';

// Estado global
window.currentModel = 'gemma2:2b';
window.conversas = [];
window.conversaAtual = null;
window.conversations = {}; // Nova estrutura global para mapear conversas por ID
window.copiarMensagem = copiarMensagem;
window.regenerarResposta = regenerarResposta;

let welcomeBar = null;
let chatBar = null;

// Configuração do Socket.IO
const socket = io();

// Exportar socket para uso em outros módulos
export { socket };

// Configuração do Marked
marked.setOptions({
    renderer: new marked.Renderer(),
    highlight: function(code, language) {
        const validLanguage = hljs.getLanguage(language) ? language : 'plaintext';
        return hljs.highlight(code, { language: validLanguage }).value;
    },
    pedantic: false,
    gfm: true,
    breaks: true,
    sanitize: false,
    smartypants: false,
    xhtml: false
});

// Inicialização do DOMPurify
DOMPurify.setConfig({
    ALLOWED_TAGS: [
        'a', 'b', 'blockquote', 'br', 'code', 'div', 'em',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'i', 'li', 'ol', 'p', 'pre', 'span',
        'strong', 'table', 'tbody', 'td', 'th',
        'thead', 'tr', 'ul'
    ],
    ALLOWED_ATTR: ['href', 'class', 'style', 'target']
});

// Função principal de inicialização
document.addEventListener('DOMContentLoaded', () => {
    // Inicializar componentes
    initializeTheme();
    initSidebar();
    configureEventListeners();
    
    // Configurar Socket.IO
    socket.on('connect', () => {
        console.log('Conectado ao servidor Socket.IO');
    });

    socket.on('disconnect', () => {
        console.log('Desconectado do servidor Socket.IO');
    });

    // Entrar na sala da conversa atual quando mudar de chat
    document.addEventListener('conversation-selected', (e) => {
        const { conversationId } = e.detail;
        if (socket.currentRoom) {
            socket.emit('leave_conversation', { conversation_id: socket.currentRoom });
        }
        if (conversationId) {
            socket.emit('join_conversation', { conversation_id: conversationId });
            socket.currentRoom = conversationId;
        }
    });

    // Inicializar WebSocket para sincronização entre abas
    inicializarSync();
    
    // Configurar listeners do Socket.IO para o YouTube
    setupYoutubeSocketListeners(socket);
    setupYoutubeEvents(socket);
    
    const welcomeForm = document.getElementById('welcome-form');
    const chatForm = document.getElementById('chat-form');
    const chatContainer = document.querySelector('.chat-container');
    const welcomeInput = document.getElementById('welcome-input');
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');
    const stopBtn = document.getElementById('stop-btn');
    const newChatBtn = document.querySelector('.new-chat-btn');
    const testBtn = document.getElementById('test-btn');

    // Configurar menu de comando usando o módulo criado
    const welcomeCommandMenu = document.getElementById('command-menu');
    const chatCommandMenu = document.getElementById('chat-command-menu');

    const COMMANDS = [
        { command: '/youtube', description: 'Processar vídeo do YouTube' },
        { command: '/youtube_resumo', description: 'Resumo detalhado de vídeo do YouTube' },
        { command: '/salvar', description: 'Salvar conversa atual' },
        { command: '/historico', description: 'Ver histórico completo' },
        { command: '/config', description: 'Abrir configurações' }
    ];

    // Prevenir submit padrão dos formulários
    document.querySelectorAll('form').forEach(form => {
        form.addEventListener('submit', (e) => {
            e.preventDefault();
        });
    });

    // Inicializar barra de entrada da tela inicial
    if (welcomeInput && welcomeCommandMenu) {
        welcomeBar = initializeInputBar(
            welcomeInput, 
            welcomeCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        welcomeForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = welcomeInput.value.trim();
            if (!message) return;
            
            // Criar nova conversa se não existir
            if (!window.conversaAtual) {
                criarNovaConversa();
            }

            // Entrar na sala da conversa
            entrarNaSala(window.conversaAtual.id);

            // Limpar barra de boas-vindas antes de trocar de tela
            welcomeBar?.destroy();

            iniciarChat(
                document.querySelector('.welcome-screen'),
                chatContainer,
                document.querySelector('.input-container')
            );
            
            await enviarMensagem(message, welcomeInput, chatContainer, sendBtn, stopBtn);
            atualizarListaConversas(); // Atualizar histórico após enviar mensagem
            
            // Adicionar barras de título aos blocos de código
            setTimeout(() => {
                melhorarBlocosCodigo();
            }, 100);
        });
    }

    // Inicializar barra de entrada do chat
    if (chatInput && chatCommandMenu) {
        chatBar = initializeInputBar(
            chatInput, 
            chatCommandMenu, 
            COMMANDS.map(c => c.command)
        );

        chatForm?.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (!message) return;
            
            // Verificar se há uma conversa ativa
            if (!window.conversaAtual) {
                criarNovaConversa();
            }
            
            // Entrar na sala da conversa
            entrarNaSala(window.conversaAtual.id);
            
            // Armazenar o ID da conversa atual para garantir que estamos na mesma conversa após o streaming
            const currentConversationId = window.conversaAtual.id;
            
            chatBar.clear();
            await enviarMensagem(message, chatInput, chatContainer, sendBtn, stopBtn);
            
            // Verificar se ainda estamos na mesma conversa
            if (window.conversaAtual && window.conversaAtual.id === currentConversationId) {
                atualizarListaConversas(); // Atualizar histórico após enviar mensagem
                
                // Adicionar barras de título aos blocos de código
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    }

    // Configurar botão de nova conversa
    newChatBtn?.addEventListener('click', () => {
        if (window.conversaAtual) {
            // Sair da sala da conversa atual
            sairDaSala(window.conversaAtual.id);
            atualizarListaConversas(); // Atualizar histórico antes de criar nova conversa
        }
        
        // Limpar barra do chat antes de trocar de tela
        chatBar?.destroy();
        
        window.conversaAtual = null;
        mostrarTelaInicial(
            document.querySelector('.welcome-screen'),
            chatContainer,
            document.querySelector('.input-container'),
            welcomeInput,
            chatInput
        );

        // Reinicializar barra de boas-vindas
        if (welcomeInput && welcomeCommandMenu) {
            welcomeBar = initializeInputBar(
                welcomeInput, 
                welcomeCommandMenu, 
                COMMANDS.map(c => c.command)
            );
        }
    });

    // Configurar botão de parar resposta
    stopBtn?.addEventListener('click', () => {
        interromperResposta();
    });

    // Inicializar lista de conversas
    atualizarListaConversas();

    // Eventos para gerenciamento de estado isolado
    window.addEventListener('conversaCarregada', (e) => {
        if (e.detail && e.detail.id) {
            // Entrar na sala da conversa carregada
            entrarNaSala(e.detail.id);
        }
    });
    
    window.addEventListener('conversaAtualizada', (e) => {
        if (e.detail && e.detail.id) {
            // Entrar na sala da conversa atualizada
            entrarNaSala(e.detail.id);
        }
        atualizarListaConversas();
    });
    
    window.addEventListener('mensagemEnviada', (e) => {
        if (window.conversaAtual) {
            // Entrar na sala da conversa atual
            entrarNaSala(window.conversaAtual.id);
        }
    });
    
    // Processar blocos de código já existentes (ao carregar uma conversa)
    melhorarBlocosCodigo();
    
    // Observar mudanças no DOM para processar novos blocos de código
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length > 0) {
                setTimeout(() => {
                    melhorarBlocosCodigo();
                }, 100);
            }
        });
    });
    
    observer.observe(chatContainer, { childList: true, subtree: true });
    
    // Configurar o listener de visibilidade para sincronização
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            // Atualizar o estado quando a aba ficar visível
            atualizarListaConversas();
            
            // Se houver uma conversa atual, verificar se há atualizações pendentes
            if (window.conversaAtual && window.conversations[window.conversaAtual.id]?.pendingUpdates) {
                carregarConversa(window.conversaAtual.id);
                window.conversations[window.conversaAtual.id].pendingUpdates = false;
            }
        }
    });

    // Adicionar evento de clique para o botão de teste
    if (testBtn) {
        testBtn.addEventListener('click', async () => {
            console.log('[DEBUG] Testando conectividade do Socket.IO');
            await testSocketConnection();
        });
    }
});

// Expor funções globalmente
window.carregarConversa = carregarConversa;
window.criarNovaConversa = criarNovaConversa;
window.adicionarMensagemAoHistorico = adicionarMensagemAoHistorico;
window.interromperResposta = interromperResposta;
window.renomearConversa = renomearConversa;
window.excluirConversa = excluirConversa;
window.melhorarBlocosCodigo = melhorarBlocosCodigo;

function showLoading() {
    document.getElementById('loading-indicator').style.display = 'block';
    document.getElementById('error-message').style.display = 'none';
    document.getElementById('success-message').style.display = 'none';
}

function hideLoading() {
    document.getElementById('loading-indicator').style.display = 'none';
}

function showError(message) {
    const errorElement = document.getElementById('error-message');
    errorElement.textContent = message;
    errorElement.style.display = 'block';
    hideLoading();
}

function showSuccess(message) {
    const successElement = document.getElementById('success-message');
    successElement.textContent = message;
    successElement.style.display = 'block';
    hideLoading();
}



==========================================
Conteúdo de messageRenderer.js (caminho: static\js\messageRenderer.js):
==========================================
import { marked } from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js';
import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js';
import { logger } from './utils/logger.js';
import { messageRegistry } from './modules/messageRegistry.js';

// Exportar o messageRegistry para retrocompatibilidade
export { messageRegistry };

/**
 * Renderiza uma mensagem formatada com Markdown usando marked.js e highlight.js
 * @param {string} text - Texto em formato Markdown
 * @returns {string} HTML formatado
 */
export function renderMarkdown(text) {
    if (!text) {
        logger.warn('Texto vazio recebido para renderização');
        return '';
    }

    // Se o texto for um elemento DOM com data-no-markdown, retorna o HTML bruto
    if (typeof text === 'string' && text.includes('data-no-markdown')) {
        logger.debug('Conteúdo HTML direto detectado (data-no-markdown)');
        return text;
    }

    // Verificar dependências e logar se não estiverem disponíveis
    if (typeof marked === 'undefined' || typeof hljs === 'undefined') {
        logger.error('Dependências de renderização não encontradas', {
            marked: typeof marked,
            hljs: typeof hljs
        });
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }

    try {
        logger.debug('Iniciando renderização de Markdown', {
            textSize: text.length
        });
        
        // Configurar marked para suportar tabelas e outros elementos
        marked.setOptions({
            breaks: true,
            gfm: true,
            tables: true,
            headerIds: false,
            mangle: false,
            sanitize: false,
            highlight: (code, lang) => {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (e) {
                        logger.warn('Erro ao destacar código', { 
                            language: lang, 
                            error: e.message 
                        });
                    }
                }
                return code;
            }
        });

        const htmlContent = marked.parse(text);

        const sanitizedHtml = DOMPurify.sanitize(htmlContent, {
            ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'a', 'img'],
            ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'target', 'rel']
        });

        logger.debug('Markdown renderizado com sucesso', {
            inputSize: text.length,
            outputSize: sanitizedHtml.length
        });
        
        return sanitizedHtml;
    } catch (error) {
        logger.error('Falha ao renderizar mensagem', {
            error: error.message,
            stack: error.stack
        });
        return `<p>${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</p>`;
    }
}

// Função renomeada para evitar conflito com a nova implementação
export const renderMessage = renderMarkdown;

// Mapa para armazenar as respostas acumuladas por conversa
const accumulatedResponses = new Map();

/**
 * Acumula chunks de mensagem por conversa
 * @param {string} chunk - Chunk de texto recebido
 * @param {string} conversationId - ID da conversa
 */
export function accumulateChunk(chunk, conversationId) {
    if (!conversationId || !chunk) {
        logger.warn('Chunk ou conversationId inválido para acumulação', { 
            chunkValid: !!chunk, 
            conversationIdValid: !!conversationId 
        });
        return;
    }
    
    let accumulated = accumulatedResponses.get(conversationId) || '';
    
    // Verificar se o chunk é válido e pode ser concatenado
    if (typeof chunk !== 'string') {
        logger.warn('Tipo de chunk inválido recebido', { 
            tipo: typeof chunk,
            chunk: JSON.stringify(chunk).substring(0, 100)
        });
        return;
    }
    
    accumulated += chunk;
    accumulatedResponses.set(conversationId, accumulated);
    
    logger.debug('Chunk acumulado', { 
        conversationId,
        chunkSize: chunk.length,
        totalAccumulatedSize: accumulated.length
    });

    // Emitir evento de atualização
    const event = new CustomEvent('chunk_accumulated', {
        detail: {
            conversationId,
            accumulated,
            chunk
        }
    });
    window.dispatchEvent(event);
}

// Variável para armazenar a referência ao ID da conversa atual
let currentConversationId = null;

/**
 * Define qual é a conversa ativa atual
 * @param {string} conversationId - ID da conversa ativa
 */
export function setCurrentConversation(conversationId) {
    logger.debug('Conversa atual definida', { 
        previousId: currentConversationId, 
        newId: conversationId 
    });
    currentConversationId = conversationId;
}

/**
 * Renderiza ou atualiza uma mensagem em um container individual
 * @param {Object} params - Parâmetros da mensagem
 * @param {string} params.content - Conteúdo do texto/chunk
 * @param {string} params.conversationId - ID da conversa
 * @param {string} params.role - Papel ("user" ou "assistant")
 * @param {string} params.messageId - ID único da mensagem
 * @param {boolean} params.isStreaming - Indica se é streaming
 * @returns {HTMLElement} O elemento da mensagem
 */
export function renderMessageContainer({ content, conversationId, role = 'assistant', messageId, isStreaming = false }) {
    logger.debug('Renderizando container de mensagem', { 
        messageId, 
        conversationId,
        role,
        contentSize: content?.length || 0,
        isStreaming
    });
    
    // Verificar se a conversa corresponde à conversa ativa
    if (conversationId !== currentConversationId && conversationId !== window.conversaAtual?.id) {
        logger.warn('Tentativa de renderizar mensagem para conversa não ativa', {
            renderingFor: conversationId,
            currentActive: currentConversationId || window.conversaAtual?.id
        });
        return null;
    }

    // Identificar o container de chat
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) {
        logger.error('Container de chat não encontrado para renderização', {
            messageId, 
            conversationId
        });
        return null;
    }

    // Verificar se já existe um container para esta mensagem
    let messageDiv = document.getElementById(`message-${messageId}`);
    
    // Criar container se não existir
    if (!messageDiv) {
        logger.debug('Criando novo container para mensagem', { 
            messageId,
            conversationId, 
            role 
        });
        
        messageDiv = document.createElement("div");
        messageDiv.id = `message-${messageId}`;
        messageDiv.className = `message ${role} fade-in`; 
        messageDiv.dataset.messageId = messageId;
        messageDiv.dataset.conversationId = conversationId;
        
        // Estrutura interna da mensagem
        messageDiv.innerHTML = `
            <div class="message-content"></div>
            <div class="message-actions">
                <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                    <i class="fas fa-copy"></i>
                </button>
                ${role === 'assistant' ? `
                    <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                        <i class="fas fa-redo"></i>
                    </button>
                ` : ''}
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
        
        // Rolar para o final se estiver próximo do fundo
        scrollToBottomIfNear(chatContainer);
    } else {
        logger.debug('Atualizando container de mensagem existente', { 
            messageId,
            previousContentSize: messageDiv.querySelector('.message-content')?.innerHTML?.length || 0
        });
    }

    // Localizar o container de conteúdo
    const contentContainer = messageDiv.querySelector('.message-content');
    if (!contentContainer) {
        logger.error('Container de conteúdo não encontrado na mensagem', { 
            messageId, 
            messageHtml: messageDiv.outerHTML.substring(0, 100) 
        });
        return messageDiv;
    }

    // Converter markdown e sanitizar o conteúdo
    const sanitizedHTML = renderMarkdown(content);

    // Atualizar o conteúdo
    if (isStreaming) {
        // No modo streaming, adicionamos incrementalmente
        contentContainer.innerHTML = sanitizedHTML;
        logger.debug('Conteúdo de streaming atualizado', { 
            messageId, 
            contentSize: sanitizedHTML.length 
        });
    } else {
        // Em modo normal, substituímos o conteúdo
        contentContainer.innerHTML = sanitizedHTML;
        logger.debug('Conteúdo normal atualizado', { 
            messageId, 
            contentSize: sanitizedHTML.length 
        });
    }

    return messageDiv;
}

/**
 * Função auxiliar para rolar para o final se estiver próximo
 * @param {HTMLElement} chatContainer - Container de chat
 */
function scrollToBottomIfNear(chatContainer) {
    if (chatContainer.scrollTop + chatContainer.clientHeight >= chatContainer.scrollHeight - 100) {
        requestAnimationFrame(() => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        });
    }
}

/**
 * Renderiza a resposta completa acumulada
 * @param {string} conversationId - ID da conversa
 * @returns {string} HTML formatado da resposta completa
 */
export function renderCompleteResponse(conversationId) {
    if (!conversationId) {
        console.warn('[DEBUG] conversationId não fornecido para renderização completa');
        return '';
    }

    const completeResponse = accumulatedResponses.get(conversationId);
    if (!completeResponse) {
        console.warn('[DEBUG] Nenhuma resposta acumulada encontrada para:', conversationId);
        return '';
    }

    try {
        // Renderizar com todas as otimizações
        const renderedContent = renderMarkdown(completeResponse);
        
        // Limpar a resposta acumulada após renderização bem-sucedida
        accumulatedResponses.delete(conversationId);
        
        // Emitir evento de renderização completa
        const event = new CustomEvent('response_rendered', {
            detail: {
                conversationId,
                content: renderedContent
            }
        });
        window.dispatchEvent(event);
        
        return renderedContent;
    } catch (error) {
        console.error('[ERRO] Falha ao renderizar resposta completa:', error);
        return '';
    }
}

/**
 * Limpa a resposta acumulada de uma conversa
 * @param {string} conversationId - ID da conversa
 */
export function clearAccumulatedResponse(conversationId) {
    if (conversationId) {
        const hadResponse = accumulatedResponses.has(conversationId);
        accumulatedResponses.delete(conversationId);
        
        if (hadResponse) {
            // Emitir evento de limpeza
            const event = new CustomEvent('response_cleared', {
                detail: { conversationId }
            });
            window.dispatchEvent(event);
        }
    } else {
        console.warn('[DEBUG] Tentativa de limpar resposta sem conversationId');
    }
}

// Adicionar função para verificar estado da acumulação
export function getAccumulatedState(conversationId) {
    if (!conversationId) {
        console.warn('[DEBUG] Tentativa de verificar estado sem conversationId');
        return null;
    }
    
    const accumulated = accumulatedResponses.get(conversationId);
    return {
        hasAccumulated: !!accumulated,
        size: accumulated ? accumulated.length : 0
    };
}

// Cache para chunks de código
const codeChunkCache = new Map();

/**
 * Processa um chunk de código e retorna o HTML formatado
 * @param {string} chunk - Chunk de texto que pode conter código
 * @returns {string} HTML formatado
 */
function processCodeChunk(chunk) {
    if (!chunk) return '';
    
    // Verificar se o chunk contém código
    const codeMatch = chunk.match(/```(\w+)?\n([\s\S]*?)```/);
    if (!codeMatch) return chunk;
    
    const [, lang, code] = codeMatch;
    const cacheKey = `${lang || 'plaintext'}_${code}`;
    
    // Verificar cache
    if (codeChunkCache.has(cacheKey)) {
        return codeChunkCache.get(cacheKey);
    }
    
    try {
        let highlighted;
        if (lang && hljs.getLanguage(lang)) {
            highlighted = hljs.highlight(code, { language: lang }).value;
        } else {
            highlighted = hljs.highlight(code).value;
        }
        
        const html = `<pre><code class="language-${lang || 'plaintext'}">${highlighted}</code></pre>`;
        
        // Armazenar no cache
        codeChunkCache.set(cacheKey, html);
        
        return html;
    } catch (e) {
        logger.error('Erro ao processar chunk de código', e);
        return `<pre><code>${code}</code></pre>`;
    }
}

/**
 * Cria um novo container para mensagem
 * @param {string} messageId - ID da mensagem
 * @param {string} conversationId - ID da conversa
 * @returns {HTMLElement} Container criado
 */
const createContainer = (messageId, conversationId) => {
    const chatContainer = document.querySelector('.chat-container');
    if (!chatContainer) {
        logger.error('Container de chat não encontrado');
        return null;
    }
    
    // Verificar se já existe um container para essa mensagem
    let container = document.querySelector(`[data-message-id="${messageId}"]`);
    
    if (container) {
        logger.debug(`Container existente encontrado para mensagem ${messageId}`);
        return container;
    }
    
    // Criar novo container
    container = document.createElement('div');
    container.className = 'message assistant streaming';
    container.dataset.messageId = messageId;
    container.dataset.conversationId = conversationId;
    container.dataset.createdAt = Date.now().toString();
    
    // Adicionar estrutura interna completa
    container.innerHTML = `
        <div class="message-content"></div>
        <div class="message-actions">
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
            <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                <i class="fas fa-redo"></i>
            </button>
        </div>
    `;
    
    chatContainer.appendChild(container);
    
    logger.debug(`Novo container criado para mensagem ${messageId}`);
    
    return container;
};

/**
 * Renderiza um chunk de mensagem em streaming
 * @param {string} messageId - ID único da mensagem
 * @param {string} chunk - Chunk de texto a ser renderizado
 * @param {string} conversationId - ID da conversa
 */
export const renderMessageChunk = (messageId, chunk, conversationId) => {
    if (!messageId) {
        logger.error('Tentativa de renderizar chunk sem messageId');
        return;
    }
    
    logger.debug('Renderizando chunk', { 
        messageId, 
        conversationId,
        chunkSize: chunk?.length || 0
    });
    
    // Verificar se a conversa é a atual
    if (conversationId && conversationId !== window.conversaAtual?.id) {
        logger.debug('Ignorando chunk de outra conversa', {
            atual: window.conversaAtual?.id,
            recebido: conversationId
        });
        return;
    }
    
    // Verificar se já existe uma mensagem completa recente para evitar duplo rendering
    const existingCompleteMessages = document.querySelectorAll(`.message.assistant.complete[data-conversation-id="${conversationId}"], .message.assistant:not(.streaming)[data-conversation-id="${conversationId}"]`);
    if (existingCompleteMessages.length > 0) {
        const lastMessage = existingCompleteMessages[existingCompleteMessages.length - 1];
        const lastMessageTimestamp = lastMessage.dataset.createdAt || '0';
        const now = Date.now();
        const age = now - parseInt(lastMessageTimestamp, 10);
        
        // Se existe uma mensagem completa criada nos últimos 2 segundos
        if (age < 2000) {
            logger.warn('Ignorando chunk para evitar duplicação - mensagem completa recente detectada', { 
                messageId,
                completeMessageId: lastMessage.dataset.messageId,
                age: age + 'ms'
            });
            return;
        }
    }
    
    // Verificar se já existem múltiplos containers com o mesmo ID de mensagem
    const duplicateContainers = document.querySelectorAll(`[data-message-id="${messageId}"]`);
    if (duplicateContainers.length > 1) {
        logger.warn('Detectados múltiplos containers com mesmo messageId', {
            messageId,
            count: duplicateContainers.length
        });
        
        // Manter apenas o mais recente, remover os outros
        const containersArray = Array.from(duplicateContainers);
        containersArray.sort((a, b) => {
            const aTime = parseInt(a.dataset.createdAt || '0', 10);
            const bTime = parseInt(b.dataset.createdAt || '0', 10);
            return bTime - aTime; // Ordenar do mais recente para o mais antigo
        });
        
        // Manter o primeiro (mais recente) e remover os outros
        for (let i = 1; i < containersArray.length; i++) {
            logger.info('Removendo container duplicado', {
                messageId,
                index: i,
                createdAt: containersArray[i].dataset.createdAt
            });
            containersArray[i].remove();
        }
    }
    
    // Verificar e registrar a mensagem no messageRegistry
    let entry = messageRegistry.messages.get(messageId);
    
    if (!entry) {
        entry = messageRegistry.registerMessage(messageId, {
            conversationId,
            content: ''
        });
        logger.debug('Nova entrada criada no registro para mensagem', { messageId });
    }
    
    // Adicionar o chunk ao conteúdo acumulado
    messageRegistry.addChunk(messageId, chunk);
    
    // Obter o container da mensagem
    let container = entry.container;
    
    if (!container) {
        // Verificar se já existe um container para esta mensagem no DOM
        container = document.querySelector(`[data-message-id="${messageId}"]`);
        
        if (container) {
            logger.debug('Container existente encontrado no DOM', { messageId });
            entry.container = container;
        } else {
            // Criar novo container se não existir
            logger.debug('Criando novo container para mensagem', { messageId });
            container = createContainer(messageId, conversationId);
            entry.container = container;
        }
    } else if (!document.body.contains(container)) {
        // Se o container existe no registro mas não está no DOM
        logger.warn('Container existe no registro mas não no DOM, recriando', { messageId });
        container = createContainer(messageId, conversationId);
        entry.container = container;
    }
    
    // Renderizar o conteúdo acumulado
    renderContent(entry);
    
    // Configurar limpeza automática
    if (!entry.cleanupTimer) {
        entry.cleanupTimer = setTimeout(() => {
            cleanupOrphan(messageId);
        }, 10000);
    }
};

/**
 * Renderiza o conteúdo em um container
 * @param {Object} entry - Entrada do registro
 */
const renderContent = (entry) => {
    try {
        // Verificar se o conteúdo é válido antes de usar marked.parse()
        if (!entry.content || typeof entry.content !== 'string') {
            logger.warn('Conteúdo inválido para renderização', { 
                messageId: entry.id || entry.container.dataset.messageId,
                content: entry.content
            });
            return;
        }

        // Preparar o conteúdo com marcador de cursor para streaming
        const htmlContent = marked.parse(entry.content + '<span class="streaming-cursor">█</span>');
        const sanitizedHtml = DOMPurify.sanitize(htmlContent);
        
        // Obter o elemento de conteúdo
        const contentElement = entry.container.querySelector('.message-content');
        
        if (contentElement) {
            // Apenas atualizar o conteúdo, mantendo a estrutura
            contentElement.innerHTML = sanitizedHtml;
        } else {
            // Se não houver elemento de conteúdo, criar a estrutura completa
            logger.warn('Elemento message-content não encontrado, recriando estrutura', { 
                messageId: entry.id || entry.container.dataset.messageId 
            });
            
            entry.container.innerHTML = `
                <div class="message-content">${sanitizedHtml}</div>
                <div class="message-actions">
                    <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                        <i class="fas fa-redo"></i>
                    </button>
                </div>
            `;
        }
        
        // Rolagem suave para o novo conteúdo
        requestAnimationFrame(() => {
            const chatContainer = document.querySelector('.chat-container');
            if (chatContainer && chatContainer.scrollHeight - chatContainer.scrollTop <= chatContainer.clientHeight + 100) {
                chatContainer.scrollTo({
                    top: chatContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }
        });
    } catch (error) {
        logger.error('Erro ao renderizar conteúdo', { 
            error: error.message,
            messageId: entry.container.dataset.messageId 
        });
    }
};

/**
 * Limpa containers órfãos
 * @param {string} messageId - ID da mensagem a ser limpa
 */
const cleanupOrphan = (messageId) => {
    logger.debug('Verificando container órfão', { messageId });
    const entry = messageRegistry.messages.get(messageId);
    
    if (entry && (!entry.container || !entry.container.textContent.trim() || !document.body.contains(entry.container))) {
        logger.info('Removendo container órfão', { messageId });
        if (entry.container && document.body.contains(entry.container)) {
            entry.container.remove();
        }
        messageRegistry.messages.delete(messageId);
    }
};

/**
 * Finaliza a mensagem após conclusão do streaming
 * @param {string} messageId - ID único da mensagem
 * @param {string} conversationId - ID da conversa
 * @param {string} content - Conteúdo final da mensagem
 */
export const completeMessage = (messageId, conversationId, content) => {
    try {
        logger.debug('Completando mensagem', { messageId, conversationId });
        
        // Verificar se já existe uma mensagem completa recente para evitar duplicação
        const existingCompleteMessages = document.querySelectorAll(`.message.assistant.complete[data-conversation-id="${conversationId}"], .message.assistant:not(.streaming)[data-conversation-id="${conversationId}"]`);
        if (existingCompleteMessages.length > 0) {
            const lastMessage = existingCompleteMessages[existingCompleteMessages.length - 1];
            
            // Não completar se o conteúdo for muito similar
            if (lastMessage.dataset.messageId !== messageId) {
                const lastContent = lastMessage.querySelector('.message-content')?.textContent || '';
                
                // Se o início do conteúdo é similar, pode ser duplicação
                if (content && lastContent && 
                    content.substring(0, 50).trim() === lastContent.substring(0, 50).trim()) {
                    
                    logger.warn('Evitando completar mensagem duplicada', {
                        messageId,
                        existingId: lastMessage.dataset.messageId,
                        similarity: 'primeiros 50 caracteres iguais'
                    });
                    
                    // Remover o container de streaming para não deixar duplicado
                    const streamingContainer = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (streamingContainer) {
                        logger.info('Removendo container de streaming redundante', { messageId });
                        streamingContainer.remove();
                    }
                    
                    return;
                }
            }
        }
        
        // Usar messageRegistry para obter a entrada da mensagem
        const entry = messageRegistry.messages.get(messageId);
        
        if (!entry || !entry.container) {
            logger.error('Container não encontrado para completar mensagem', { messageId, conversationId });
            return;
        }
        
        // Verificar duplicação com base no conteúdo
        const existingEntries = Array.from(messageRegistry.messages.values())
            .filter(msg => msg.id !== messageId && msg.complete && msg.conversationId === conversationId);
        
        for (const existingEntry of existingEntries) {
            // Comparar primeiros 50 caracteres
            if (existingEntry.content && content &&
                existingEntry.content.substring(0, 50).trim() === content.substring(0, 50).trim()) {
                
                logger.warn('Conteúdo similar detectado em mensagem existente', {
                    messageId,
                    existingId: existingEntry.id
                });
                
                // Apenas logamos, pois pode ser uma resposta legitimamente similar
                break;
            }
        }
        
        // Remover a classe de streaming
        entry.container.classList.remove('streaming');
        entry.container.classList.add('complete');
        entry.container.dataset.completedAt = Date.now().toString();
        
        // Preservar os botões de ação
        const actionsElement = entry.container.querySelector('.message-actions');
        
        // Atualizar o conteúdo da mensagem no registro
        entry.content = content;
        
        // Obter o elemento de conteúdo
        const contentElement = entry.container.querySelector('.message-content');
        
        if (contentElement) {
            // Verificar se o conteúdo é válido antes de usar marked.parse()
            if (!content || typeof content !== 'string') {
                logger.warn('Conteúdo inválido para completar mensagem', { 
                    messageId, 
                    content 
                });
                contentElement.innerHTML = '';
            } else {
                // Atualizar apenas o conteúdo sem a cursor de streaming
                contentElement.innerHTML = DOMPurify.sanitize(marked.parse(content));
                logger.debug('Conteúdo atualizado mantendo estrutura', { messageId });
            }
        } else {
            // Se não existir, criar a estrutura completa
            logger.warn('Elemento message-content não encontrado ao completar mensagem', { messageId });
            
            // Verificar se o conteúdo é válido antes de usar marked.parse()
            const sanitizedContent = (!content || typeof content !== 'string') 
                ? '' 
                : DOMPurify.sanitize(marked.parse(content));
            
            // Preservar a estrutura original com o conteúdo atualizado
            entry.container.innerHTML = `<div class="message-content">${sanitizedContent}</div>`;
            
            // Re-adicionar os botões de ação se já existiam
            if (actionsElement) {
                entry.container.appendChild(actionsElement);
                logger.debug('Botões de ação readicionados', { messageId });
            } else {
                // Criar botões de ação padrão
                const newActions = document.createElement('div');
                newActions.className = 'message-actions';
                newActions.innerHTML = `
                    <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                        <i class="fas fa-copy"></i>
                    </button>
                    <button class="action-btn regenerate-btn" onclick="window.regenerarResposta(this)" title="Regenerar resposta">
                        <i class="fas fa-redo"></i>
                    </button>
                `;
                entry.container.appendChild(newActions);
                logger.debug('Novos botões de ação adicionados', { messageId });
            }
        }
        
        // Marcar como completa no messageRegistry
        messageRegistry.completeMessage(messageId);
        
        logger.info('Mensagem completada com sucesso', { messageId, conversationId });
    } catch (error) {
        logger.error('Erro ao completar mensagem', { 
            error: error.message, 
            stack: error.stack,
            messageId, 
            conversationId 
        });
    }
};

// Sistema de backup para limpeza de containers vazios
setInterval(() => {
    document.querySelectorAll('.message.streaming').forEach(container => {
        const messageId = container.dataset.messageId;
        if (messageId && (!container.textContent.trim() || container.querySelector('.message-content:empty'))) {
            logger.debug('Detectado container vazio', { messageId });
            cleanupOrphan(messageId);
        }
    });
}, 5000);

// Estilos para o cursor
const style = document.createElement('style');
style.textContent = `
.streaming-cursor {
    animation: blink 1s step-end infinite;
    font-weight: bold;
    margin-left: 2px;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
}
`;
document.head.appendChild(style);


==========================================
Conteúdo de commandHandler.js (caminho: static\js\modules\commandHandler.js):
==========================================
(function() { // IIFE para isolamento de escopo
    const COMMAND_PREFIX = '/';
    const COMMANDS = ['/youtube', '/google', '/help', '/settings'];
    
    class CommandMenu {
        constructor() {
            this.input = document.getElementById('chat-input');
            if (!this.input) {
                console.error('[Erro] Elemento #chat-input não encontrado');
                return;
            }
            
            this.initMenu();
            this.setupListeners();
        }

        initMenu() {
            this.menu = document.createElement('div');
            this.menu.className = 'cmd-menu';
            document.body.appendChild(this.menu);
        }

        setupListeners() {
            this.input.addEventListener('input', () => this.handleInput());
            document.addEventListener('click', (e) => this.handleOutsideClick(e));
            this.menu.addEventListener('click', (e) => this.handleMenuClick(e));
        }

        handleInput() {
            const text = this.input.value.trim();
            
            if (text.startsWith(COMMAND_PREFIX)) {
                this.positionMenu();
                this.filterCommands(text);
            } else {
                this.hideMenu();
            }
        }

        positionMenu() {
            const rect = this.input.getBoundingClientRect();
            this.menu.style.top = `${rect.bottom + window.scrollY}px`;
            this.menu.style.left = `${rect.left}px`;
            this.menu.classList.add('visible');
        }

        filterCommands(text) {
            this.menu.innerHTML = COMMANDS
                .filter(cmd => cmd.toLowerCase().startsWith(text.toLowerCase()))
                .map(cmd => `<div class="cmd-item" data-cmd="${cmd}">${cmd}</div>`)
                .join('');
        }

        handleMenuClick(e) {
            const item = e.target.closest('.cmd-item');
            if (item) {
                this.input.value = `${item.dataset.cmd} `;
                this.hideMenu();
                this.input.focus();
            }
        }

        handleOutsideClick(e) {
            if (!this.input.contains(e.target) && !this.menu.contains(e.target)) {
                this.hideMenu();
            }
        }

        hideMenu() {
            this.menu.classList.remove('visible');
        }
    }

    // Inicialização segura após DOM carregado
    document.addEventListener('DOMContentLoaded', () => {
        new CommandMenu();
    });
})();


==========================================
Conteúdo de inputBar.js (caminho: static\js\modules\inputBar.js):
==========================================

import { initCommandMenu } from '../commandMenu.js';
import { configureTextarea } from '../textarea.js';

const activeListeners = new WeakMap();

function handleSubmit(e, inputElement) {
    e.preventDefault();
    const message = inputElement.value.trim();
    
    // Não enviar se for comando incompleto
    if (message.startsWith('/') && !message.includes(' ')) {
        return;
    }

    if (message) {
        const submitEvent = new CustomEvent('customSubmit', { 
            detail: { message },
            bubbles: true 
        });
        e.target.dispatchEvent(submitEvent);
    }
}

export function initializeInputBar(inputElement, menuElement, commands) {
    if (!inputElement || !menuElement) {
        console.error('Elementos necessários não fornecidos para initializeInputBar');
        return;
    }

    // Limpar listeners antigos se existirem
    destroyInputBar(inputElement);

    // Configurar textarea (autoajuste de altura e eventos)
    configureTextarea(inputElement);

    // Configurar menu de comandos
    initCommandMenu(inputElement, menuElement, commands);

    // Adicionar evento de submit unificado
    const form = inputElement.closest('form');
    if (form) {
        const boundSubmitHandler = (e) => handleSubmit(e, inputElement);
        form.addEventListener('submit', boundSubmitHandler);
        
        // Armazenar referência ao listener para limpeza posterior
        activeListeners.set(form, boundSubmitHandler);
    }

    // Adicionar atributos de acessibilidade
    inputElement.setAttribute('aria-label', 'Campo de mensagem');
    inputElement.setAttribute('aria-describedby', 'message-instructions');

    return {
        focus: () => inputElement.focus(),
        clear: () => {
            inputElement.value = '';
            inputElement.style.height = 'auto';
        },
        getValue: () => inputElement.value,
        setValue: (value) => {
            inputElement.value = value;
            inputElement.style.height = 'auto';
            inputElement.style.height = inputElement.scrollHeight + 'px';
        },
        destroy: () => destroyInputBar(inputElement)
    };
}

export function destroyInputBar(inputElement) {
    const form = inputElement.closest('form');
    if (form) {
        // Remover listener específico se existir
        const listener = activeListeners.get(form);
        if (listener) {
            form.removeEventListener('submit', listener);
            activeListeners.delete(form);
        }
    }
}


==========================================
Conteúdo de messageRegistry.js (caminho: static\js\modules\messageRegistry.js):
==========================================
/**
 * messageRegistry.js
 * 
 * Sistema centralizado para gerenciamento de mensagens em streaming.
 * Este módulo exporta uma instância única do messageRegistry que
 * deve ser usada por toda a aplicação para evitar duplicação de mensagens.
 */

import { logger } from '../utils/logger.js';

/**
 * Classe para gerenciar o registro de mensagens
 */
class MessageRegistry {
    constructor() {
        logger.info('Inicializando MessageRegistry', { source: 'messageRegistry.js' });
        this.messages = new Map();
        this.debug = false; // Configurar como true para habilitar logs adicionais
        
        // Criar global para garantir acesso em todos os módulos
        if (!window.messageRegistry) {
            window.messageRegistry = this.messages;
            logger.info('Inicializando messageRegistry global', { source: 'messageRegistry.js' });
        } else {
            this.messages = window.messageRegistry;
            logger.debug('Usando messageRegistry global existente', { source: 'messageRegistry.js' });
        }
        
        // Monitoramento periódico para limpeza e depuração
        this.setupPeriodicCheck();
    }
    
    /**
     * Configura verificação periódica para limpeza e logs
     */
    setupPeriodicCheck() {
        setInterval(() => {
            if (this.debug) {
                this._log('debug', 'Estado atual do messageRegistry', {
                    totalEntries: this.messages.size,
                    entries: Array.from(this.messages.keys())
                });
            }
            
            // Limpar containers órfãos
            this.cleanOrphanContainers();
        }, 5000);
    }

    /**
     * Registra logs do sistema
     * @private
     */
    _log(level, message, data = {}) {
        logger[level](message, { ...data, source: 'messageRegistry.js' });
    }

    /**
     * Registra uma nova mensagem
     * @param {string} messageId - ID único da mensagem
     * @param {Object} data - Dados da mensagem
     * @returns {Object} Entrada criada no registry
     */
    registerMessage(messageId, data = {}) {
        this._log('debug', `Adicionando mensagem ${messageId}`);
        
        if (!messageId) {
            this._log('error', 'Tentativa de registrar mensagem sem ID');
            return null;
        }
        
        if (this.messages.has(messageId)) {
            this._log('warn', `Mensagem ${messageId} já existe no registro`);
            return this.messages.get(messageId);
        }
        
        // Criar nova entrada com flags padrão
        const entry = {
            ...data,
            created: Date.now(),
            isComplete: false,
            isStreaming: true
        };
        
        this.messages.set(messageId, entry);
        this._log('debug', `Mensagem ${messageId} registrada com sucesso`);
        
        return entry;
    }
    
    /**
     * Obtém uma mensagem do registro
     * @param {string} messageId - ID da mensagem
     * @returns {Object|null} Dados da mensagem ou null se não existir
     */
    getMessage(messageId) {
        this._log('debug', `Buscando mensagem ${messageId}`);
        if (!messageId) return null;
        return this.messages.get(messageId) || null;
    }
    
    /**
     * Atualiza dados de uma mensagem existente
     * @param {string} messageId - ID da mensagem
     * @param {Object} data - Novos dados a serem mesclados
     * @returns {boolean} Sucesso da operação
     */
    updateMessage(messageId, data) {
        if (!messageId || !this.messages.has(messageId)) {
            return false;
        }
        
        const entry = this.messages.get(messageId);
        Object.assign(entry, data);
        
        this._log('debug', `Mensagem ${messageId} atualizada`, {
            contentLength: entry.content?.length
        });
        
        return true;
    }
    
    /**
     * Adiciona conteúdo a uma mensagem existente
     * @param {string} messageId - ID da mensagem
     * @param {string} chunk - Chunk de conteúdo a ser adicionado
     * @returns {boolean} Sucesso da operação
     */
    addChunk(messageId, chunk) {
        const entry = this.messages.get(messageId);
        if (!entry) {
            this._log('error', `Tentativa de adicionar chunk a mensagem inexistente: ${messageId}`);
            return false;
        }

        entry.content = (entry.content || '') + chunk;
        this._log('debug', `Chunk adicionado à mensagem ${messageId}`);
        return true;
    }
    
    /**
     * Marca uma mensagem como completa
     * @param {string} messageId - ID da mensagem
     * @returns {boolean} Sucesso da operação
     */
    completeMessage(messageId) {
        const entry = this.messages.get(messageId);
        if (!entry) {
            this._log('error', `Tentativa de completar mensagem inexistente: ${messageId}`);
            return false;
        }

        entry.isComplete = true;
        entry.isStreaming = false;
        entry.completedAt = Date.now();
        
        this._log('info', `Mensagem ${messageId} marcada como completa`);
        return true;
    }
    
    /**
     * Remove uma mensagem do registro
     * @param {string} messageId - ID da mensagem
     * @returns {boolean} Sucesso da operação
     */
    removeMessage(messageId) {
        if (!messageId || !this.messages.has(messageId)) {
            return false;
        }
        
        const result = this.messages.delete(messageId);
        
        if (result) {
            this._log('debug', `Mensagem removida: ${messageId}`);
        }
        
        return result;
    }
    
    /**
     * Verifica se uma mensagem existe no registro
     * @param {string} messageId - ID da mensagem
     * @returns {boolean} Se a mensagem existe
     */
    hasMessage(messageId) {
        return this.messages.has(messageId);
    }
    
    /**
     * Obtém todas as mensagens de uma conversa
     * @param {string} conversationId - ID da conversa
     * @returns {Array} Lista de mensagens
     */
    getMessagesByConversation(conversationId) {
        if (!conversationId) return [];
        
        return Array.from(this.messages.values())
            .filter(entry => entry.conversationId === conversationId);
    }
    
    /**
     * Limpa containers que estão vazios ou abandonados
     */
    cleanOrphanContainers() {
        document.querySelectorAll('.message.assistant').forEach(container => {
            // Verificar se o container está vazio ou não tem messageId
            if (!container.dataset.messageId || !container.innerHTML.trim()) {
                this._log('debug', 'Removendo container órfão ou vazio', {
                    id: container.id,
                    messageId: container.dataset.messageId
                });
                container.remove();
            }
        });
    }
    
    /**
     * Verifica se existem múltiplas mensagens com conteúdo similar
     * Útil para detectar duplicações
     * @param {string} content - Conteúdo a verificar
     * @returns {Array} Lista de IDs de mensagens similares
     */
    findSimilarMessages(content) {
        if (!content || content.length < 10) return [];
        
        // Simplificar conteúdo para comparação
        const simplifiedContent = content
            .trim()
            .toLowerCase()
            .replace(/\s+/g, ' ')
            .substring(0, 100);  // Comparar apenas o início
            
        const similarMessages = [];
        
        this.messages.forEach((entry, id) => {
            if (!entry.content) return;
            
            const entryContent = entry.content
                .trim()
                .toLowerCase()
                .replace(/\s+/g, ' ')
                .substring(0, 100);
                
            if (entryContent === simplifiedContent) {
                similarMessages.push(id);
            }
        });
        
        if (similarMessages.length > 1) {
            this._log('warn', 'Múltiplas mensagens com conteúdo similar detectadas', {
                count: similarMessages.length,
                ids: similarMessages
            });
        }
        
        return similarMessages;
    }
}

// Exportar uma instância única do messageRegistry
export const messageRegistry = new MessageRegistry();

// Também exportar uma referência à instância global para conveniência
export const registry = messageRegistry;

// Para retrocompatibilidade
export default messageRegistry;

==========================================
Conteúdo de streamingManager.js (caminho: static\js\modules\streamingManager.js):
==========================================
import { socket } from '../main.js';
import { messageRegistry } from './messageRegistry.js';
import { renderMarkdown } from '../messageRenderer.js';
import { logger } from '../utils/logger.js';
/**
 * Importação do módulo marked via CDN
 * Esta importação corrige o erro: "Failed to resolve module specifier 'marked'"
 * Usa a mesma fonte CDN que já é utilizada em outros arquivos do projeto
 */
import { marked } from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js';

/**
 * Gerenciador de streaming e cache para mensagens da IA
 */
class StreamingManager {
    constructor() {
        this.streamingCache = {};
        this.activeContainers = new Map();
        this.initializeSocketListeners();
        
        // Configurar o cleanupOrphan para executar periodicamente (a cada 5 segundos)
        // Isto evita acúmulo de containers vazios ou órfãos na interface
        setInterval(() => this.cleanupOrphan(), 5000);
        
        // Log de inicialização
        logger.info('StreamingManager inicializado');
    }

    /**
     * Inicializa os listeners do Socket.IO
     */
    initializeSocketListeners() {
        if (!socket) {
            logger.error('Socket.IO não está disponível para o StreamingManager');
            return;
        }

        // Remover listeners anteriores para evitar duplicação
        socket.off('message_chunk');
        socket.off('response_complete');
        socket.off('stream_error');

        // Adicionar novos listeners
        socket.on('message_chunk', this.handleMessageChunk.bind(this));
        socket.on('response_complete', this.handleResponseComplete.bind(this));
        socket.on('stream_error', this.handleStreamError.bind(this));
        
        logger.debug('Listeners de Socket.IO inicializados no StreamingManager');
    }

    /**
     * Manipula chunks de mensagem recebidos
     */
    handleMessageChunk({ content, conversation_id, message_id, chunk_number }) {
        if (!content || !conversation_id || !message_id) {
            logger.warn('Chunk recebido com dados incompletos', {
                hasContent: !!content,
                hasConversationId: !!conversation_id,
                hasMessageId: !!message_id
            });
            return;
        }
        
        logger.debug('Chunk recebido', {
            messageId: message_id,
            conversationId: conversation_id,
            chunkNumber: chunk_number,
            contentSize: content.length
        });
        
        // Verificar se a conversa atual corresponde
        if (window.conversaAtual?.id !== conversation_id) {
            logger.debug('Ignorando chunk de outra conversa', {
                atual: window.conversaAtual?.id,
                recebido: conversation_id
            });
            return;
        }
        
        // Ocultar a animação de carregamento ao receber o primeiro chunk
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation && loadingAnimation.style.display === 'block') {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após receber chunk');
        }
        
        // Criar ou obter o container da mensagem
        let container;
        let entry = messageRegistry.messages.get(message_id);
        
        logger.debug('Processando chunk', {
            messageId: message_id,
            conversationId: conversation_id,
            chunkNumber: chunk_number,
            contentSize: content?.length,
            processedChunks: messageRegistry.messages.get(message_id)?.processedChunks || [],
            timestamp: Date.now()
        });

        if (!entry) {
            // Criar novo container e registrar a mensagem
            container = this.createMessageContainer(message_id, conversation_id);
            entry = this.registerMessage(message_id, container, false);
            entry.isStreaming = true;
            entry.content = content;
            
            // Renderizar o conteúdo inicial imediatamente
            const contentDiv = container.querySelector('.message-content');
            if (contentDiv) {
                contentDiv.innerHTML = marked.parse(content);
                this.manageScroll(container);
            }
        } else {
            container = entry.container;
            if (!container || !container.isConnected) {
                container = this.createMessageContainer(message_id, conversation_id);
                entry.container = container;
            }
            
            // Verificar se este chunk já foi processado
            if (!entry.processedChunks) {
                entry.processedChunks = [];
            }
            
            if (entry.processedChunks.includes(chunk_number)) {
                logger.warn('Chunk duplicado detectado e ignorado', {
                    messageId: message_id,
                    chunkNumber: chunk_number,
                    processedChunks: entry.processedChunks
                });
                return;
            }

            // Verificar ordem dos chunks
            if (entry.processedChunks.length > 0) {
                const lastChunk = Math.max(...entry.processedChunks);
                if (chunk_number < lastChunk) {
                    logger.warn('Chunk fora de ordem detectado', {
                        messageId: message_id,
                        chunkNumber: chunk_number,
                        lastProcessedChunk: lastChunk,
                        processedChunks: entry.processedChunks
                    });
                }
            }

            // Registrar o chunk como processado
            entry.processedChunks.push(chunk_number);
            entry.lastChunkTime = Date.now();

            // Adicionar o chunk ao conteúdo existente
            entry.content += content;
            entry.isStreaming = true;
            
            // Remover qualquer loading-dots remanescente
            const contentDiv = container.querySelector('.message-content');
            const loadingDots = contentDiv.querySelector('.loading-dots');
            if (loadingDots) loadingDots.remove();
            
            // Renderizar o conteúdo atualizado
            contentDiv.innerHTML = marked.parse(entry.content);
            this.manageScroll(container);
        }

        // Registrar timestamp do último chunk
        if (entry) {
            entry.lastChunkTime = Date.now();
            logger.debug('Estado após processamento do chunk', {
                messageId: message_id,
                processedChunks: entry.processedChunks,
                contentLength: entry.content?.length,
                timeSinceLastChunk: entry.lastChunkTime - (entry.firstChunkTime || entry.lastChunkTime)
            });
        }
    }

    /**
     * Manipula a conclusão da resposta
     */
    handleResponseComplete({ conversation_id, message_id, complete_response, total_chunks }) {
        if (!message_id || !conversation_id) {
            logger.warn('Resposta completa com dados incompletos', {
                hasMessageId: !!message_id,
                hasConversationId: !!conversation_id
            });
            return;
        }
        
        logger.info('Resposta completa recebida', {
            messageId: message_id,
            conversationId: conversation_id,
            totalChunks: total_chunks
        });
        
        // Verificar se a conversa atual corresponde
        if (window.conversaAtual?.id !== conversation_id) {
            logger.debug('Ignorando resposta completa de outra conversa', {
                atual: window.conversaAtual?.id,
                recebido: conversation_id
            });
            return;
        }
        
        // Ocultar a animação de carregamento ao completar a resposta
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation && loadingAnimation.style.display === 'block') {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após completar resposta');
        }
        
        // Verificar se a mensagem existe no registry
        if (!messageRegistry.messages.has(message_id)) {
            logger.warn(`Mensagem não encontrada no registry: ${message_id}`);
            
            // Se temos o complete_response, podemos criar agora
            if (complete_response) {
                const container = this.createMessageContainer(message_id, conversation_id);
                const entry = this.registerMessage(message_id, container, false);
                entry.content = complete_response;
                entry.isComplete = true;
                entry.isStreaming = false;
                
                this.renderCompleteMessage(message_id, conversation_id);
            } else {
                return;
            }
        } else {
            // Marcar como completa
            const entry = messageRegistry.messages.get(message_id);
            if (entry) {
                if (complete_response && complete_response !== entry.content) {
                    entry.content = complete_response;
                }
                
                // Atualizar flags para indicar que a mensagem está completa e o streaming terminou
                // Isto é essencial para evitar que o cleanupOrphan remova esta mensagem
                entry.isComplete = true;
                entry.isStreaming = false;
                
                // Atualizar a interface
                this.renderCompleteMessage(message_id, conversation_id);
                
                // Remover loading dots se existirem
                const contentDiv = entry.container.querySelector('.message-content');
                const loadingDots = contentDiv.querySelector('.loading-dots');
                if (loadingDots) loadingDots.remove();
            }
        }
        
        // Limpar do streamingCache
        if (this.streamingCache[conversation_id]) {
            delete this.streamingCache[conversation_id][message_id];
            if (Object.keys(this.streamingCache[conversation_id]).length === 0) {
                delete this.streamingCache[conversation_id];
            }
        }
        
        // Remover do activeContainers
        this.activeContainers.delete(message_id);

        logger.info('Finalizando processamento de mensagem', {
            messageId: message_id,
            conversationId: conversation_id,
            totalChunksProcessed: messageRegistry.messages.get(message_id)?.processedChunks?.length || 0,
            expectedTotalChunks: total_chunks,
            timingInfo: this.getMessageTimingInfo(message_id),
            contentMatch: this.validateContentMatch(message_id, complete_response)
        });

        const entry = messageRegistry.messages.get(message_id);
        if (entry) {
            // Verificar se todos os chunks foram recebidos
            const processedCount = entry.processedChunks?.length || 0;
            if (processedCount !== total_chunks) {
                logger.warn('Discrepância no número de chunks', {
                    messageId: message_id,
                    processedChunks: processedCount,
                    expectedChunks: total_chunks,
                    missingChunks: this.findMissingChunks(entry.processedChunks, total_chunks)
                });
            }

            // Verificar por possíveis duplicações
            const duplicateCheck = this.checkForDuplicates(conversation_id, complete_response);
            if (duplicateCheck.hasDuplicates) {
                logger.warn('Possível duplicação de conteúdo detectada', {
                    messageId: message_id,
                    similarMessageIds: duplicateCheck.similarMessageIds,
                    similarityScore: duplicateCheck.similarityScore
                });
            }
        }
    }

    /**
     * Manipula erros de streaming
     */
    handleStreamError({ conversation_id, message_id, error }) {
        logger.error('Erro no streaming', {
            messageId: message_id,
            conversationId: conversation_id,
            error
        });
        
        // Ocultar a animação de carregamento em caso de erro
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation && loadingAnimation.style.display === 'block') {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após erro no streaming');
        }
        
        const entry = messageRegistry.messages.get(message_id);
        if (entry && entry.container) {
            entry.container.innerHTML = `<div class="error-message">Erro: ${error}</div>`;
            entry.container.classList.add('error');
        }
        
        // Limpar do streamingCache
        if (this.streamingCache[conversation_id]) {
            delete this.streamingCache[conversation_id][message_id];
            if (Object.keys(this.streamingCache[conversation_id]).length === 0) {
                delete this.streamingCache[conversation_id];
            }
        }
        
        // Remover do activeContainers
        this.activeContainers.delete(message_id);
    }

    /**
     * Atualiza a UI para uma mensagem
     */
    updateMessageUI(messageId, conversationId) {
        const entry = messageRegistry.messages.get(messageId);
        if (!entry) return;
        
        // Verificar se há um container válido
        let container = entry.container;
        
        if (!container || !container.isConnected) {
            container = this.createMessageContainer(messageId, conversationId);
            messageRegistry.updateMessage(messageId, { container });
        }
        
        // Renderizar conteúdo
        this.renderStreamingContent(messageId, conversationId);
    }

    /**
     * Cria um container para a mensagem
     */
    createMessageContainer(messageId, conversationId) {
        const chatContainer = document.querySelector('.chat-container');
        if (!chatContainer) {
            logger.error('Container de chat não encontrado');
            return null;
        }
        
        // Verificar se já existe um container para essa mensagem
        let container = document.querySelector(`[data-message-id="${messageId}"]`);
        
        if (container) {
            logger.debug(`Container existente encontrado para mensagem ${messageId}`);
            return container;
        }
        
        // Verificar também se já existe uma mensagem completa recente para esta conversa
        // para evitar duplicações visuais
        const existingMessages = document.querySelectorAll(`.message.assistant[data-conversation-id="${conversationId}"]`);
        
        if (existingMessages.length > 0) {
            const lastMessage = existingMessages[existingMessages.length - 1];
            const lastMessageId = lastMessage.dataset.messageId;
            
            // Se a última mensagem é recente (criada há menos de 2 segundos), pode ser uma duplicação
            const lastCreationTime = parseInt(lastMessageId.split('_').pop(), 10) || 0;
            const now = Date.now();
            
            if (now - lastCreationTime < 2000) {
                logger.warn('Possível duplicação de container detectada', {
                    messageId,
                    existingId: lastMessageId,
                    timeDiff: now - lastCreationTime
                });
                
                // Não impedimos a criação, apenas logamos para diagnóstico
            }
        }
        
        // Criar e adicionar ao DOM
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message assistant';
        messageDiv.dataset.messageId = messageId;
        messageDiv.dataset.conversationId = conversationId;
        
        // Criar container de conteúdo vazio que será preenchido com o conteúdo real
        // Não usamos mais os "três pontinhos" ou qualquer placeholder
        messageDiv.innerHTML = `<div class="message-content"></div>`;
        
        // Adicionar antes do final do chat
        chatContainer.appendChild(messageDiv);
        
        // Verificar se a animação centralizada está visível
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation && loadingAnimation.style.display !== 'block') {
            // Se não estiver visível e estamos criando uma mensagem, mostrar
            loadingAnimation.style.display = 'block';
            logger.debug('Animação de carregamento exibida ao criar container de mensagem');
        }
        
        // Registrar no messageRegistry como uma mensagem real (não cursor)
        this.registerMessage(messageId, messageDiv, false);
        
        return messageDiv;
    }

    /**
     * Renderiza o conteúdo de streaming
     */
    renderStreamingContent(messageId, conversationId) {
        const entry = messageRegistry.messages.get(messageId);
        if (!entry || !entry.container) return;
        
        const content = entry.content;
        const container = entry.container;
        
        try {
            // Renderizar Markdown e sanitizar
            const renderedContent = renderMarkdown(content + '<span class="streaming-cursor">█</span>');
            container.innerHTML = renderedContent;
            
            // Manter scroll na última posição visível
            this.manageScroll(container);
        } catch (error) {
            logger.error('Erro ao renderizar conteúdo de streaming', {
                messageId,
                error: error.message
            });
        }
    }

    /**
     * Renderiza uma mensagem completa
     */
    renderCompleteMessage(messageId, conversationId) {
        const entry = messageRegistry.messages.get(messageId);
        if (!entry || !entry.container) {
            logger.error('Container não encontrado para renderização completa', { 
                messageId, 
                conversationId,
                hasEntry: !!entry
            });
            return;
        }
        
        // Verificar se já existe uma mensagem completa para esta conversa
        const existingCompleteMessages = document.querySelectorAll(`.message.assistant.complete[data-conversation-id="${conversationId}"]`);
        const lastCompleteMessage = existingCompleteMessages.length > 0 ? 
            existingCompleteMessages[existingCompleteMessages.length - 1] : null;
        
        // Se existir uma mensagem completa recente e o conteúdo for muito similar, podemos estar duplicando
        if (lastCompleteMessage && lastCompleteMessage !== entry.container) {
            const lastContent = lastCompleteMessage.querySelector('.message-content')?.textContent || '';
            const currentContent = entry.content || '';
            
            // Comparar os primeiros 50 caracteres para determinar similaridade
            const isSimilar = lastContent.substring(0, 50).trim() === currentContent.substring(0, 50).trim();
            
            if (isSimilar) {
                logger.warn('Possível duplicação de mensagem detectada', {
                    messageId,
                    existingId: lastCompleteMessage.dataset.messageId,
                    similarity: 'primeiros 50 caracteres iguais'
                });
                
                // Apenas logamos e continuamos, porque pode ser uma resposta legitimamente similar
            }
        }
        
        const content = entry.content;
        const container = entry.container;
        
        logger.debug('Renderizando mensagem completa', {
            messageId,
            conversationId,
            containerClass: container.className,
            contentLength: content?.length
        });
        
        try {
            // Remover classes de streaming
            container.classList.remove('streaming');
            container.classList.add('complete');
            
            // Preservar os botões de ação
            const actionsElement = container.querySelector('.message-actions');
            
            // Obter o elemento de conteúdo
            const contentElement = container.querySelector('.message-content');
            
            // Renderizar Markdown e sanitizar
            const renderedContent = renderMarkdown(content);
            
            if (contentElement) {
                // Atualizar apenas o conteúdo sem substituir a estrutura
                contentElement.innerHTML = renderedContent;
                logger.debug('Conteúdo atualizado mantendo estrutura existente', { messageId });
            } else {
                // Se não existir, criar a estrutura completa
                logger.warn('Elemento message-content não encontrado ao completar mensagem', { messageId });
                
                // Preservar a estrutura original com o conteúdo atualizado
                container.innerHTML = `<div class="message-content">${renderedContent}</div>`;
                
                // Re-adicionar os botões de ação se já existiam
                if (actionsElement) {
                    container.appendChild(actionsElement);
                    logger.debug('Botões de ação readicionados', { messageId });
                } else {
                    // Adicionar botões de ação se necessário
                    this.addActionButtons(container, messageId);
                    logger.debug('Novos botões de ação adicionados', { messageId });
                }
            }
            
            logger.info(`Mensagem ${messageId} renderizada como completa`);
        } catch (error) {
            logger.error('Erro ao renderizar conteúdo completo', {
                messageId,
                error: error.message,
                stack: error.stack
            });
        }
    }

    /**
     * Adiciona botões de ação à mensagem
     */
    addActionButtons(container, messageId) {
        // Verificar se já existem botões
        if (container.querySelector('.message-actions')) {
            return;
        }
        
        // Adicionar botões
        const actions = document.createElement('div');
        actions.className = 'message-actions';
        actions.innerHTML = `
            <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                <i class="fas fa-copy"></i>
            </button>
        `;
        
        container.appendChild(actions);
    }

    /**
     * Gerencia o scroll durante o streaming
     */
    manageScroll(container) {
        // Calcular se o usuário está próximo do final
        const chatContainer = document.querySelector('.chat-container');
        if (!chatContainer) return;
        
        const { scrollTop, scrollHeight, clientHeight } = chatContainer;
        const distanceToBottom = scrollHeight - scrollTop - clientHeight;
        
        // Se estiver próximo do final, scroll automático
        if (distanceToBottom < 200) {
            container.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
    }

    /**
     * Registra uma nova mensagem no messageRegistry com flags adicionais
     * As flags isCursor e isComplete são essenciais para o gerenciamento do ciclo de vida das mensagens
     * 
     * @param {string} messageId - ID da mensagem
     * @param {HTMLElement} container - Elemento DOM do container da mensagem
     * @param {boolean} isCursor - Se é apenas um cursor de digitação
     * @returns {Object} Entrada criada no registry
     */
    registerMessage(messageId, container, isCursor = false) {
        if (!messageRegistry) {
            logger.error('MessageRegistry não está disponível');
            return null;
        }
        
        // Criar objeto com as flags necessárias para controle dos containers
        const entry = {
            content: '',
            rendered: false,
            container: container,
            timer: null,
            isCursor: isCursor,        // true se for apenas um cursor de digitação
            isComplete: false,         // true após response_complete (mensagem finalizada)
            isStreaming: !isCursor     // false se for apenas cursor, true se estiver recebendo chunks
        };
        
        messageRegistry.messages.set(messageId, entry);
        logger.info(`Registrada entrada para messageId: ${messageId}, isCursor: ${isCursor}`);
        
        return entry;
    }
    
    /**
     * Limpa containers órfãos ou incompletos
     * Esta função é crítica para evitar containers vazios ou desnecessários na interface
     * A lógica implementada garante que:
     * 1. Containers com isCursor=true e isStreaming=false sejam removidos
     * 2. Containers com isStreaming=false e isComplete=false sejam removidos
     * 3. Containers com isComplete=true sejam SEMPRE preservados
     */
    cleanupOrphan() {
        if (!messageRegistry) {
            logger.warn('MessageRegistry não disponível para limpeza');
            return;
        }
        
        // Usar .messages.entries() para iterar sobre o Map em vez de .entries()
        for (const [messageId, entry] of messageRegistry.messages.entries()) {
            if (entry.isCursor && !entry.isStreaming) {
                // Remover containers de cursor sem streaming ativo
                // Isto evita cursores "fantasmas" que não estão mais em uso
                if (entry.container && entry.container.isConnected) {
                    entry.container.remove();
                }
                messageRegistry.messages.delete(messageId);
                logger.debug(`Removido container de cursor órfão: ${messageId}`);
            } else if (!entry.isStreaming && !entry.isComplete) {
                // Remover mensagens incompletas sem streaming
                // Isto evita mensagens "abandonadas" que nunca foram finalizadas
                if (entry.container && entry.container.isConnected) {
                    entry.container.remove();
                }
                messageRegistry.messages.delete(messageId);
                logger.debug(`Removido container de mensagem incompleta: ${messageId}`);
            }
            // Não remover NUNCA containers com isComplete=true
            // Isto garante que mensagens finalizadas permaneçam visíveis
        }
    }

    /**
     * Encontra chunks faltantes na sequência
     * @private
     */
    findMissingChunks(processedChunks = [], totalExpected) {
        const missing = [];
        if (!processedChunks.length) return Array.from({length: totalExpected}, (_, i) => i);
        
        for (let i = 0; i < totalExpected; i++) {
            if (!processedChunks.includes(i)) {
                missing.push(i);
            }
        }
        return missing;
    }

    /**
     * Obtém informações de timing da mensagem
     * @private
     */
    getMessageTimingInfo(messageId) {
        const entry = messageRegistry.messages.get(messageId);
        if (!entry) return null;

        return {
            firstChunkTime: entry.firstChunkTime,
            lastChunkTime: entry.lastChunkTime,
            totalProcessingTime: entry.lastChunkTime - entry.firstChunkTime,
            averageTimeBetweenChunks: this.calculateAverageChunkTiming(entry)
        };
    }

    /**
     * Calcula tempo médio entre chunks
     * @private
     */
    calculateAverageChunkTiming(entry) {
        if (!entry.chunkTimings || entry.chunkTimings.length < 2) return null;
        
        let totalDiff = 0;
        for (let i = 1; i < entry.chunkTimings.length; i++) {
            totalDiff += entry.chunkTimings[i] - entry.chunkTimings[i-1];
        }
        return totalDiff / (entry.chunkTimings.length - 1);
    }

    /**
     * Verifica correspondência entre conteúdo acumulado e resposta completa
     * @private
     */
    validateContentMatch(messageId, completeResponse) {
        const entry = messageRegistry.messages.get(messageId);
        if (!entry || !completeResponse) return { matches: true };  // assume match if can't verify

        const accumulated = entry.content || '';
        if (accumulated === completeResponse) return { matches: true };

        // Se não corresponder exatamente, calcular diferença
        return {
            matches: false,
            accumulatedLength: accumulated.length,
            completeLength: completeResponse.length,
            firstDifferenceAt: this.findFirstDifference(accumulated, completeResponse)
        };
    }

    /**
     * Encontra a primeira diferença entre duas strings
     * @private
     */
    findFirstDifference(str1, str2) {
        const minLength = Math.min(str1.length, str2.length);
        for (let i = 0; i < minLength; i++) {
            if (str1[i] !== str2[i]) return i;
        }
        return str1.length === str2.length ? -1 : minLength;
    }

    /**
     * Verifica duplicações de conteúdo
     * @private
     */
    checkForDuplicates(conversationId, content) {
        const messages = Array.from(messageRegistry.messages.values())
            .filter(m => m.conversationId === conversationId && m.isComplete);
        
        const duplicates = {
            hasDuplicates: false,
            similarMessageIds: [],
            similarityScore: 0
        };

        for (const message of messages) {
            if (!message.content || message.content === content) continue;
            
            const similarity = this.calculateSimilarity(content, message.content);
            if (similarity > 0.9) {  // 90% similar
                duplicates.hasDuplicates = true;
                duplicates.similarMessageIds.push(message.id);
                duplicates.similarityScore = Math.max(duplicates.similarityScore, similarity);
            }
        }

        return duplicates;
    }

    /**
     * Calcula similaridade entre duas strings (0-1)
     * @private
     */
    calculateSimilarity(str1, str2) {
        // Simplificação para comparação rápida
        const sample1 = str1.substring(0, 100).toLowerCase();
        const sample2 = str2.substring(0, 100).toLowerCase();
        
        let matches = 0;
        const minLength = Math.min(sample1.length, sample2.length);
        
        for (let i = 0; i < minLength; i++) {
            if (sample1[i] === sample2[i]) matches++;
        }
        
        return matches / minLength;
    }
}

// Exportar instância única
export const streamingManager = new StreamingManager();

==========================================
Conteúdo de sidebar.js (caminho: static\js\sidebar.js):
==========================================
export function toggleSidebar() {
    console.log('[DEBUG] Função toggleSidebar chamada');
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');
    
    if (sidebar && mainContent) {
        sidebar.classList.toggle('collapsed');
        mainContent.classList.toggle('expanded');
        
        // Salvar o estado da barra lateral no localStorage
        const isCollapsed = sidebar.classList.contains('collapsed');
        localStorage.setItem('sidebarCollapsed', isCollapsed);
    }
}

export function initSidebar() {
    // Verificar o estado salvo da barra lateral
    const sidebarCollapsed = localStorage.getItem('sidebarCollapsed') === 'true';
    const sidebar = document.querySelector('.sidebar');
    const mainContent = document.querySelector('.main-content');
    
    if (sidebar && mainContent && sidebarCollapsed) {
        sidebar.classList.add('collapsed');
        mainContent.classList.add('expanded');
    }
    
    // Ajustar para dispositivos móveis
    if (window.innerWidth <= 768) {
        sidebar?.classList.add('collapsed');
        mainContent?.classList.add('expanded');
    }
    
    // Detectar redimensionamento da janela
    window.addEventListener('resize', () => {
        if (window.innerWidth <= 768) {
            sidebar?.classList.add('collapsed');
            mainContent?.classList.add('expanded');
        }
    });
}


==========================================
Conteúdo de textarea.js (caminho: static\js\textarea.js):
==========================================

export function configureTextarea(textarea) {
    if (!textarea) return;

    textarea.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
    });

    textarea.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const form = this.closest('form');
            if (form) {
                const event = new Event('submit', {
                    'bubbles': true,
                    'cancelable': true
                });
                form.dispatchEvent(event);
            }
        }
    });
}


==========================================
Conteúdo de theme.js (caminho: static\js\theme.js):
==========================================
// Estado do tema
let currentTheme = 'light';

// Função para alternar o tema
export function toggleTheme() {
    console.log('[DEBUG] Função toggleTheme chamada');
    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
    applyTheme(currentTheme);
    localStorage.setItem('theme', currentTheme);
}

// Função para aplicar o tema
function applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    
    const themeToggle = document.querySelector('.theme-toggle');
    if (themeToggle) {
        // Ícones minimalistas com linhas finas
        themeToggle.innerHTML = theme === 'light' 
            ? '<i class="fas fa-moon" style="font-weight: 100;"></i>' 
            : '<i class="fas fa-sun" style="font-weight: 100;"></i>';
    }
    
    // Atualizar meta tag para tema do navegador em dispositivos móveis
    const metaThemeColor = document.querySelector('meta[name="theme-color"]');
    if (metaThemeColor) {
        metaThemeColor.setAttribute('content', 
            theme === 'light' ? '#f9f9fb' : '#1A1A1A');
    }
    
    // Atualizar o ícone de enviar mensagem
    const sendBtns = document.querySelectorAll('.send-btn');
    sendBtns.forEach(btn => {
        btn.innerHTML = '<i class="fas fa-arrow-up" style="font-size: 0.9rem;"></i>';
    });
}

// Função para inicializar o tema
export function initializeTheme() {
    // Verificar preferência do sistema
    const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    // Verificar tema salvo ou usar preferência do sistema
    const savedTheme = localStorage.getItem('theme');
    currentTheme = savedTheme || (prefersDark ? 'dark' : 'light');
    
    // Aplicar tema
    applyTheme(currentTheme);
    
    // Ouvir mudanças na preferência do sistema
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
        if (!localStorage.getItem('theme')) {
            currentTheme = event.matches ? 'dark' : 'light';
            applyTheme(currentTheme);
        }
    });
}


==========================================
Conteúdo de logger.js (caminho: static\js\utils\logger.js):
==========================================
/**
 * Sistema centralizado de logs para aplicação de chat
 * Fornece funcionalidades para registrar eventos, erros e estado do sistema
 * com níveis de log e envio para o backend
 */

// Níveis de log disponíveis
const LOG_LEVELS = {
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3
};

// Configuração do nível de log atual
const currentLogLevel = LOG_LEVELS.DEBUG;

/**
 * Função principal de log que gerencia tanto logs locais (console) quanto remotos (backend)
 * @param {string} level - Nível do log (DEBUG, INFO, WARN, ERROR)
 * @param {string} message - Mensagem do log
 * @param {Object} data - Dados adicionais para contexto do log
 * @param {string} source - Origem do log (arquivo/módulo)
 */
export function log(level, message, data = {}, source = '') {
  if (LOG_LEVELS[level] >= currentLogLevel) {
    const timestamp = new Date().toISOString();
    const context = 'frontend';
    
    // Log local no console com estilo
    const styles = {
      DEBUG: 'color: gray',
      INFO: 'color: blue',
      WARN: 'color: orange',
      ERROR: 'color: red; font-weight: bold'
    };
    
    // Formatação consistente da mensagem
    const logMessage = `[${level}] ${source ? `[${source}] ` : ''}${timestamp} - ${message}`;
    
    // Log no console local
    console.log(`%c${logMessage}`, styles[level], data);
    
    // Extrair IDs relevantes dos dados ou contexto global
    const messageId = data.messageId || data.message_id;
    const conversationId = data.conversationId || data.conversation_id || window.conversaAtual?.id;
    
    // Preparar payload para o backend
    const logData = {
      level,
      message,
      data,
      timestamp,
      context,
      source,
      url: window.location.href,
      messageId,
      conversationId
    };
    
    // Enviar log para o backend (assíncrono)
    fetch('/log-frontend', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(logData)
    }).catch(err => console.error('[ERROR] Falha ao enviar log ao backend:', err));
  }
}

// Interface simplificada para diferentes níveis de log
export const logger = {
  debug: (message, data = {}, source = '') => log('DEBUG', message, data, source),
  info: (message, data = {}, source = '') => log('INFO', message, data, source),
  warn: (message, data = {}, source = '') => log('WARN', message, data, source),
  error: (message, data = {}, source = '') => log('ERROR', message, data, source),
  
  // Função específica para rastreamento de mensagens
  trackMessage: (action, messageId, conversationId, extra = {}) => {
    log('INFO', `Message ${action}`, {
      messageId,
      conversationId,
      action,
      ...extra
    }, 'message-tracker');
  }
};

// Interceptar erros não capturados
window.addEventListener('error', (event) => {
  logger.error('Erro não capturado', {
    message: event.message,
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno,
    error: event.error?.stack || 'Sem stack disponível'
  }, 'window');
});

// Interceptar rejeições de promises não tratadas
window.addEventListener('unhandledrejection', (event) => {
  logger.error('Promise rejeitada não tratada', {
    reason: event.reason?.message || event.reason,
    stack: event.reason?.stack || 'Sem stack disponível'
  }, 'window');
});

export default logger;

==========================================
Conteúdo de utils.js (caminho: static\js\utils.js):
==========================================
export function escapeHTML(text) {
    const div = document.createElement('div');
    div.innerText = text;
    return div.innerHTML;
}

export function mostrarCarregamento(chatContainer) {
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'loading message assistant';
    loadingDiv.setAttribute('data-no-markdown', 'true');
    loadingDiv.innerHTML = `
        <span></span>
        <span></span>
        <span></span>
    `;
    chatContainer.appendChild(loadingDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
    return loadingDiv;
}

==========================================
Conteúdo de youtubeEvents.js (caminho: static\js\youtube-system\youtubeEvents.js):
==========================================
// youtubeEvents.js
// Este arquivo lidará com os eventos Socket.IO relacionados ao YouTube.

let isProcessingYoutube = false;

export function setupYoutubeEvents(socket) {
    // Evento para quando a mensagem do usuário é salva
    socket.on('message_saved', (data) => {
        console.log("[DEBUG] Mensagem do usuário salva:", data);
        const conversationId = window.conversaAtual?.id;
        
        if (!data.conversation_id || data.conversation_id !== conversationId) {
            console.log("[DEBUG] Ignorando evento: conversa diferente");
            return;
        }
        
        const chatContainer = document.querySelector('.chat-container');
        if (!chatContainer) {
            console.log("[ERRO] Chat container não encontrado");
            return;
        }

        // Remove qualquer indicador de carregamento existente
        const loadingDivs = chatContainer.querySelectorAll('.loading');
        loadingDivs.forEach(div => div.remove());

        console.log("[DEBUG] Adicionando mensagem do usuário ao chat");
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message user';
        messageDiv.innerHTML = `
            <div class="message-content">
                <span>${data.content}</span>
            </div>
        `;
        
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
        
        console.log("[DEBUG] Mensagem do usuário adicionada com sucesso");
    });

    // Evento para resposta do processamento do YouTube
    socket.on('youtube_response', (data) => {
        console.log("[DEBUG] Recebido youtube_response:", data);
        const chatContainer = document.querySelector('.chat-container');
        const conversationId = window.conversaAtual?.id;

        if (!chatContainer || !conversationId || data.conversation_id !== conversationId) {
            console.log("[DEBUG] Ignorando resposta: container não encontrado ou conversa diferente");
            return;
        }

        // Remove todos os indicadores de carregamento existentes
        const loadingDivs = chatContainer.querySelectorAll('.loading');
        loadingDivs.forEach(div => {
            console.log("[DEBUG] Removendo indicador de carregamento");
            div.remove();
        });

        // Reseta o estado de processamento
        isProcessingYoutube = false;
        const sendBtn = document.querySelector('#send-btn');
        if (sendBtn) sendBtn.disabled = false;

        // Verifica se já existe uma resposta com o mesmo message_id
        if (data.message_id) {
            const existingMessage = chatContainer.querySelector(`.message[data-message-id="${data.message_id}"]`);
            if (existingMessage) {
                console.log("[DEBUG] Resposta já existe, ignorando duplicata");
                return;
            }
        }

        if (data.status === 'error') {
            console.log("[DEBUG] Exibindo mensagem de erro");
            const errorMessage = document.createElement('div');
            errorMessage.className = 'message error';
            errorMessage.dataset.messageId = data.message_id || `error_${Date.now()}`;
            errorMessage.innerHTML = `
                <div class="message-content">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>${data.error}</span>
                </div>
            `;
            
            chatContainer.appendChild(errorMessage);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            return;
        }

        if (data.status === 'success' && data.content) {
            console.log("[DEBUG] Exibindo resposta do YouTube");
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant youtube';
            messageDiv.dataset.messageId = data.message_id || `youtube_${Date.now()}`;
            messageDiv.innerHTML = `
                <div class="message-content">
                    ${marked.parse(data.content)}
                </div>
                <div class="message-actions">
                    <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            `;
            
            chatContainer.appendChild(messageDiv);
            messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });

            // Notifica que uma nova mensagem foi adicionada
            const event = new CustomEvent('messageAdded', {
                detail: {
                    type: 'youtube',
                    messageId: messageDiv.dataset.messageId,
                    conversationId: data.conversation_id
                }
            });
            chatContainer.dispatchEvent(event);
            
            console.log("[DEBUG] Resposta do YouTube renderizada com sucesso");
        }
    });
}

export function handleYoutubeCommand(command, socket) {
    if (isProcessingYoutube) {
        console.log('[DEBUG] Já existe um processamento de YouTube em andamento');
        return;
    }

    console.log('[DEBUG] Processando comando do YouTube:', command);
    
    // Verificar se a mensagem já existe
    const existingMessage = document.querySelector(`.message[data-message-id="${command.message_id}"]`);
    if (existingMessage) {
        console.log('[DEBUG] Mensagem já existe, ignorando');
        return;
    }
    
    // Ativar estado de processamento
    isProcessingYoutube = true;
    const sendBtn = document.querySelector('#send-btn');
    if (sendBtn) sendBtn.disabled = true;
    
    // Adicionar animação de carregamento
    const chatContainer = document.querySelector('.chat-container');
    if (chatContainer) {
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'message loading';
        loadingDiv.innerHTML = `
            <div class="message-content">
                <div class="loading-spinner">
                    <i class="fas fa-spinner fa-spin"></i>
                    <span>Processando vídeo do YouTube...</span>
                </div>
            </div>
        `;
        chatContainer.appendChild(loadingDiv);
        chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
    }
    
    // Enviar comando para o servidor
    socket.emit('youtube_command', command);
} 

==========================================
Conteúdo de youtubeHandler.js (caminho: static\js\youtube-system\youtubeHandler.js):
==========================================
// youtubeHandler.js
import { logger } from '../utils/logger.js';
import { marked } from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js';
import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js';

let isProcessingYoutube = false;

export async function handleYoutubeCommand(command, conversationId) {
    logger.info('Iniciando processamento de comando YouTube', {
        conversationId,
        isProcessing: isProcessingYoutube
    });

    if (isProcessingYoutube) {
        logger.warn('Processamento de YouTube já em andamento, ignorando comando');
        return;
    }

    // Extrair a URL do vídeo do comando
    const videoUrl = command.split(' ')[1];
    if (!videoUrl) {
        logger.error('URL do vídeo não fornecida no comando');
        throw new Error('URL do vídeo não fornecida');
    }

    // Validar se a URL é do YouTube
    if (!videoUrl.includes('youtube.com') && !videoUrl.includes('youtu.be')) {
        logger.error('URL inválida fornecida', { url: videoUrl });
        throw new Error('URL inválida. Use um link do YouTube válido.');
    }

    logger.debug('Iniciando processamento de vídeo', {
        url: videoUrl,
        conversationId
    });
    
    try {
        isProcessingYoutube = true;
        const sendBtn = document.querySelector('#send-btn');
        if (sendBtn) {
            sendBtn.disabled = true;
            logger.debug('Botão de envio desabilitado');
        }

        // Exibir animação de carregamento centralizada
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation) {
            loadingAnimation.style.display = 'block';
            logger.debug('Animação de carregamento exibida');
        }

        logger.info('Enviando requisição para processar vídeo', {
            url: videoUrl,
            conversationId
        });

        // Enviar requisição para processar o vídeo
        const response = await fetch('/process_youtube', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                conversation_id: conversationId,
                video_url: videoUrl
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            logger.error('Falha na resposta do servidor', {
                status: response.status,
                error: errorData.error
            });
            throw new Error(errorData.error || 'Erro ao processar vídeo');
        }

        const data = await response.json();
        logger.info('Processamento do vídeo iniciado pelo backend', {
            status: data.status,
            conversationId
        });
        
        // Entrar na sala da conversa para receber eventos
        if (window.socket) {
            window.socket.emit('join_conversation', { conversation_id: conversationId });
            logger.debug('Entrou na sala da conversa para eventos', { conversationId });
        } else {
            logger.error('Socket não inicializado');
        }
        
        return data;
    } catch (error) {
        logger.error('Erro no processamento do vídeo', {
            error: error.message,
            stack: error.stack,
            conversationId
        });
        
        // Esconder animação em caso de erro
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation) {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após erro');
        }
        
        throw error;
    } finally {
        setTimeout(() => {
            isProcessingYoutube = false;
            const sendBtn = document.querySelector('#send-btn');
            if (sendBtn) {
                sendBtn.disabled = false;
                logger.debug('Botão de envio reabilitado');
            }
        }, 2000);
    }
}

// Função para configurar os listeners de eventos do Socket.IO
export function setupYoutubeSocketListeners(socket) {
    logger.info('Configurando listeners do YouTube');
    
    socket.on('youtube_response', (response) => {
        logger.debug('Resposta do YouTube recebida', {
            status: response.status,
            conversationId: response.conversation_id,
            messageId: response.message_id
        });

        const chatContainer = document.querySelector('.chat-container');
        const loadingAnimation = document.getElementById('loading-animation');

        if (response.status === 'processing') {
            // Manter animação visível
            if (loadingAnimation) {
                loadingAnimation.style.display = 'block';
                logger.debug('Mantendo animação de carregamento');
            }
            return;
        }

        // Esconder animação ao receber resposta final ou erro
        if (loadingAnimation) {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada');
        }

        // Verificar se a mensagem já existe no DOM
        if (response.message_id) {
            const existingMessage = document.querySelector(`.message[data-message-id="${response.message_id}"]`);
            if (existingMessage) {
                logger.warn('Detectada tentativa de mensagem duplicada', {
                    messageId: response.message_id,
                    status: response.status
                });
                return;
            }
        }

        if (response.status === 'success' && response.content) {
            logger.info('Renderizando resposta do YouTube', {
                messageId: response.message_id,
                conversationId: response.conversation_id,
                contentLength: response.content.length
            });

            // Criar a nova mensagem
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant youtube';
            messageDiv.setAttribute('data-message-id', response.message_id);
            messageDiv.setAttribute('data-conversation-id', response.conversation_id);
            messageDiv.innerHTML = `
                <div class="message-content">
                    ${DOMPurify.sanitize(marked.parse(response.content))}
                </div>
                <div class="message-actions">
                    <button class="action-btn copy-btn" onclick="window.copiarMensagem(this)" title="Copiar mensagem">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            `;
            chatContainer.appendChild(messageDiv);
            messageDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
            logger.debug('Resposta do YouTube renderizada com sucesso');
        } else if (response.status === 'error') {
            logger.error('Erro na resposta do YouTube', {
                error: response.error,
                messageId: response.message_id,
                conversationId: response.conversation_id
            });

            // Criar mensagem de erro
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message error';
            errorDiv.setAttribute('data-message-id', response.message_id);
            errorDiv.setAttribute('data-conversation-id', response.conversation_id);
            errorDiv.innerHTML = `
                <div class="message-content">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>${DOMPurify.sanitize(response.error)}</span>
                </div>
            `;
            chatContainer.appendChild(errorDiv);
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'end' });
            logger.debug('Mensagem de erro do YouTube renderizada');
        }
    });
    
    socket.on('youtube_error', (error) => {
        logger.error('Erro no processamento do YouTube', {
            error: error.message,
            stack: error.stack
        });
        
        // Remover todas as animações de carregamento
        const loadingDivs = document.querySelectorAll('.message.loading');
        loadingDivs.forEach(div => {
            logger.debug('Removendo div de carregamento', {
                messageId: div.dataset.messageId,
                conversationId: div.dataset.conversationId
            });
            div.remove();
        });
        
        // Exibir mensagem de erro
        const chatContainer = document.querySelector('.chat-container');
        if (chatContainer) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message error';
            errorDiv.innerHTML = `
                <div class="message-content">
                    <i class="fas fa-exclamation-circle"></i>
                    <span>Erro ao processar vídeo do YouTube: ${DOMPurify.sanitize(error.message)}</span>
                </div>
            `;
            chatContainer.appendChild(errorDiv);
            chatContainer.scrollTo({ top: chatContainer.scrollHeight, behavior: 'smooth' });
            logger.debug('Mensagem de erro renderizada no chat');
        }
        
        // Resetar estado
        isProcessingYoutube = false;
        const sendBtn = document.querySelector('#send-btn');
        if (sendBtn) {
            sendBtn.disabled = false;
            logger.debug('Botão de envio reabilitado após erro');
        }
    });
}

function processSubtitles(subtitles) {
    // Aqui você pode adicionar lógica adicional para processar as legendas
    // Por exemplo, formatar o texto, adicionar timestamps, etc.
    const formattedSubtitles = formatSubtitles(subtitles);
    displaySubtitles(formattedSubtitles);
}

function formatSubtitles(subtitles) {
    // Formatar as legendas para exibição
    return subtitles.split('\n').map(line => {
        // Adicionar formatação específica se necessário
        return line.trim();
    }).join('\n');
}

function displaySubtitles(formattedSubtitles) {
    const subtitlesContainer = document.getElementById('subtitles-container');
    subtitlesContainer.innerHTML = formattedSubtitles;
    subtitlesContainer.style.display = 'block';
}

==========================================
Conteúdo de youtubeResumoHandler.js (caminho: static\js\youtube-system\youtubeResumoHandler.js):
==========================================
// youtubeResumoHandler.js
import { logger } from '../utils/logger.js';
import { marked } from 'https://cdn.jsdelivr.net/npm/marked@5.1.1/lib/marked.esm.js';
import DOMPurify from 'https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.es.js';

let isProcessingYoutubeResumo = false;

export async function handleYoutubeResumoCommand(command, conversationId) {
    logger.info('Iniciando processamento de comando YouTube Resumo', {
        conversationId,
        isProcessing: isProcessingYoutubeResumo
    });

    if (isProcessingYoutubeResumo) {
        logger.warn('Processamento de resumo já em andamento, ignorando comando', {
            conversationId
        });
        return;
    }

    // Extrair a URL do vídeo do comando
    const videoUrl = command.split(' ')[1];
    if (!videoUrl) {
        logger.error('URL do vídeo não fornecida no comando de resumo');
        throw new Error('URL do vídeo não fornecida');
    }

    // Validar se a URL é do YouTube
    if (!videoUrl.includes('youtube.com') && !videoUrl.includes('youtu.be')) {
        logger.error('URL inválida fornecida para resumo', { url: videoUrl });
        throw new Error('URL inválida. Use um link do YouTube válido.');
    }

    logger.debug('Iniciando processamento de resumo', {
        url: videoUrl,
        conversationId,
        timestamp: new Date().toISOString()
    });
    
    try {
        isProcessingYoutubeResumo = true;
        const sendBtn = document.querySelector('#send-btn');
        if (sendBtn) {
            sendBtn.disabled = true;
            logger.debug('Botão de envio desabilitado para resumo');
        }

        // Exibir animação de carregamento centralizada
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation) {
            loadingAnimation.style.display = 'block';
            logger.debug('Animação de carregamento exibida para resumo');
        }

        logger.info('Enviando requisição para processar resumo', {
            url: videoUrl,
            conversationId,
            endpoint: '/process_youtube_resumo'
        });

        // Enviar requisição para processar o vídeo
        const response = await fetch('/process_youtube_resumo', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                conversation_id: conversationId,
                url: videoUrl
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            logger.error('Falha na resposta do servidor para resumo', {
                status: response.status,
                error: errorData.error
            });
            throw new Error(errorData.error || 'Erro ao processar resumo do vídeo');
        }

        const data = await response.json();
        logger.info('Processamento de resumo iniciado pelo backend', {
            status: data.status,
            conversationId,
            timestamp: new Date().toISOString()
        });
        
        // Entrar na sala da conversa para receber eventos
        if (window.socket) {
            window.socket.emit('join_conversation', { conversation_id: conversationId });
            logger.debug('Entrou na sala da conversa para eventos de resumo', {
                conversationId
            });
        } else {
            logger.error('Socket não inicializado para resumo');
        }
        
        return data;
    } catch (error) {
        logger.error('Erro no processamento do resumo', {
            error: error.message,
            stack: error.stack,
            conversationId,
            url: videoUrl
        });
        
        // Esconder animação em caso de erro
        const loadingAnimation = document.getElementById('loading-animation');
        if (loadingAnimation) {
            loadingAnimation.style.display = 'none';
            logger.debug('Animação de carregamento ocultada após erro no resumo');
        }
        
        throw error;
    } finally {
        setTimeout(() => {
            isProcessingYoutubeResumo = false;
            const sendBtn = document.querySelector('#send-btn');
            if (sendBtn) {
                sendBtn.disabled = false;
                logger.debug('Botão de envio reabilitado após resumo');
            }
        }, 2000);
    }
}

// O YouTube Resumo usa os eventos padrão message_chunk e response_complete
// Aqui adicionamos logs para diagnóstico de streaming
logger.info('Sistema de streaming padrão configurado para YouTube Resumo', {
    events: ['message_chunk', 'response_complete'],
    handledBy: 'streamingManager'
});

==========================================
Conteúdo de chat_storage.py (caminho: utils\chat_storage.py):
==========================================
"""
Módulo de Gerenciamento de Conversas

Este módulo fornece funções para gerenciar o armazenamento persistente de conversas
em formato JSON. Permite criar, ler, atualizar e excluir conversas e mensagens.

Principais funcionalidades:
- Criar novas conversas
- Adicionar mensagens a conversas existentes
- Recuperar histórico de conversas
- Atualizar metadados de conversas
- Excluir conversas
"""

import json
import os
import uuid
from datetime import datetime

# Definição de constantes para armazenamento de dados
DATA_DIR = "data"
CONVERSATIONS_DIR = os.path.join(DATA_DIR, "conversations")
INDEX_FILE = os.path.join(DATA_DIR, "index.json")

def ensure_directories():
    """
    Garante que os diretórios necessários para armazenamento existam.
    Cria os diretórios data/ e data/conversations/ caso não existam.
    """
    # print("[DEBUG-PYTHON] ensure_directories em utils/chat_storage.py chamada")
    os.makedirs(CONVERSATIONS_DIR, exist_ok=True)

def create_new_conversation():
    """
    Cria uma nova conversa com ID baseado no timestamp atual.
    
    Returns:
        str: ID único da conversa recém-criada
    """
    # print("[DEBUG-PYTHON] create_new_conversation em utils/chat_storage.py chamada")
    ensure_directories()
    
    conversation_id = str(int(datetime.now().timestamp() * 1000))
    conversation = {
        "id": conversation_id,
        "title": "Nova conversa",
        "timestamp": datetime.now().isoformat(),
        "messages": []
    }
    
    save_conversation(conversation)
    update_index(conversation)
    
    # print(f"[DEBUG-PYTHON] Nova conversa criada com ID: {conversation_id}")
    return conversation_id

def save_conversation(conversation):
    """
    Salva uma conversa em seu arquivo JSON correspondente.
    
    Args:
        conversation (dict): Objeto de conversa com campos id, title, timestamp e messages
        
    Returns:
        bool: True se a operação foi bem-sucedida, False caso contrário
    """
    # print(f"[DEBUG-PYTHON] save_conversation em utils/chat_storage.py chamada para conversa ID: {conversation['id']}")
    filename = f"conversation_{conversation['id']}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(conversation, f, ensure_ascii=False, indent=2)
        # print(f"[DEBUG-PYTHON] Conversa {conversation['id']} salva com sucesso")
        return True
    except Exception as e:
        print(f"[ERRO-PYTHON] Falha ao salvar conversa: {str(e)}")
        return False

def update_index(conversation):
    """
    Atualiza o arquivo de índice com os metadados da conversa.
    O índice contém informações resumidas de todas as conversas para
    carregar rapidamente a lista de conversas sem precisar abrir cada arquivo.
    
    Args:
        conversation (dict): Objeto de conversa a ser indexado
        
    Returns:
        bool: True se a operação foi bem-sucedida, False caso contrário
    """
    # print(f"[DEBUG-PYTHON] update_index em utils/chat_storage.py chamada para conversa ID: {conversation['id']}")
    ensure_directories()
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG-PYTHON] Arquivo de índice não encontrado ou inválido, criando novo")
        index = []
    
    entry = {
        "id": conversation["id"],
        "title": conversation.get("title", "Nova conversa"),
        "timestamp": conversation["timestamp"],
        "filename": f"conversation_{conversation['id']}.json"
    }
    
    # Remover entrada antiga se existir
    index = [item for item in index if item["id"] != conversation["id"]]
    index.append(entry)
    index.sort(key=lambda x: x["timestamp"], reverse=True)
    
    try:
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        # print(f"[DEBUG-PYTHON] Índice atualizado com sucesso para conversa {conversation['id']}")
        return True
    except Exception as e:
        print(f"[ERRO-PYTHON] Falha ao atualizar índice: {str(e)}")
        return False

def get_conversation_by_id(conversation_id):
    """
    Recupera uma conversa específica pelo ID.
    
    Args:
        conversation_id (str): ID da conversa a ser recuperada
        
    Returns:
        dict: Objeto de conversa completo ou None se não encontrada
    """
    # print(f"[DEBUG-PYTHON] get_conversation_by_id em utils/chat_storage.py chamada para ID: {conversation_id}")
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            conversa = json.load(f)
            # print(f"[DEBUG-PYTHON] Conversa {conversation_id} carregada com sucesso")
            return conversa
    except FileNotFoundError:
        # print(f"[DEBUG-PYTHON] Conversa {conversation_id} não encontrada")
        return None
    except json.JSONDecodeError:
        print(f"[ERRO-PYTHON] Arquivo de conversa corrompido: {conversation_id}")
        return None
    except Exception as e:
        print(f"[ERRO-PYTHON] Erro ao carregar conversa: {str(e)}")
        return None

def get_conversation_history():
    """
    Recupera o histórico de todas as conversas a partir do arquivo de índice.
    Verifica se os arquivos correspondentes ainda existem.
    
    Returns:
        list: Lista de metadados de todas as conversas válidas
    """
    # print("[DEBUG-PYTHON] get_conversation_history em utils/chat_storage.py chamada")
    ensure_directories()
    
    try:
        with open(INDEX_FILE, 'r', encoding='utf-8') as f:
            index = json.load(f)
            
        # Verificar se todos os arquivos ainda existem
        valid_entries = []
        for entry in index:
            filepath = os.path.join(CONVERSATIONS_DIR, entry.get("filename", ""))
            if os.path.exists(filepath):
                valid_entries.append(entry)
            else:
                # print(f"[DEBUG-PYTHON] Arquivo não encontrado para conversa {entry.get('id')}: {filepath}")
                pass
        
        # print(f"[DEBUG-PYTHON] Histórico de conversas carregado: {len(valid_entries)} conversas válidas")
        return valid_entries
    except (FileNotFoundError, json.JSONDecodeError):
        # print("[DEBUG-PYTHON] Arquivo de índice não encontrado ou inválido")
        return []
    except Exception as e:
        print(f"[ERRO-PYTHON] Erro ao carregar histórico: {str(e)}")
        return []

def add_message_to_conversation(conversation_id, content, role, message_id=None):
    """
    Adiciona uma mensagem a uma conversa existente.
    Se a conversa não existir, cria uma nova.
    
    Args:
        conversation_id (str): ID da conversa
        content (str): Conteúdo da mensagem
        role (str): Papel do autor da mensagem ('user' ou 'assistant')
        message_id (str, optional): ID único da mensagem. Se não fornecido, gera um novo.
        
    Returns:
        str: ID único da mensagem adicionada
    """
    # print(f"[DEBUG-PYTHON] add_message_to_conversation em utils/chat_storage.py chamada para conversa {conversation_id}, role: {role}")
    
    conversation = get_conversation_by_id(conversation_id)
    
    if not conversation:
        # print(f"[DEBUG-PYTHON] Criando nova conversa para ID: {conversation_id}")
        conversation = {
            "id": conversation_id,
            "title": "Nova conversa",
            "timestamp": datetime.now().isoformat(),
            "messages": []
        }
    
    # Usar o message_id fornecido ou gerar um novo
    if message_id is None:
        message_id = str(uuid.uuid4())  # Gera um ID único no formato de string
    
    message = {
        "message_id": message_id,
        "role": role,
        "content": content,
        "timestamp": datetime.now().isoformat()
    }
    
    conversation["messages"].append(message)
    conversation["timestamp"] = datetime.now().isoformat()
    
    # Definir título automaticamente com base na primeira mensagem do usuário
    if role == "user" and len([m for m in conversation["messages"] if m["role"] == "user"]) == 1:
        conversation["title"] = content[:30] + "..." if len(content) > 30 else content
        # print(f"[DEBUG-PYTHON] Título da conversa atualizado para: {conversation['title']}")
    
    save_conversation(conversation)
    update_index(conversation)
    # print(f"[DEBUG-PYTHON] Mensagem {message_id} adicionada com sucesso à conversa {conversation_id}")
    
    return message_id  # Retorna o ID da mensagem para uso posterior

def update_message_in_conversation(conversation_id, message_id, new_content):
    """
    Atualiza o conteúdo de uma mensagem existente em uma conversa.
    
    Args:
        conversation_id (str): ID da conversa
        message_id (str): ID da mensagem a ser atualizada
        new_content (str): Novo conteúdo da mensagem
        
    Returns:
        bool: True se a mensagem foi atualizada com sucesso, False caso contrário
    """
    # print(f"[DEBUG-PYTHON] update_message_in_conversation chamada para mensagem {message_id} na conversa {conversation_id}")
    
    conversation = get_conversation_by_id(conversation_id)
    
    if not conversation:
        print(f"[ERRO-PYTHON] Conversa não encontrada: {conversation_id}")
        return False
    
    # Procura a mensagem pelo ID
    for message in conversation["messages"]:
        if message.get("message_id") == message_id:
            # Atualiza o conteúdo da mensagem
            message["content"] = new_content
            message["updated_at"] = datetime.now().isoformat()
            
            # Salva a conversa atualizada
            save_conversation(conversation)
            # print(f"[DEBUG-PYTHON] Mensagem {message_id} atualizada com sucesso")
            return True
    
    print(f"[ERRO-PYTHON] Mensagem {message_id} não encontrada na conversa {conversation_id}")
    return False

def delete_conversation(conversation_id):
    """
    Exclui uma conversa e sua entrada no índice.
    
    Args:
        conversation_id (str): ID da conversa a ser excluída
        
    Returns:
        bool: True se a conversa foi excluída com sucesso, False caso contrário
    """
    filename = f"conversation_{conversation_id}.json"
    filepath = os.path.join(CONVERSATIONS_DIR, filename)
    
    try:
        # Remove o arquivo da conversa se existir
        if os.path.exists(filepath):
            os.remove(filepath)
            
        # Remove a entrada do índice
        try:
            with open(INDEX_FILE, 'r', encoding='utf-8') as f:
                index = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            index = []
            
        # Filtra a conversa do índice
        index = [item for item in index if item["id"] != conversation_id]
        
        # Salva o índice atualizado
        with open(INDEX_FILE, 'w', encoding='utf-8') as f:
            json.dump(index, f, ensure_ascii=False, indent=2)
        
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao excluir conversa: {str(e)}")
        return False

def rename_conversation(conversation_id, new_title):
    """
    Renomeia uma conversa existente.
    
    Args:
        conversation_id (str): ID da conversa a ser renomeada
        new_title (str): Novo título para a conversa
        
    Returns:
        bool: True se a conversa foi renomeada com sucesso, False caso contrário
    """
    conversation = get_conversation_by_id(conversation_id)
    if not conversation:
        print(f"[ERRO] Conversa {conversation_id} não existe")
        return False
        
    try:
        # Atualiza o título com validação
        new_title = new_title.strip()
        if not new_title or len(new_title) > 100:
            print("[ERRO] Título inválido ou muito longo")
            return False
            
        conversation["title"] = new_title
        conversation["timestamp"] = datetime.now().isoformat() # Atualiza timestamp
        
        # Salva as alterações
        save_success = save_conversation(conversation)
        if not save_success:
            print("[ERRO] Falha ao salvar conversa")
            return False
            
        index_success = update_index(conversation)
        if not index_success:
            print("[ERRO] Falha ao atualizar índice")
            return False
        
        return True
    except Exception as e:
        print(f"[ERRO] Falha ao renomear conversa: {str(e)}")
        return False


==========================================
Conteúdo de youtube_handler.py (caminho: youtube_handler.py):
==========================================
"""
Manipulador de Vídeos do YouTube

Este módulo fornece funcionalidades para trabalhar com vídeos do YouTube,
especialmente para baixar e processar legendas/transcrições.

A classe YoutubeHandler oferece métodos para:
- Baixar legendas de vídeos do YouTube (PT-BR, PT e EN)
- Limpar e formatar o texto das legendas
- Dividir transcrições em blocos para processamento
"""

import os
import json
import yt_dlp
import re
import logging
import traceback
from typing import Optional, Dict, Any, Tuple

# Configuração do logger
logger = logging.getLogger('youtube_handler')

class YoutubeHandler:
    """
    Classe para manipular vídeos do YouTube, com foco em download e processamento de legendas.
    Oferece suporte para baixar legendas em português e inglês, limpá-las e dividi-las em blocos.
    """
    
    def __init__(self, download_path: str = "./temp"):
        """
        Inicializa o manipulador de vídeos do YouTube.
        
        Args:
            download_path (str): Caminho para salvar arquivos temporários
        """
        logger.info("Iniciando YoutubeHandler")
        self.download_path = download_path
        if not os.path.exists(download_path):
            os.makedirs(download_path)
            logger.debug(f"Diretório criado: {download_path}")

    def download_subtitles(self, video_url: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Baixa legendas do vídeo em PT-BR, PT ou EN, com fallback para legendas automáticas.
        
        Args:
            video_url (str): URL do vídeo do YouTube
            
        Returns:
            Tuple[Optional[str], Optional[str]]: (caminho_do_arquivo, título_do_vídeo)
                Se não for possível baixar, o primeiro elemento será None
        """
        logger.info(f"Iniciando download de legendas para: {video_url}")
        
        # Configuração para baixar legendas apenas em PT-BR, PT e EN
        ydl_opts = {
            'writesubtitles': True,          # Baixa legendas manuais
            'writeautomaticsub': True,       # Baixa legendas automáticas como fallback
            'subtitleslangs': ['pt-BR', 'pt', 'en'],  # Limita a PT-BR, PT e EN
            'skip_download': True,           # Não baixa o vídeo
            'outtmpl': os.path.join(self.download_path, '%(id)s.%(ext)s'),
            'quiet': False,                  # Logs detalhados para diagnóstico
        }

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                logger.debug("Extraindo informações do vídeo...")
                info = ydl.extract_info(video_url, download=True)
                
                if not info:
                    logger.error("Não foi possível extrair informações do vídeo")
                    return None, None
                
                video_id = info.get('id')
                video_title = info.get('title', 'Sem título')
                logger.info(f"Vídeo encontrado - ID: {video_id}, Título: {video_title}")

                # Lista de sufixos para legendas manuais e automáticas, na ordem de prioridade
                lang_options = [
                    # PT-BR (manuais e automáticas)
                    [f"{video_id}.pt-BR.vtt", f"{video_id}.pt_BR.vtt", f"{video_id}.pt-br.vtt",
                     f"{video_id}.pt-BR.auto.vtt", f"{video_id}.pt_BR.auto.vtt"],
                    # PT (manuais e automáticas)
                    [f"{video_id}.pt.vtt", f"{video_id}.pt-PT.vtt", f"{video_id}.pt.auto.vtt"],
                    # EN (manuais e automáticas)
                    [f"{video_id}.en.vtt", f"{video_id}.en.auto.vtt"]
                ]

                # Busca por legendas na ordem de prioridade
                for lang_group in lang_options:
                    for file_name in lang_group:
                        subtitle_file = os.path.join(self.download_path, file_name)
                        if os.path.exists(subtitle_file):
                            logger.info(f"Legenda encontrada: {file_name}")
                            return subtitle_file, video_title

                logger.warning(f"Nenhuma legenda encontrada para {video_id} em PT-BR, PT ou EN")
                return None, video_title

        except yt_dlp.utils.DownloadError as e:
            if '429' in str(e):
                logger.error("Limite de requisições excedido (429). Tente novamente mais tarde.")
            else:
                logger.error(f"Erro no download: {str(e)}")
            return None, None
        except Exception as e:
            logger.error(f"Falha ao baixar legendas: {str(e)}")
            logger.error(traceback.format_exc())
            return None, None

    def clean_subtitles(self, subtitle_file: str) -> Optional[str]:
        """
        Limpa as legendas removendo timestamps, formatação e repetições.
        
        Args:
            subtitle_file (str): Caminho do arquivo de legendas
            
        Returns:
            Optional[str]: Texto limpo das legendas ou None se ocorrer erro
        """
        logger.debug(f"Iniciando limpeza de legendas: {subtitle_file}")
        
        if not isinstance(subtitle_file, str):
            logger.error(f"subtitle_file não é uma string, é {type(subtitle_file)}")
            return None
            
        if not os.path.exists(subtitle_file):
            logger.error(f"Arquivo não existe: {subtitle_file}")
            return None

        try:
            # Tenta diferentes codificações
            content = None
            for encoding in ['utf-8', 'latin1', 'cp1252']:
                try:
                    with open(subtitle_file, 'r', encoding=encoding) as f:
                        content = f.read()
                        logger.debug(f"Arquivo lido com sucesso usando encoding: {encoding}")
                        break
                except UnicodeDecodeError:
                    logger.debug(f"Falha ao ler com encoding: {encoding}")
                    continue
            
            if content is None:
                raise Exception("Não foi possível ler o arquivo com nenhuma codificação suportada")

            logger.debug("Iniciando processo de limpeza do texto...")
            
            # Remove cabeçalho WEBVTT e metadados
            content = re.sub(r'WEBVTT.*\n', '', content)
            content = re.sub(r'Kind:.*\n', '', content)
            content = re.sub(r'Language:.*\n', '', content)
            
            # Remove timestamps e números de sequência
            content = re.sub(r'\d{2}:\d{2}:\d{2}[\.,]\d{3} --> .*\n', '', content)
            content = re.sub(r'^\d+$', '', content, flags=re.MULTILINE)
            
            # Remove tags HTML e formatação
            content = re.sub(r'<[^>]+>', '', content)
            content = re.sub(r'{\\an\d}', '', content)
            content = re.sub(r'\[.*?\]', '', content)
            
            # Processa linha por linha removendo duplicatas
            seen_lines = set()
            cleaned_lines = []
            
            for line in content.split('\n'):
                line = line.strip()
                if line and not line.startswith(('<', '{', '[')) and line not in seen_lines:
                    cleaned_lines.append(line)
                    seen_lines.add(line)

            # Remove arquivo temporário
            try:
                os.remove(subtitle_file)
                logger.debug(f"Arquivo temporário removido: {subtitle_file}")
            except Exception as e:
                logger.warning(f"Não foi possível remover o arquivo temporário: {str(e)}")
            
            # Junta as linhas com espaço e remove espaços extras
            result = ' '.join(cleaned_lines).strip()
            logger.info(f"Texto limpo gerado com sucesso: {len(result)} caracteres")
            logger.debug(f"Amostra do texto limpo: {result[:100]}...")
            return result
            
        except Exception as e:
            logger.error(f"Erro ao limpar legendas: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def download_and_clean_transcript(self, video_url: str) -> Tuple[Optional[str], Optional[str]]:
        """
        Combinação das funções download_subtitles e clean_subtitles em um único método.
        
        Args:
            video_url (str): URL do vídeo do YouTube
            
        Returns:
            Tuple[Optional[str], Optional[str]]: (transcrição_limpa, título_do_vídeo)
        """
        logger.info(f"Iniciando download e limpeza de transcrição para: {video_url}")
        
        subtitle_file, video_title = self.download_subtitles(video_url)
        if subtitle_file:
            logger.debug(f"Legendas baixadas com sucesso, iniciando limpeza: {video_title}")
            cleaned_transcript = self.clean_subtitles(subtitle_file)
            if cleaned_transcript:
                logger.info(f"Transcrição processada com sucesso para: {video_title}")
                return cleaned_transcript, video_title
            else:
                logger.error(f"Falha ao limpar legendas para: {video_title}")
        else:
            logger.error(f"Falha ao baixar legendas para: {video_url}")
        
        return None, video_title
        
    def split_transcript_into_chunks(self, transcript: str, words_per_chunk: int = 300) -> list[str]:
        """
        Divide a transcrição em blocos de aproximadamente N palavras.
        
        Args:
            transcript (str): Texto da transcrição limpa
            words_per_chunk (int): Número aproximado de palavras por bloco
            
        Returns:
            list[str]: Lista de blocos de texto
        """
        if not transcript:
            logger.error("Transcrição vazia, não é possível dividir em blocos")
            return []
            
        try:
            # Divide o texto em palavras
            words = transcript.split()
            total_words = len(words)
            logger.debug(f"Total de palavras na transcrição: {total_words}")
            
            # Calcula quantos blocos serão necessários
            num_chunks = max(1, (total_words + words_per_chunk - 1) // words_per_chunk)
            logger.debug(f"Dividindo em aproximadamente {num_chunks} blocos")
            
            chunks = []
            for i in range(0, total_words, words_per_chunk):
                chunk = ' '.join(words[i:i + words_per_chunk])
                chunks.append(chunk)
                
            logger.info(f"Transcrição dividida em {len(chunks)} blocos de aproximadamente {words_per_chunk} palavras")
            return chunks
            
        except Exception as e:
            logger.error(f"Erro ao dividir transcrição em blocos: {str(e)}")
            logger.error(traceback.format_exc())
            return []



==========================================
Estrutura de pastas (relativa à Entrada):
==========================================
├── persistencia-memoria-html
├── app.py
├── cleanup_ports.py
├── DOCUMENTACAO.md
├── iniciar_servidor.bat
├── init_eventlet.py
├── linha_de_raciocinio
│   ├── 1- documentação.md
│   ├── 2- DFD com foco no youtube- 2025-04-02.png
│   ├── 2- DFD com foco no youtube.md
│   ├── 3-implementacao-streaming-mensagens.md
│   ├── 4-resolucao-problemas-duplicacao-mensagens.md
│   ├── 5-problemas-interacao-eventos.md
│   ├── animacao-carregamento.md
│   ├── arvore-funcoes.md
│   ├── documentacao-sistema.md
│   ├── documentacao_atualizada.md
│   ├── implementacao-streaming-continuo-resumo.md
│   ├── leia-me.md
│   ├── linha_de_raciocinio_atualizada.md
│   ├── Plano-implementacao.md
│   ├── plano_atual_12.05.2025.txt
│   ├── README.md
│   └── resolucao-problemas-limpeza-mensagens.md
├── README.md
├── static
│   ├── css
│   │   ├── base
│   │   │   ├── reset.css
│   │   │   ├── typography.css
│   │   │   └── variables.css
│   │   ├── components
│   │   │   ├── buttons.css
│   │   │   ├── code-highlight.css
│   │   │   ├── command-menu.css
│   │   │   ├── forms.css
│   │   │   └── messages.css
│   │   ├── layout
│   │   │   ├── container.css
│   │   │   ├── main-content.css
│   │   │   └── sidebar.css
│   │   ├── messages.css
│   │   ├── streaming.css
│   │   ├── style.css
│   │   ├── styles.css
│   │   ├── themes
│   │   │   ├── dark-theme.css
│   │   │   └── light-theme.css
│   │   └── variables.css
│   └── js
│       ├── backup
│       │   ├── chatUI.js
│       │   └── messageRegistry.js
│       ├── chat
│       │   ├── chatActions.js
│       │   ├── chatStorage.js
│       │   ├── chatSync.js
│       │   ├── chatUI.js
│       │   └── chatUtils.js
│       ├── chat.js
│       ├── commandMenu.js
│       ├── events.js
│       ├── init.js
│       ├── main.js
│       ├── messageRenderer.js
│       ├── modules
│       │   ├── commandHandler.js
│       │   ├── inputBar.js
│       │   ├── messageRegistry.js
│       │   └── streamingManager.js
│       ├── sidebar.js
│       ├── textarea.js
│       ├── theme.js
│       ├── utils
│       │   └── logger.js
│       ├── utils.js
│       └── youtube-system
│           ├── youtubeEvents.js
│           ├── youtubeHandler.js
│           └── youtubeResumoHandler.js
├── utils
│   └── chat_storage.py
└── youtube_handler.py
