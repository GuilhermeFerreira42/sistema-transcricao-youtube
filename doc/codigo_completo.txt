==========================================
Conteúdo de app.py (caminho: backend\app.py):
==========================================
# backend/app.py
from flask import Flask, request, jsonify, send_file, render_template
import os
import logging
import json
from youtube_handler import YouTubeHandler

# Configuração do logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('app')

app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')

# Inicializar o handler do YouTube
youtube_handler = YouTubeHandler()

@app.route('/')
def index():
    """Renderiza a página principal"""
    return render_template('index.html')

@app.route('/process_youtube_video', methods=['POST'])
def process_youtube_video():
    """
    Rota para processar um vídeo do YouTube
    Espera um JSON com {"url": "URL_DO_VIDEO"}
    """
    data = request.get_json()
    
    if not data or 'url' not in data:
        logger.error("Requisição inválida: URL não fornecida")
        return jsonify({
            "success": False,
            "error": "URL do vídeo não fornecida"
        }), 400
    
    url = data['url']
    logger.info(f"Processando vídeo do YouTube: {url}")
    
    try:
        # Processar o vídeo
        transcript, metadata, json_path = youtube_handler.download_and_clean_transcript(url)
        
        if not transcript:
            error_msg = f"Não foi possível processar as legendas do vídeo '{metadata.get('title', 'desconhecido')}'"
            logger.error(error_msg)
            return jsonify({
                "success": False,
                "error": error_msg
            }), 400
        
        # Preparar resposta
        response = {
            "success": True,
            "video_id": metadata['video_id'],
            "title": metadata['title'],
            "thumbnail": metadata['thumbnail'],
            "transcript": transcript,
            "chunks": youtube_handler.split_transcript_into_chunks(transcript),
            "metadata": metadata
        }
        
        return jsonify(response)
    
    except Exception as e:
        logger.exception(f"Erro ao processar vídeo {url}: {str(e)}")
        return jsonify({
            "success": False,
            "error": f"Erro interno ao processar o vídeo: {str(e)}"
        }), 500

@app.route('/download_transcription/<video_id>', methods=['GET'])
def download_transcription(video_id):
    """
    Rota para baixar a transcrição em TXT
    """
    # Garantir que o diretório de transcrições exista
    transcriptions_dir = youtube_handler.output_dir
    os.makedirs(transcriptions_dir, exist_ok=True)
    
    # Encontrar o arquivo JSON mais recente com este video_id
    matching_files = []
    
    for filename in os.listdir(transcriptions_dir):
        if filename.startswith(video_id) and filename.endswith('.json'):
            filepath = os.path.join(transcriptions_dir, filename)
            matching_files.append((filepath, os.path.getctime(filepath)))
    
    if not matching_files:
        logger.error(f"Nenhuma transcrição encontrada para o vídeo {video_id}")
        return jsonify({
            "success": False,
            "error": "Transcrição não encontrada"
        }), 404
    
    # Pegar o arquivo mais recente
    latest_file = max(matching_files, key=lambda x: x[1])[0]
    
    try:
        # Carregar o arquivo JSON
        with open(latest_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Criar conteúdo TXT
        txt_content = f"Transcrição do vídeo: {data['title']}\n"
        txt_content += f"ID do vídeo: {data['video_id']}\n"
        txt_content += f"Gerado em: {data['created_at']}\n\n"
        txt_content += "===== CONTEÚDO DO VÍDEO =====\n\n"
        txt_content += data['transcript']
        
        # Sanitizar o título para o nome do arquivo
        safe_title = youtube_handler.sanitize_filename(data['title'])
        txt_filename = f"{safe_title[:50]}_transcricao.txt"
        
        # Criar um objeto BytesIO para evitar criar arquivo temporário no disco
        from io import BytesIO
        temp_txt = BytesIO()
        temp_txt.write(txt_content.encode('utf-8'))
        temp_txt.seek(0)
        
        # Enviar o arquivo para download diretamente da memória
        return send_file(
            temp_txt,
            mimetype='text/plain',
            as_attachment=True,
            download_name=txt_filename
        )
    
    except Exception as e:
        logger.exception(f"Erro ao gerar arquivo TXT para {video_id}: {str(e)}")
        return jsonify({
            "success": False,
            "error": f"Erro ao gerar arquivo de transcrição: {str(e)}"
        }), 500

@app.route('/get_transcription/<video_id>', methods=['GET'])
def get_transcription(video_id):
    """
    Rota para obter a transcrição completa em JSON
    """
    # Encontrar o arquivo JSON mais recente com este video_id
    transcriptions_dir = youtube_handler.output_dir
    matching_files = []
    
    for filename in os.listdir(transcriptions_dir):
        if filename.startswith(video_id) and filename.endswith('.json'):
            filepath = os.path.join(transcriptions_dir, filename)
            matching_files.append((filepath, os.path.getctime(filepath)))
    
    if not matching_files:
        logger.error(f"Nenhuma transcrição encontrada para o vídeo {video_id}")
        return jsonify({
            "success": False,
            "error": "Transcrição não encontrada"
        }), 404
    
    # Pegar o arquivo mais recente
    latest_file = max(matching_files, key=lambda x: x[1])[0]
    
    try:
        # Enviar o arquivo JSON
        return send_file(latest_file, mimetype='application/json')
    except Exception as e:
        logger.exception(f"Erro ao enviar transcrição para {video_id}: {str(e)}")
        return jsonify({
            "success": False,
            "error": f"Erro ao enviar transcrição: {str(e)}"
        }), 500

if __name__ == '__main__':
    # Certifique-se de que o diretório de transcrições existe
    os.makedirs('data/transcriptions', exist_ok=True)
    
    logger.info("Iniciando servidor na porta 5000...")
    app.run(debug=True, port=5000)

==========================================
Conteúdo de utils.py (caminho: backend\utils.py):
==========================================
# backend/utils.py
import re
import os
import uuid
import logging

logger = logging.getLogger('utils')

def sanitize_filename(filename):
    """
    Sanitiza o nome do arquivo para evitar caracteres inválidos
    
    Args:
        filename (str): Nome do arquivo original
        
    Returns:
        str: Nome do arquivo sanitizado
    """
    # Remover caracteres inválidos para nomes de arquivo
    sanitized = re.sub(r'[\\/*?:"<>|]', "", filename)
    # Substituir espaços por underscores
    sanitized = re.sub(r'\s+', '_', sanitized)
    # Limitar o tamanho do nome do arquivo
    return sanitized[:200]

def generate_unique_id():
    """
    Gera um ID único usando UUID
    
    Returns:
        str: ID único
    """
    return str(uuid.uuid4())

def validate_youtube_url(url):
    """
    Valida se a URL fornecida é um link válido do YouTube
    
    Args:
        url (str): URL a ser validada
        
    Returns:
        bool: True se for uma URL válida do YouTube, False caso contrário
    """
    youtube_regex = (
        r'(https?://)?(www\.)?'
        '(youtube|youtu|youtube-nocookie)\.(com|be)/'
        '(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})'
    )
    
    return bool(re.match(youtube_regex, url))

def extract_video_id(url):
    """
    Extrai o ID do vídeo da URL do YouTube
    
    Args:
        url (str): URL do vídeo do YouTube
        
    Returns:
        Optional[str]: ID do vídeo se encontrado, None caso contrário
    """
    patterns = [
        r'(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=))([^"&?\/\s]{11})',
        r'(?:youtu\.be\/|v\/|vi\/|u\/\w\/|embed\/)([^"&?\/\s]{11})'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            return match.group(1)
    return None

==========================================
Conteúdo de youtube_handler.py (caminho: backend\youtube_handler.py):
==========================================
# backend/youtube_handler.py
import os
import re
import json
import yt_dlp
import uuid
import logging
import requests
import time
import random
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any

# ==============================================================================
# NOVA IMPORTAÇÃO: Adicionamos a biblioteca especializada em transcrições
# ==============================================================================
from youtube_transcript_api import YouTubeTranscriptApi


# Configuração do logger
logger = logging.getLogger('youtube_handler')
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

class YouTubeHandler:
    """Classe responsável por todas as operações relacionadas ao YouTube."""
    
    def __init__(self, output_dir="data/transcriptions"):
        """
        Inicializa o handler com diretório de saída para armazenar transcrições
        """
        self.output_dir = os.path.normpath(output_dir)
        os.makedirs(self.output_dir, exist_ok=True)
        logger.info(f"Diretório de transcrições configurado: {self.output_dir}")
        self.headers = self._get_realistic_headers()
    
    def _get_realistic_headers(self) -> Dict[str, str]:
        """Gera headers HTTP que imitam um navegador real para evitar bloqueios"""
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0'
        ]
        user_agent = random.choice(user_agents)
        headers = {
            'User-Agent': user_agent,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        }
        return headers

    def _add_random_delay(self):
        """Adiciona um delay aleatório entre requisições para evitar detecção como bot"""
        delay = random.uniform(1.0, 3.0)
        logger.debug(f"Aguardando {delay:.2f} segundos antes da próxima requisição")
        time.sleep(delay)

    def _is_google_block(self, content: str) -> bool:
        """Verifica se o conteúdo indica que o Google bloqueou a requisição"""
        block_indicators = [
            "unusual traffic from your computer network",
            "Our systems have detected unusual traffic from your computer network"
        ]
        content_lower = content.lower()
        return any(indicator.lower() in content_lower for indicator in block_indicators)

    def validate_youtube_url(self, url: str) -> bool:
        """Valida se a URL fornecida é um link válido do YouTube"""
        youtube_regex = (
            r'(https?://)?(www\.)?'
            '(youtube|youtu|youtube-nocookie)\.(com|be)/'
            '(watch\?v=|embed/|v/|.+\?v=)?([^&=%\?]{11})'
        )
        return bool(re.match(youtube_regex, url))

    def extract_video_id(self, url: str) -> Optional[str]:
        """Extrai o ID do vídeo da URL do YouTube"""
        patterns = [
            r'(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=))([^"&?\/\s]{11})',
            r'(?:youtu\.be\/|v\/|vi\/|u\/\w\/|embed\/)([^"&?\/\s]{11})'
        ]
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        return None

    def _get_video_metadata(self, url: str, video_id: str) -> Dict:
        """Obtém apenas os metadados do vídeo usando yt-dlp."""
        logger.info(f"Buscando metadados para o vídeo: {video_id}")
        try:
            ydl_opts = {
                'skip_download': True,
                'quiet': True,
                'no_warnings': True,
                'force_generic_extractor': False
            }
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                metadata = {
                    'video_id': video_id,
                    'title': info.get('title', 'Vídeo sem título'),
                    'thumbnail': info.get('thumbnail', ''),
                    'duration': info.get('duration', 0),
                    'view_count': info.get('view_count', 0),
                    'uploader': info.get('uploader', ''),
                    'upload_date': info.get('upload_date', '')
                }
                return metadata
        except Exception as e:
            logger.error(f"Não foi possível obter metadados com yt-dlp para {video_id}: {e}")
            return {
                'video_id': video_id,
                'title': 'Título indisponível',
                'thumbnail': '',
                'duration': 0,
                'view_count': 0,
                'uploader': '',
                'upload_date': ''
            }

    def download_subtitles_fallback(self, url: str, video_id: str) -> Tuple[Optional[str], Dict]:
        """Tenta baixar legendas usando yt-dlp (MÉTODO FALLBACK)."""
        logger.info(f"Método fallback (yt-dlp) iniciado para o vídeo: {video_id}")
        
        ydl_opts = {
            'skip_download': True,
            'writesubtitles': True,
            'writeautomaticsub': True,
            'subtitleslangs': ["pt", "pt-BR", "en"],
            'subformat': 'srt',
            'quiet': True,
            'no_warnings': True,
            'http_headers': self.headers,
            'retries': 3,
            'fragment_retries': 10,
            'sleep_interval': 2,
            'max_sleep_interval': 5,
            'verbose': False
        }

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                metadata = {
                    'video_id': video_id,
                    'title': info.get('title', 'Vídeo sem título'),
                    'thumbnail': info.get('thumbnail', ''),
                    'duration': info.get('duration', 0),
                    'view_count': info.get('view_count', 0),
                    'uploader': info.get('uploader', ''),
                    'upload_date': info.get('upload_date', '')
                }

                for lang in ["pt", "pt-BR", "en"]:
                    sub_info = info.get('subtitles', {}).get(lang)
                    if not sub_info:
                        sub_info = info.get('automatic_captions', {}).get(lang)
                    
                    if sub_info:
                        for sub_format in sub_info:
                            if 'url' in sub_format:
                                self._add_random_delay()
                                response = requests.get(sub_format['url'], headers=self.headers, timeout=10)
                                if not self._is_google_block(response.text) and response.text.strip():
                                    logger.info(f"Legendas baixadas com sucesso via fallback para o idioma {lang}")
                                    return response.text, metadata
                
                logger.warning(f"Fallback yt-dlp não encontrou legendas para {video_id}")
                return None, metadata
        except Exception as e:
            logger.error(f"Erro crítico no fallback yt-dlp para {url}: {e}")
            return None, {}

    def clean_subtitles(self, raw_subtitles: str) -> str:
        """Limpa e formata o texto das legendas, tratando tanto JSON quanto VTT/SRT."""
        if self._is_google_block(raw_subtitles):
            logger.error("Conteúdo bloqueado pelo Google detectado.")
            return "Erro: O Google bloqueou a requisição."
        
        try:
            data = json.loads(raw_subtitles)
            if 'events' in data:
                transcript_parts = []
                for event in data['events']:
                    if 'segs' in event:
                        for seg in event['segs']:
                            if 'utf8' in seg:
                                transcript_parts.append(seg['utf8'])
                
                full_transcript = "".join(transcript_parts).replace('\n', ' ').strip()
                cleaned = re.sub(r'\s{2,}', ' ', full_transcript)
                logger.info("Transcrição limpa a partir do formato JSON.")
                return cleaned
        except (json.JSONDecodeError, TypeError):
            logger.info("Formato não é JSON, limpando como VTT/SRT.")
            pass

        cleaned = re.sub(r'WEBVTT.*\n', '', raw_subtitles)
        cleaned = re.sub(r'\d{2}:\d{2}:\d{2}[,.]\d{3} --> \d{2}:\d{2}:\d{2}[,.]\d{3}.*\n', '', cleaned)
        cleaned = re.sub(r'<\d{2}:\d{2}:\d{2}[,.]\d{3}>', '', cleaned)
        cleaned = re.sub(r'<c[^>]*>', '', cleaned)
        cleaned = re.sub(r'</c>', '', cleaned)
        cleaned = re.sub(r'<[^>]+>', '', cleaned)
        
        cleaned = re.sub(r'\[.*?\]', '', cleaned)
        cleaned = re.sub(r'\n\s*\n', '\n\n', cleaned)
        cleaned = re.sub(r'\s{2,}', ' ', cleaned)
        return cleaned.strip()

    def split_transcript_into_chunks(self, transcript: str, words_per_chunk: int = 300) -> List[str]:
        """Divide a transcrição em blocos menores."""
        words = transcript.split()
        chunks = []
        for i in range(0, len(words), words_per_chunk):
            chunk = ' '.join(words[i:i + words_per_chunk])
            chunks.append(chunk)
        return chunks

    def sanitize_filename(self, filename: str) -> str:
        """Sanitiza o nome do arquivo para evitar caracteres inválidos."""
        sanitized = re.sub(r'[\\/*?:"<>|]', "", filename)
        sanitized = re.sub(r'\s+', '_', sanitized)
        return sanitized[:200]

    def save_transcription_to_json(self, video_id: str, title: str, transcript: str, 
                                 chunks: List[str], metadata: Dict) -> str:
        """Salva a transcrição em um arquivo JSON."""
        transcription_id = str(uuid.uuid4())
        data = {
            "transcription_id": transcription_id,
            "video_id": video_id,
            "title": title,
            "transcript": transcript,
            "chunks": chunks,
            "metadata": metadata,
            "created_at": datetime.now().isoformat(),
            "format_version": "2.0"
        }
        safe_title = self.sanitize_filename(title)
        filename = f"{video_id}_{safe_title[:50]}_{transcription_id[:8]}.json"
        filepath = os.path.join(self.output_dir, filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"Transcrição salva em: {filepath}")
        return filepath

    def download_and_clean_transcript(self, url: str) -> Tuple[Optional[str], Dict, Optional[str]]:
        """Função principal que coordena o download e limpeza da transcrição."""
        if not self.validate_youtube_url(url):
            logger.error(f"URL inválida: {url}")
            return None, {}, None

        video_id = self.extract_video_id(url)
        if not video_id:
            logger.error(f"ID do vídeo não encontrado na URL: {url}")
            return None, {}, None
            
        logger.info(f"Iniciando processamento do vídeo: {url}")

        metadata = self._get_video_metadata(url, video_id)
        
        # --- MÉTODO 1: API Especializada (youtube-transcript-api) ---
        try:
            logger.info(f"Tentando extrair com 'youtube-transcript-api' para {video_id}...")
            transcript_list = YouTubeTranscriptApi.get_transcript(video_id, languages=['pt', 'pt-BR', 'en'])
            
            raw_transcript = " ".join([item['text'] for item in transcript_list])
            
            cleaned_transcript = re.sub(r'\s+', ' ', raw_transcript).strip()
            
            logger.info(f"Transcrição obtida com sucesso via 'youtube-transcript-api' para {video_id}")

            chunks = self.split_transcript_into_chunks(cleaned_transcript)
            json_path = self.save_transcription_to_json(
                metadata['video_id'], metadata['title'], cleaned_transcript, chunks, metadata
            )
            return cleaned_transcript, metadata, json_path

        except Exception as api_error:
            logger.warning(f"Falha ao usar 'youtube-transcript-api': {api_error}. Ativando método fallback com yt-dlp.")

        # --- MÉTODO 2: Fallback com yt-dlp (se o primeiro falhar) ---
        raw_transcript, fallback_metadata = self.download_subtitles_fallback(url, video_id)
        
        if fallback_metadata and fallback_metadata.get('title'):
            metadata = fallback_metadata
        
        if not raw_transcript:
            logger.error(f"Todos os métodos falharam. Não foi possível obter legendas para: {url}")
            return None, metadata, None

        cleaned_transcript = self.clean_subtitles(raw_transcript)
        
        if not cleaned_transcript.strip() or "Erro: O Google bloqueou" in cleaned_transcript:
            logger.error(f"A transcrição limpa está vazia ou bloqueada para o vídeo: {url}")
            return None, metadata, None
            
        chunks = self.split_transcript_into_chunks(cleaned_transcript)
        json_path = self.save_transcription_to_json(
            metadata['video_id'], metadata['title'], cleaned_transcript, chunks, metadata
        )
        
        return cleaned_transcript, metadata, json_path

==========================================
Conteúdo de CHECKLIST_SISTEMA.md (caminho: doc\CHECKLIST_SISTEMA.md):
==========================================
# Checklist de Status do Projeto: Sistema de Transcrição YouTube

Este documento reflete o estado atual de implementação do sistema, com base na análise do código-fonte e nos requisitos definidos na documentação do projeto.

**Legenda:**
- `[x]` - Completo
- `[/]` - Parcialmente Implementado
- `[ ]` - Não Iniciado
- `[+]` - Funcionalidade Adicional Implementada (Não prevista inicialmente no checklist)

---

## Requisitos Funcionais (RF)

- **[x] RF-01: Transcrição de Vídeos Individuais**
  - [cite_start]O sistema processa uma URL de vídeo do YouTube, extrai a transcrição e a limpa de metadados e timestamps[cite: 3, 48, 58].

- **[ ] RF-02: Download de Arquivos de Mídia (Vídeo/Áudio)**
  - O sistema está focado exclusivamente na transcrição. [cite_start]A funcionalidade para baixar os arquivos de vídeo ou áudio (`.mp4`, `.mp3`) não foi implementada[cite: 31, 38].

- **[x] RF-03: Download da Transcrição em TXT**
  - [cite_start]A rota `/download_transcription/<video_id>` gera e disponibiliza para download um arquivo `.txt` com a transcrição limpa e formatada[cite: 6, 9, 10, 11, 12].

- **[/] RF-04: Interface de Usuário e Visualização da Transcrição**
  - [cite_start]A interface exibe o título, a miniatura (thumbnail) e o conteúdo da transcrição para um único vídeo processado[cite: 104, 105, 115, 117].
  - [cite_start]*Comentário: A exibição principal está funcional, mas faltam funcionalidades da documentação, como a barra lateral para histórico de sessões e a alternância de temas (claro/escuro)[cite: 144, 146].*

- **[/] RF-05: Persistência de Dados e Histórico**
  - [cite_start]Cada transcrição é salva individualmente em um arquivo JSON no diretório `data/transcriptions`[cite: 21, 52].
  - [cite_start]*Comentário: O armazenamento individual está implementado, mas não existe um sistema de gerenciamento de histórico ou um índice que permita ao usuário navegar entre as transcrições processadas anteriormente na interface[cite: 144].*

- **[ ] RF-06: Processamento de Playlists**
  - A lógica atual trata apenas URLs de vídeos individuais. Não há implementação para extrair e processar múltiplos vídeos de uma URL de playlist.

- **[+] [+] Divisão da Transcrição em Blocos (Chunks)** `[x]`
  - [cite_start]Uma funcionalidade implementada que divide a transcrição final em blocos de aproximadamente 300 palavras para facilitar o manuseio e a exibição[cite: 5, 50].

---

## Requisitos Não Funcionais (RNF)

- **[/] RNF-01: Responsividade da Interface**
  - [cite_start]O layout utiliza um contêiner com largura máxima, o que oferece uma fluidez básica[cite: 69].
  - *Comentário: O design não é totalmente responsivo, faltando `media queries` para se adaptar a telas menores como tablets e dispositivos móveis.*

- **[x] RNF-02: Tratamento de Erros e Feedback ao Usuário**
  - [cite_start]O backend retorna mensagens de erro claras para URLs inválidas ou vídeos sem legendas[cite: 2, 4].
  - [cite_start]O frontend exibe essas mensagens de erro em uma área de status dedicada[cite: 92, 109, 114].

- **[x] RNF-03: Sanitização de Entradas e Nomes de Arquivos**
  - [cite_start]Nomes de arquivos são sanitizados para remover caracteres inválidos antes de salvar o JSON ou gerar o nome do arquivo TXT para download[cite: 10, 17, 51].
  - [cite_start]URLs do YouTube são validadas no backend usando expressões regulares[cite: 27].

- **[ ] RNF-04: Comunicação em Tempo Real**
  - A comunicação atual é baseada em requisições HTTP (`fetch`). [cite_start]Não há implementação de WebSockets (Socket.IO) para atualizações de progresso em tempo real[cite: 100, 274].
  - [cite_start]*Comentário: A implementação difere do requisito[cite: 149]. [cite_start]O frontend exibe um indicador de processamento (`spinner`), mas não uma barra de progresso real[cite: 115, 82].*

- **[+] [+] Mecanismo de Fallback para Extração de Legendas** `[x]`
  - [cite_start]O sistema primeiro tenta obter a transcrição através de uma API especializada (`youtube-transcript-api`) e, em caso de falha, utiliza um método de fallback mais robusto com `yt-dlp` para garantir maior chance de sucesso[cite: 56, 64].

- **[+] [+] Estratégia para Evitar Bloqueios** `[x]`
  - [cite_start]O `youtube_handler` utiliza `User-Agents` de navegadores reais e insere um delay aleatório entre as requisições no método de fallback para simular comportamento humano e reduzir o risco de bloqueios por parte do YouTube[cite: 22, 24, 25].

==========================================
Conteúdo de style.css (caminho: frontend\static\css\style.css):
==========================================
/* frontend/static/css/style.css */
:root {
    --primary-color: #ff0000;
    --secondary-color: #f8f8f8;
    --text-color: #333;
    --border-color: #ddd;
    --success-color: #28a745;
    --error-color: #dc3545;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    line-height: 1.6;
    color: var(--text-color);
    background-color: #fff;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

header {
    text-align: center;
    margin-bottom: 30px;
    padding: 20px 0;
    border-bottom: 1px solid var(--border-color);
}

header h1 {
    color: var(--primary-color);
    margin-bottom: 10px;
}

.input-section {
    background-color: var(--secondary-color);
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 25px;
}

.input-group {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

#youtube-url {
    flex: 1;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 16px;
}

#process-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 0 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    transition: background-color 0.3s;
}

#process-btn:hover {
    background-color: #cc0000;
}

#process-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

.status-message {
    margin-top: 10px;
    padding: 10px;
    border-radius: 4px;
    display: none;
}

.status-message.success {
    background-color: rgba(40, 167, 69, 0.1);
    color: var(--success-color);
    display: block;
}

.status-message.error {
    background-color: rgba(220, 53, 51, 0.1);
    color: var(--error-color);
    display: block;
}

.video-info {
    background-color: var(--secondary-color);
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 25px;
}

.thumbnail-container {
    text-align: center;
    margin-bottom: 15px;
}

#video-thumbnail {
    max-width: 100%;
    border-radius: 4px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.processing-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: #666;
}

.spinner {
    border: 3px solid rgba(0, 0, 0, 0.1);
    border-top: 3px solid var(--primary-color);
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    margin-right: 10px;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.transcription-section {
    background-color: var(--secondary-color);
    padding: 20px;
    border-radius: 8px;
}

.transcription-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.download-btn {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    font-weight: bold;
}

.download-btn:hover {
    background-color: #cc0000;
}

.transcription-content {
    line-height: 1.8;
    white-space: pre-wrap;
    background-color: white;
    padding: 20px;
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.05);
    max-height: 600px;
    overflow-y: auto;
}

footer {
    text-align: center;
    margin-top: 40px;
    padding: 20px 0;
    color: #666;
    border-top: 1px solid var(--border-color);
}

==========================================
Conteúdo de main.js (caminho: frontend\static\js\main.js):
==========================================
// frontend/static/js/main.js
document.addEventListener('DOMContentLoaded', function() {
    const youtubeUrlInput = document.getElementById('youtube-url');
    const processBtn = document.getElementById('process-btn');
    const statusMessage = document.getElementById('status-message');
    const videoInfoSection = document.getElementById('video-info');
    const videoThumbnail = document.getElementById('video-thumbnail');
    const videoTitle = document.getElementById('video-title');
    const processingIndicator = document.getElementById('processing-indicator');
    const transcriptionSection = document.getElementById('transcription-section');
    const transcriptionContent = document.getElementById('transcription-content');
    const downloadBtn = document.getElementById('download-btn');
    
    // Função para exibir mensagens de status
    function showStatus(message, type = 'info') {
        statusMessage.textContent = message;
        statusMessage.className = 'status-message';
        
        if (type === 'success') {
            statusMessage.classList.add('success');
        } else if (type === 'error') {
            statusMessage.classList.add('error');
        } else {
            statusMessage.style.display = 'block';
        }
    }
    
    // Função para validar URL do YouTube
    function isValidYoutubeUrl(url) {
        const regex = /^(https?:\/\/)?(www\.)?(youtube|youtu|youtube-nocookie)\.(com|be)\/(watch\?v=|embed\/|v\/|.+\?v=)?([^&=%\?]{11})/;
        return regex.test(url);
    }
    
    // Função para processar o vídeo
    async function processVideo() {
        const url = youtubeUrlInput.value.trim();
        
        if (!url) {
            showStatus('Por favor, insira uma URL do YouTube', 'error');
            return;
        }
        
        if (!isValidYoutubeUrl(url)) {
            showStatus('URL do YouTube inválida. Por favor, insira uma URL válida do YouTube.', 'error');
            return;
        }
        
        // Resetar interface
        videoInfoSection.style.display = 'none';
        transcriptionSection.style.display = 'none';
        showStatus('Processando vídeo...', 'info');
        processBtn.disabled = true;
        
        try {
            // Mostrar indicador de processamento
            processingIndicator.style.display = 'flex';
            
            // Enviar requisição para o backend
            const response = await fetch('/process_youtube_video', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ url: url })
            });
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.error || 'Erro ao processar o vídeo');
            }
            
            // Atualizar interface com os dados do vídeo
            videoThumbnail.src = data.thumbnail || 'https://i.ytimg.com/vi/' + data.video_id + '/hqdefault.jpg';
            videoTitle.textContent = data.title;
            
            // Exibir transcrição
            transcriptionContent.textContent = data.transcript;
            
            // Atualizar elementos da interface
            videoInfoSection.style.display = 'block';
            transcriptionSection.style.display = 'block';
            processingIndicator.style.display = 'none';
            
            showStatus('Vídeo processado com sucesso!', 'success');
            
            // Configurar o botão de download
            downloadBtn.onclick = function() {
                window.location.href = `/download_transcription/${data.video_id}`;
            };
            
        } catch (error) {
            console.error('Erro:', error);
            showStatus(`Erro: ${error.message}`, 'error');
            processingIndicator.style.display = 'none';
        } finally {
            processBtn.disabled = false;
        }
    }
    
    // Event listeners
    processBtn.addEventListener('click', processVideo);
    
    youtubeUrlInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            processVideo();
        }
    });
});

==========================================
Conteúdo de index.html (caminho: frontend\templates\index.html):
==========================================
<!-- frontend/templates/index.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Transcrição e Download YouTube</title>
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Sistema de Transcrição e Download YouTube</h1>
            <p>Transforme conteúdo audiovisual em texto editável e pesquisável</p>
        </header>
        
        <main>
            <section class="input-section">
                <h2>Insira a URL do vídeo do YouTube</h2>
                <div class="input-group">
                    <input type="text" id="youtube-url" placeholder="https://www.youtube.com/watch?v=...">
                    <button id="process-btn">Processar Vídeo</button>
                </div>
                <div id="status-message" class="status-message"></div>
            </section>
            
            <section id="video-info" class="video-info" style="display: none;">
                <div class="thumbnail-container">
                    <img id="video-thumbnail" src="" alt="Thumbnail do vídeo">
                </div>
                <h2 id="video-title"></h2>
                <div id="processing-indicator" class="processing-indicator">
                    <div class="spinner"></div>
                    <span>Processando transcrição...</span>
                </div>
            </section>
            
            <section id="transcription-section" class="transcription-section" style="display: none;">
                <div class="transcription-header">
                    <h2>Transcrição Completa</h2>
                    <button id="download-btn" class="download-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                            <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
                        </svg>
                        Baixar TXT
                    </button>
                </div>
                <div id="transcription-content" class="transcription-content"></div>
            </section>
        </main>
        
        <footer>
            <p>Sistema de Transcrição e Download YouTube &copy; 2023</p>
        </footer>
    </div>
    
    <script src="/static/js/main.js"></script>
</body>
</html>


==========================================
Estrutura de pastas (relativa à Entrada):
==========================================
├── sistema-transcricao-youtube
├── backend
│   ├── app.py
│   ├── utils.py
│   └── youtube_handler.py
├── data
│   └── transcriptions
├── doc
│   └── CHECKLIST_SISTEMA.md
└── frontend
    ├── static
    │   ├── css
    │   │   └── style.css
    │   ├── images
    │   └── js
    │       └── main.js
    └── templates
        └── index.html
